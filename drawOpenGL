.//Image/bmp.cpp:11:typedef unsigned short int WORD;	/* 16-bit unsigned integer. */
.//Image/bmp.cpp:12:typedef unsigned int DWORD;			/* 32-bit unsigned integer */
.//Image/bmp.cpp:13:typedef int LONG;					/* 32-bit signed integer */
.//Image/bmp.cpp:252:    /* ignore bmih.biClrUsed - we assume a true color display, and
.//Image/bmp.cpp:254:    /* ignore bmih.biClrImportant - same reason */
.//Image/bmp.cpp:282:				img(x,img.height()-y-1)=p;
.//Image/bmp.cpp:374:			p=img(x,img.height()-y-1);
.//Image/bmp.cpp:378:			/* putc(p->a, fp), nbytes++; */
.//Image/bmp.cpp:381:		/* Padding for 32-bit boundary */
.//Image/image.cpp:92:	// Generate the in-between line segment pairs
.//Image/image.cpp:102:	// Generate the in-between morphs
.//Image/image.cpp:105:	// Cross-dissolve to get the final image
.//Image/image.h:10:/** This structure represents a 4-channel, floating point precision pixel. */
.//Image/image.h:27:/** This structure represents a 4-channel, 32-bit, RGBA pixel. */
.//Image/image.h:82:	  * of noise that should be added. The actual amount of noise added is in the range [-noise,noise].
.//Image/image.h:132:	  * The final pixel values are obtained by using Floyd-Steinberg dithering for propogating quantization errors.
.//Image/image.h:154:	/** This method scales an image using bilinear-interpolation to obtain pixel values and writes out the new image to outputImage.
.//Image/image.h:160:	/** This method scales an image using Gaussian-weighting to obtain pixel values and writes out the new image to outputImage.
.//Image/image.h:172:	/** This method rotates an image using bilinear-interpolation to obtain pixel values and writes out the new image to outputImage.
.//Image/image.h:178:	/** This method rotates an image using Gaussian-weighting to obtain pixel values and writes out the new image to outputImage.
.//Image/image.h:185:	/** This method sets the alpha-channel of the current image using the information provided in the matte image.
.//Image/image.h:191:	  * The method uses the values in the alpha-channel of the overlay image to determine how pixels should be blended.
.//Image/image.h:204:	/** This method applies a fun-filter to the current image and writes out the new image to outputImage.
.//Image/image.h:209:	/** This static method applies a Beier-Neely morph and writes out the new image to outputImage.
.//Image/image.h:211:	  * The time-step parameter, in the range of [0,1], specifies the point in the morph at which the output image should be obtained.
.//Image/image.h:221:	/** This static method cross-dissolves two image and writes out the new image to outputImage.
.//Image/image.h:222:	  * The method generates an image which is the blend of the source and destination, using the blend-weight in the range [0,1] to
.//Image/image.h:229:	/** This method returns the value of the image, sampled at position (x,y) using nearest-point sampling.
.//Image/image.h:234:	/** This method returns the value of the image, sampled at position (x,y) using bilinear-weighted sampling.
.//Image/image.h:239:	/** This method returns the value of the image, sampled at position (x,y) using Gaussian-weighted sampling.
.//Image/jpeg.cpp:17:	/* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
.//Image/jpeg.cpp:18:	my_error_ptr myerr = (my_error_ptr) cinfo->err;
.//Image/jpeg.cpp:22:	(*cinfo->err->output_message) (cinfo);
.//Image/jpeg.cpp:25:	longjmp(myerr->setjmp_buffer, 1);
.//Image/jpeg.cpp:78:	buffer = (*cinfo.mem->alloc_sarray) ((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);
.//Image/jpeg.cpp:93:			if(cinfo.output_components==1){img(i,cinfo.output_scanline-1)=p;}
.//Image/jpeg.cpp:94:			else{img(i/3,cinfo.output_scanline-1)=p;}
.//Image/lineSegments.cpp:14:	outSegments.x1=(int)(segments1.x1*(1.-weight)+segments2.x1*weight);
.//Image/lineSegments.cpp:15:	outSegments.y1=(int)(segments1.y1*(1.-weight)+segments2.y1*weight);
.//Image/lineSegments.cpp:16:	outSegments.x2=(int)(segments1.x2*(1.-weight)+segments2.x2*weight);
.//Image/lineSegments.cpp:17:	outSegments.y2=(int)(segments1.y2*(1.-weight)+segments2.y2*weight);
.//Image/lineSegments.cpp:90:		dx=x-targetX;
.//Image/lineSegments.cpp:91:		dy=y-targetY;
.//Image/lineSegments.h:14:	/** The coordinates of the end-points of the line segment.*/
.//Image/lineSegments.h:40:	/** This method sets the values (x,y) to the coordinates of the unit-vector perpendicular to the direction
.//JPEG/ckconfig.cpp:4: * Copyright (C) 1991-1994, Thomas G. Lane.
.//JPEG/ckconfig.cpp:30: * We start out with the assumption that your system has all the ANSI-standard
.//JPEG/ckconfig.cpp:49: * We try the non-BSD convention first; define NEED_BSD_STRINGS
.//JPEG/ckconfig.cpp:77: * says "typedef something-or-other size_t;".  Then, change the line below
.//JPEG/ckconfig.cpp:93:/* The next question is whether your compiler supports ANSI-style function
.//JPEG/ckconfig.cpp:105:struct methods_struct {		/* check method-pointer declarations */
.//JPEG/ckconfig.cpp:252:  else if (arg != -67) {	/* expected result for signed char */
.//JPEG/ckconfig.cpp:266:/* See whether right-shift on a long is signed or not. */
.//JPEG/ckconfig.cpp:270:  if (res == -0x7F7E80CL) {	/* expected result for signed shift */
.//JPEG/ckconfig.cpp:273:  /* see if unsigned-shift hack will fix it. */
.//JPEG/ckconfig.cpp:275:  res |= (~0L) << (32-4);
.//JPEG/ckconfig.cpp:276:  if (res == -0x7F7E80CL) {	/* expected result now? */
.//JPEG/ckconfig.cpp:293:  char signed_char_check = (char) (-67);
.//JPEG/ckconfig.cpp:303:  fprintf(outfile, "/* jconfig.h --- generated by ckconfig.c */\n");
.//JPEG/ckconfig.cpp:366:  if (is_shifting_signed(-0x7F7E80B1L))
.//JPEG/ckconfig.cpp:377:  fprintf(outfile, "#undef TWO_FILE_COMMANDLINE	/* You may need this on non-Unix systems */\n");
.//JPEG/jcapimin.cpp:4: * Copyright (C) 1994-1998, Thomas G. Lane.
.//JPEG/jcapimin.cpp:10: * needed in either the normal full-compression case or the transcoding-only
.//JPEG/jcapimin.cpp:15: * parameter-setup helper routines, jcomapi.c for routines shared by
.//JPEG/jcapimin.cpp:35:  cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
.//JPEG/jcapimin.cpp:49:    struct jpeg_error_mgr * err = cinfo->err;
.//JPEG/jcapimin.cpp:50:    void * client_data = cinfo->client_data; /* ignore Purify complaint here */
.//JPEG/jcapimin.cpp:52:    cinfo->err = err;
.//JPEG/jcapimin.cpp:53:    cinfo->client_data = client_data;
.//JPEG/jcapimin.cpp:55:  cinfo->is_decompressor = FALSE;
.//JPEG/jcapimin.cpp:61:  cinfo->progress = NULL;
.//JPEG/jcapimin.cpp:62:  cinfo->dest = NULL;
.//JPEG/jcapimin.cpp:64:  cinfo->comp_info = NULL;
.//JPEG/jcapimin.cpp:67:    cinfo->quant_tbl_ptrs[i] = NULL;
.//JPEG/jcapimin.cpp:70:    cinfo->dc_huff_tbl_ptrs[i] = NULL;
.//JPEG/jcapimin.cpp:71:    cinfo->ac_huff_tbl_ptrs[i] = NULL;
.//JPEG/jcapimin.cpp:74:  cinfo->script_space = NULL;
.//JPEG/jcapimin.cpp:76:  cinfo->input_gamma = 1.0;	/* in case application forgets */
.//JPEG/jcapimin.cpp:79:  cinfo->global_state = CSTATE_START;
.//JPEG/jcapimin.cpp:107: * Forcibly suppress or un-suppress all quantization and Huffman tables.
.//JPEG/jcapimin.cpp:114: * since it is called by jpeg_start_compress, we put it here --- otherwise
.//JPEG/jcapimin.cpp:126:    if ((qtbl = cinfo->quant_tbl_ptrs[i]) != NULL)
.//JPEG/jcapimin.cpp:127:      qtbl->sent_table = suppress;
.//JPEG/jcapimin.cpp:131:    if ((htbl = cinfo->dc_huff_tbl_ptrs[i]) != NULL)
.//JPEG/jcapimin.cpp:132:      htbl->sent_table = suppress;
.//JPEG/jcapimin.cpp:133:    if ((htbl = cinfo->ac_huff_tbl_ptrs[i]) != NULL)
.//JPEG/jcapimin.cpp:134:      htbl->sent_table = suppress;
.//JPEG/jcapimin.cpp:151:  if (cinfo->global_state == CSTATE_SCANNING ||
.//JPEG/jcapimin.cpp:152:      cinfo->global_state == CSTATE_RAW_OK) {
.//JPEG/jcapimin.cpp:154:    if (cinfo->next_scanline < cinfo->image_height)
.//JPEG/jcapimin.cpp:156:    (*cinfo->master->finish_pass) (cinfo);
.//JPEG/jcapimin.cpp:157:  } else if (cinfo->global_state != CSTATE_WRCOEFS)
.//JPEG/jcapimin.cpp:158:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jcapimin.cpp:160:  while (! cinfo->master->is_last_pass) {
.//JPEG/jcapimin.cpp:161:    (*cinfo->master->prepare_for_pass) (cinfo);
.//JPEG/jcapimin.cpp:162:    for (iMCU_row = 0; iMCU_row < cinfo->total_iMCU_rows; iMCU_row++) {
.//JPEG/jcapimin.cpp:163:      if (cinfo->progress != NULL) {
.//JPEG/jcapimin.cpp:164:	cinfo->progress->pass_counter = (long) iMCU_row;
.//JPEG/jcapimin.cpp:165:	cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows;
.//JPEG/jcapimin.cpp:166:	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//JPEG/jcapimin.cpp:171:      if (! (*cinfo->coef->compress_data) (cinfo, (JSAMPIMAGE) NULL))
.//JPEG/jcapimin.cpp:174:    (*cinfo->master->finish_pass) (cinfo);
.//JPEG/jcapimin.cpp:177:  (*cinfo->marker->write_file_trailer) (cinfo);
.//JPEG/jcapimin.cpp:178:  (*cinfo->dest->term_destination) (cinfo);
.//JPEG/jcapimin.cpp:197:  if (cinfo->next_scanline != 0 ||
.//JPEG/jcapimin.cpp:198:      (cinfo->global_state != CSTATE_SCANNING &&
.//JPEG/jcapimin.cpp:199:       cinfo->global_state != CSTATE_RAW_OK &&
.//JPEG/jcapimin.cpp:200:       cinfo->global_state != CSTATE_WRCOEFS))
.//JPEG/jcapimin.cpp:201:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jcapimin.cpp:203:  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);
.//JPEG/jcapimin.cpp:204:  write_marker_byte = cinfo->marker->write_marker_byte;	/* copy for speed */
.//JPEG/jcapimin.cpp:205:  while (datalen--) {
.//JPEG/jcapimin.cpp:216:  if (cinfo->next_scanline != 0 ||
.//JPEG/jcapimin.cpp:217:      (cinfo->global_state != CSTATE_SCANNING &&
.//JPEG/jcapimin.cpp:218:       cinfo->global_state != CSTATE_RAW_OK &&
.//JPEG/jcapimin.cpp:219:       cinfo->global_state != CSTATE_WRCOEFS))
.//JPEG/jcapimin.cpp:220:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jcapimin.cpp:222:  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);
.//JPEG/jcapimin.cpp:228:  (*cinfo->marker->write_marker_byte) (cinfo, val);
.//JPEG/jcapimin.cpp:250: * will not re-emit the tables unless it is passed write_all_tables=TRUE.
.//JPEG/jcapimin.cpp:256:  if (cinfo->global_state != CSTATE_START)
.//JPEG/jcapimin.cpp:257:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jcapimin.cpp:260:  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
.//JPEG/jcapimin.cpp:261:  (*cinfo->dest->init_destination) (cinfo);
.//JPEG/jcapimin.cpp:265:  (*cinfo->marker->write_tables_only) (cinfo);
.//JPEG/jcapimin.cpp:267:  (*cinfo->dest->term_destination) (cinfo);
.//JPEG/jcapistd.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jcapistd.cpp:10: * used in the normal full-compression case.  They are not used by a
.//JPEG/jcapistd.cpp:11: * transcoding-only application.  Note that if an application links in
.//JPEG/jcapistd.cpp:40:  if (cinfo->global_state != CSTATE_START)
.//JPEG/jcapistd.cpp:41:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jcapistd.cpp:47:  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
.//JPEG/jcapistd.cpp:48:  (*cinfo->dest->init_destination) (cinfo);
.//JPEG/jcapistd.cpp:52:  (*cinfo->master->prepare_for_pass) (cinfo);
.//JPEG/jcapistd.cpp:56:  cinfo->next_scanline = 0;
.//JPEG/jcapistd.cpp:57:  cinfo->global_state = (cinfo->raw_data_in ? CSTATE_RAW_OK : CSTATE_SCANNING);
.//JPEG/jcapistd.cpp:72: * so that the application need not adjust num_lines for end-of-image
.//JPEG/jcapistd.cpp:73: * when using a multiple-scanline buffer.
.//JPEG/jcapistd.cpp:82:  if (cinfo->global_state != CSTATE_SCANNING)
.//JPEG/jcapistd.cpp:83:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jcapistd.cpp:84:  if (cinfo->next_scanline >= cinfo->image_height)
.//JPEG/jcapistd.cpp:88:  if (cinfo->progress != NULL) {
.//JPEG/jcapistd.cpp:89:    cinfo->progress->pass_counter = (long) cinfo->next_scanline;
.//JPEG/jcapistd.cpp:90:    cinfo->progress->pass_limit = (long) cinfo->image_height;
.//JPEG/jcapistd.cpp:91:    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//JPEG/jcapistd.cpp:99:  if (cinfo->master->call_pass_startup)
.//JPEG/jcapistd.cpp:100:    (*cinfo->master->pass_startup) (cinfo);
.//JPEG/jcapistd.cpp:103:  rows_left = cinfo->image_height - cinfo->next_scanline;
.//JPEG/jcapistd.cpp:108:  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, num_lines);
.//JPEG/jcapistd.cpp:109:  cinfo->next_scanline += row_ctr;
.//JPEG/jcapistd.cpp:125:  if (cinfo->global_state != CSTATE_RAW_OK)
.//JPEG/jcapistd.cpp:126:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jcapistd.cpp:127:  if (cinfo->next_scanline >= cinfo->image_height) {
.//JPEG/jcapistd.cpp:133:  if (cinfo->progress != NULL) {
.//JPEG/jcapistd.cpp:134:    cinfo->progress->pass_counter = (long) cinfo->next_scanline;
.//JPEG/jcapistd.cpp:135:    cinfo->progress->pass_limit = (long) cinfo->image_height;
.//JPEG/jcapistd.cpp:136:    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//JPEG/jcapistd.cpp:144:  if (cinfo->master->call_pass_startup)
.//JPEG/jcapistd.cpp:145:    (*cinfo->master->pass_startup) (cinfo);
.//JPEG/jcapistd.cpp:148:  lines_per_iMCU_row = cinfo->max_v_samp_factor * DCTSIZE;
.//JPEG/jcapistd.cpp:153:  if (! (*cinfo->coef->compress_data) (cinfo, data)) {
.//JPEG/jcapistd.cpp:159:  cinfo->next_scanline += lines_per_iMCU_row;
.//JPEG/jccoefct.cpp:4: * Copyright (C) 1994-1997, Thomas G. Lane.
.//JPEG/jccoefct.cpp:10: * The coefficient buffer lies between forward-DCT and entropy encoding steps.
.//JPEG/jccoefct.cpp:18:/* We use a full-image coefficient buffer when doing Huffman optimization,
.//JPEG/jccoefct.cpp:19: * and also for writing multiple-scan JPEG files.  In all cases, the DCT
.//JPEG/jccoefct.cpp:42:  /* For single-pass compression, it's sufficient to buffer just one MCU
.//JPEG/jccoefct.cpp:48:   * In multi-pass modes, this array points to the current MCU's blocks
.//JPEG/jccoefct.cpp:53:  /* In multi-pass modes, we need a virtual block array for each component. */
.//JPEG/jccoefct.cpp:73:/* Reset within-iMCU-row counters for a new row */
.//JPEG/jccoefct.cpp:75:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jccoefct.cpp:81:  if (cinfo->comps_in_scan > 1) {
.//JPEG/jccoefct.cpp:82:    coef->MCU_rows_per_iMCU_row = 1;
.//JPEG/jccoefct.cpp:84:    if (coef->iMCU_row_num < (cinfo->total_iMCU_rows-1))
.//JPEG/jccoefct.cpp:85:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
.//JPEG/jccoefct.cpp:87:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
.//JPEG/jccoefct.cpp:90:  coef->mcu_ctr = 0;
.//JPEG/jccoefct.cpp:91:  coef->MCU_vert_offset = 0;
.//JPEG/jccoefct.cpp:102:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jccoefct.cpp:104:  coef->iMCU_row_num = 0;
.//JPEG/jccoefct.cpp:109:    if (coef->whole_image[0] != NULL)
.//JPEG/jccoefct.cpp:111:    coef->pub.compress_data = compress_data;
.//JPEG/jccoefct.cpp:115:    if (coef->whole_image[0] == NULL)
.//JPEG/jccoefct.cpp:117:    coef->pub.compress_data = compress_first_pass;
.//JPEG/jccoefct.cpp:120:    if (coef->whole_image[0] == NULL)
.//JPEG/jccoefct.cpp:122:    coef->pub.compress_data = compress_output;
.//JPEG/jccoefct.cpp:133: * Process some data in the single-pass case.
.//JPEG/jccoefct.cpp:145:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jccoefct.cpp:147:  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
.//JPEG/jccoefct.cpp:148:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//JPEG/jccoefct.cpp:154:  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
.//JPEG/jccoefct.cpp:156:    for (MCU_col_num = coef->mcu_ctr; MCU_col_num <= last_MCU_col;
.//JPEG/jccoefct.cpp:168:      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jccoefct.cpp:169:	compptr = cinfo->cur_comp_info[ci];
.//JPEG/jccoefct.cpp:170:	blockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
.//JPEG/jccoefct.cpp:171:						: compptr->last_col_width;
.//JPEG/jccoefct.cpp:172:	xpos = MCU_col_num * compptr->MCU_sample_width;
.//JPEG/jccoefct.cpp:174:	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
.//JPEG/jccoefct.cpp:175:	  if (coef->iMCU_row_num < last_iMCU_row ||
.//JPEG/jccoefct.cpp:176:	      yoffset+yindex < compptr->last_row_height) {
.//JPEG/jccoefct.cpp:177:	    (*cinfo->fdct->forward_DCT) (cinfo, compptr,
.//JPEG/jccoefct.cpp:178:					 input_buf[compptr->component_index],
.//JPEG/jccoefct.cpp:179:					 coef->MCU_buffer[blkn],
.//JPEG/jccoefct.cpp:181:	    if (blockcnt < compptr->MCU_width) {
.//JPEG/jccoefct.cpp:183:	      jzero_far((void FAR *) coef->MCU_buffer[blkn + blockcnt],
.//JPEG/jccoefct.cpp:184:			(compptr->MCU_width - blockcnt) * SIZEOF(JBLOCK));
.//JPEG/jccoefct.cpp:185:	      for (bi = blockcnt; bi < compptr->MCU_width; bi++) {
.//JPEG/jccoefct.cpp:186:		coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn+bi-1][0][0];
.//JPEG/jccoefct.cpp:191:	    jzero_far((void FAR *) coef->MCU_buffer[blkn],
.//JPEG/jccoefct.cpp:192:		      compptr->MCU_width * SIZEOF(JBLOCK));
.//JPEG/jccoefct.cpp:193:	    for (bi = 0; bi < compptr->MCU_width; bi++) {
.//JPEG/jccoefct.cpp:194:	      coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn-1][0][0];
.//JPEG/jccoefct.cpp:197:	  blkn += compptr->MCU_width;
.//JPEG/jccoefct.cpp:202:       * re-DCT the MCU on restart (a bit inefficient, could be fixed...)
.//JPEG/jccoefct.cpp:204:      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
.//JPEG/jccoefct.cpp:206:	coef->MCU_vert_offset = yoffset;
.//JPEG/jccoefct.cpp:207:	coef->mcu_ctr = MCU_col_num;
.//JPEG/jccoefct.cpp:212:    coef->mcu_ctr = 0;
.//JPEG/jccoefct.cpp:215:  coef->iMCU_row_num++;
.//JPEG/jccoefct.cpp:224: * Process some data in the first pass of a multi-pass case.
.//JPEG/jccoefct.cpp:241: * at the scan-dependent variables (MCU dimensions, etc).
.//JPEG/jccoefct.cpp:247:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jccoefct.cpp:248:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//JPEG/jccoefct.cpp:256:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jccoefct.cpp:259:    buffer = (*cinfo->mem->access_virt_barray)
.//JPEG/jccoefct.cpp:260:      ((j_common_ptr) cinfo, coef->whole_image[ci],
.//JPEG/jccoefct.cpp:261:       coef->iMCU_row_num * compptr->v_samp_factor,
.//JPEG/jccoefct.cpp:262:       (JDIMENSION) compptr->v_samp_factor, TRUE);
.//JPEG/jccoefct.cpp:263:    /* Count non-dummy DCT block rows in this iMCU row. */
.//JPEG/jccoefct.cpp:264:    if (coef->iMCU_row_num < last_iMCU_row)
.//JPEG/jccoefct.cpp:265:      block_rows = compptr->v_samp_factor;
.//JPEG/jccoefct.cpp:268:      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
.//JPEG/jccoefct.cpp:269:      if (block_rows == 0) block_rows = compptr->v_samp_factor;
.//JPEG/jccoefct.cpp:271:    blocks_across = compptr->width_in_blocks;
.//JPEG/jccoefct.cpp:272:    h_samp_factor = compptr->h_samp_factor;
.//JPEG/jccoefct.cpp:276:      ndummy = h_samp_factor - ndummy;
.//JPEG/jccoefct.cpp:277:    /* Perform DCT for all non-dummy blocks in this iMCU row.  Each call
.//JPEG/jccoefct.cpp:282:      (*cinfo->fdct->forward_DCT) (cinfo, compptr,
.//JPEG/jccoefct.cpp:290:	lastDC = thisblockrow[-1][0];
.//JPEG/jccoefct.cpp:301:    if (coef->iMCU_row_num == last_iMCU_row) {
.//JPEG/jccoefct.cpp:304:      for (block_row = block_rows; block_row < compptr->v_samp_factor;
.//JPEG/jccoefct.cpp:307:	lastblockrow = buffer[block_row-1];
.//JPEG/jccoefct.cpp:311:	  lastDC = lastblockrow[h_samp_factor-1][0];
.//JPEG/jccoefct.cpp:331: * Process some data in subsequent passes of a multi-pass case.
.//JPEG/jccoefct.cpp:343:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jccoefct.cpp:355:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jccoefct.cpp:356:    compptr = cinfo->cur_comp_info[ci];
.//JPEG/jccoefct.cpp:357:    buffer[ci] = (*cinfo->mem->access_virt_barray)
.//JPEG/jccoefct.cpp:358:      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
.//JPEG/jccoefct.cpp:359:       coef->iMCU_row_num * compptr->v_samp_factor,
.//JPEG/jccoefct.cpp:360:       (JDIMENSION) compptr->v_samp_factor, FALSE);
.//JPEG/jccoefct.cpp:364:  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
.//JPEG/jccoefct.cpp:366:    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;
.//JPEG/jccoefct.cpp:370:      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jccoefct.cpp:371:	compptr = cinfo->cur_comp_info[ci];
.//JPEG/jccoefct.cpp:372:	start_col = MCU_col_num * compptr->MCU_width;
.//JPEG/jccoefct.cpp:373:	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
.//JPEG/jccoefct.cpp:375:	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
.//JPEG/jccoefct.cpp:376:	    coef->MCU_buffer[blkn++] = buffer_ptr++;
.//JPEG/jccoefct.cpp:381:      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
.//JPEG/jccoefct.cpp:383:	coef->MCU_vert_offset = yoffset;
.//JPEG/jccoefct.cpp:384:	coef->mcu_ctr = MCU_col_num;
.//JPEG/jccoefct.cpp:389:    coef->mcu_ctr = 0;
.//JPEG/jccoefct.cpp:392:  coef->iMCU_row_num++;
.//JPEG/jccoefct.cpp:410:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jccoefct.cpp:412:  cinfo->coef = (struct jpeg_c_coef_controller *) coef;
.//JPEG/jccoefct.cpp:413:  coef->pub.start_pass = start_pass_coef;
.//JPEG/jccoefct.cpp:418:    /* Allocate a full-image virtual array for each component, */
.//JPEG/jccoefct.cpp:423:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jccoefct.cpp:425:      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
.//JPEG/jccoefct.cpp:427:	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
.//JPEG/jccoefct.cpp:428:				(long) compptr->h_samp_factor),
.//JPEG/jccoefct.cpp:429:	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
.//JPEG/jccoefct.cpp:430:				(long) compptr->v_samp_factor),
.//JPEG/jccoefct.cpp:431:	 (JDIMENSION) compptr->v_samp_factor);
.//JPEG/jccoefct.cpp:437:    /* We only need a single-MCU buffer. */
.//JPEG/jccoefct.cpp:442:      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jccoefct.cpp:445:      coef->MCU_buffer[i] = buffer + i;
.//JPEG/jccoefct.cpp:447:    coef->whole_image[0] = NULL; /* flag for no virtual arrays */
.//JPEG/jccolor.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//JPEG/jccolor.cpp:21:  /* Private state for RGB->YCC conversion */
.//JPEG/jccolor.cpp:28:/**************** RGB -> YCbCr conversion: most common case **************/
.//JPEG/jccolor.cpp:31: * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
.//JPEG/jccolor.cpp:32: * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
.//JPEG/jccolor.cpp:35: *	Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + CENTERJSAMPLE
.//JPEG/jccolor.cpp:36: *	Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + CENTERJSAMPLE
.//JPEG/jccolor.cpp:37: * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
.//JPEG/jccolor.cpp:44: * To avoid floating-point arithmetic, we represent the fractional constants
.//JPEG/jccolor.cpp:50: * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
.//JPEG/jccolor.cpp:51: * for 12-bit samples it is still acceptable.  It's not very reasonable for
.//JPEG/jccolor.cpp:52: * 16-bit samples, but if you want lossless storage you shouldn't be changing
.//JPEG/jccolor.cpp:54: * The CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included
.//JPEG/jccolor.cpp:58:#define SCALEBITS	16	/* speediest right-shift on some machines */
.//JPEG/jccolor.cpp:60:#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
.//JPEG/jccolor.cpp:82: * Initialize for RGB->YCC colorspace conversion.
.//JPEG/jccolor.cpp:88:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//JPEG/jccolor.cpp:93:  cconvert->rgb_ycc_tab = rgb_ycc_tab = (INT32 *)
.//JPEG/jccolor.cpp:94:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jccolor.cpp:101:    rgb_ycc_tab[i+R_CB_OFF] = (-FIX(0.16874)) * i;
.//JPEG/jccolor.cpp:102:    rgb_ycc_tab[i+G_CB_OFF] = (-FIX(0.33126)) * i;
.//JPEG/jccolor.cpp:103:    /* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.
.//JPEG/jccolor.cpp:105:     * not MAXJSAMPLE+1, and thus that we don't have to range-limit.
.//JPEG/jccolor.cpp:107:    rgb_ycc_tab[i+B_CB_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;
.//JPEG/jccolor.cpp:109:    rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;
.//JPEG/jccolor.cpp:111:    rgb_ycc_tab[i+G_CR_OFF] = (-FIX(0.41869)) * i;
.//JPEG/jccolor.cpp:112:    rgb_ycc_tab[i+B_CR_OFF] = (-FIX(0.08131)) * i;
.//JPEG/jccolor.cpp:120: * Note that we change from the application's interleaved-pixel format
.//JPEG/jccolor.cpp:121: * to our internal noninterleaved, one-plane-per-component format.
.//JPEG/jccolor.cpp:134:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//JPEG/jccolor.cpp:136:  register INT32 * ctab = cconvert->rgb_ycc_tab;
.//JPEG/jccolor.cpp:140:  JDIMENSION num_cols = cinfo->image_width;
.//JPEG/jccolor.cpp:142:  while (--num_rows >= 0) {
.//JPEG/jccolor.cpp:154:       * must be too; we do not need an explicit range-limiting operation.
.//JPEG/jccolor.cpp:175:/**************** Cases other than RGB -> YCbCr **************/
.//JPEG/jccolor.cpp:180: * This version handles RGB->grayscale conversion, which is the same
.//JPEG/jccolor.cpp:181: * as the RGB->Y portion of RGB->YCbCr.
.//JPEG/jccolor.cpp:190:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//JPEG/jccolor.cpp:192:  register INT32 * ctab = cconvert->rgb_ycc_tab;
.//JPEG/jccolor.cpp:196:  JDIMENSION num_cols = cinfo->image_width;
.//JPEG/jccolor.cpp:198:  while (--num_rows >= 0) {
.//JPEG/jccolor.cpp:218: * This version handles Adobe-style CMYK->YCCK conversion,
.//JPEG/jccolor.cpp:219: * where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same
.//JPEG/jccolor.cpp:229:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//JPEG/jccolor.cpp:231:  register INT32 * ctab = cconvert->rgb_ycc_tab;
.//JPEG/jccolor.cpp:235:  JDIMENSION num_cols = cinfo->image_width;
.//JPEG/jccolor.cpp:237:  while (--num_rows >= 0) {
.//JPEG/jccolor.cpp:245:      r = MAXJSAMPLE - GETJSAMPLE(inptr[0]);
.//JPEG/jccolor.cpp:246:      g = MAXJSAMPLE - GETJSAMPLE(inptr[1]);
.//JPEG/jccolor.cpp:247:      b = MAXJSAMPLE - GETJSAMPLE(inptr[2]);
.//JPEG/jccolor.cpp:248:      /* K passes through as-is */
.//JPEG/jccolor.cpp:252:       * must be too; we do not need an explicit range-limiting operation.
.//JPEG/jccolor.cpp:287:  JDIMENSION num_cols = cinfo->image_width;
.//JPEG/jccolor.cpp:288:  int instride = cinfo->input_components;
.//JPEG/jccolor.cpp:290:  while (--num_rows >= 0) {
.//JPEG/jccolor.cpp:304: * This version handles multi-component colorspaces without conversion.
.//JPEG/jccolor.cpp:317:  int nc = cinfo->num_components;
.//JPEG/jccolor.cpp:318:  JDIMENSION num_cols = cinfo->image_width;
.//JPEG/jccolor.cpp:320:  while (--num_rows >= 0) {
.//JPEG/jccolor.cpp:357:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jccolor.cpp:359:  cinfo->cconvert = (struct jpeg_color_converter *) cconvert;
.//JPEG/jccolor.cpp:361:  cconvert->pub.start_pass = null_method;
.//JPEG/jccolor.cpp:364:  switch (cinfo->in_color_space) {
.//JPEG/jccolor.cpp:366:    if (cinfo->input_components != 1)
.//JPEG/jccolor.cpp:372:    if (cinfo->input_components != RGB_PIXELSIZE)
.//JPEG/jccolor.cpp:378:    if (cinfo->input_components != 3)
.//JPEG/jccolor.cpp:384:    if (cinfo->input_components != 4)
.//JPEG/jccolor.cpp:389:    if (cinfo->input_components < 1)
.//JPEG/jccolor.cpp:395:  switch (cinfo->jpeg_color_space) {
.//JPEG/jccolor.cpp:397:    if (cinfo->num_components != 1)
.//JPEG/jccolor.cpp:399:    if (cinfo->in_color_space == JCS_GRAYSCALE)
.//JPEG/jccolor.cpp:400:      cconvert->pub.color_convert = grayscale_convert;
.//JPEG/jccolor.cpp:401:    else if (cinfo->in_color_space == JCS_RGB) {
.//JPEG/jccolor.cpp:402:      cconvert->pub.start_pass = rgb_ycc_start;
.//JPEG/jccolor.cpp:403:      cconvert->pub.color_convert = rgb_gray_convert;
.//JPEG/jccolor.cpp:404:    } else if (cinfo->in_color_space == JCS_YCbCr)
.//JPEG/jccolor.cpp:405:      cconvert->pub.color_convert = grayscale_convert;
.//JPEG/jccolor.cpp:411:    if (cinfo->num_components != 3)
.//JPEG/jccolor.cpp:413:    if (cinfo->in_color_space == JCS_RGB && RGB_PIXELSIZE == 3)
.//JPEG/jccolor.cpp:414:      cconvert->pub.color_convert = null_convert;
.//JPEG/jccolor.cpp:420:    if (cinfo->num_components != 3)
.//JPEG/jccolor.cpp:422:    if (cinfo->in_color_space == JCS_RGB) {
.//JPEG/jccolor.cpp:423:      cconvert->pub.start_pass = rgb_ycc_start;
.//JPEG/jccolor.cpp:424:      cconvert->pub.color_convert = rgb_ycc_convert;
.//JPEG/jccolor.cpp:425:    } else if (cinfo->in_color_space == JCS_YCbCr)
.//JPEG/jccolor.cpp:426:      cconvert->pub.color_convert = null_convert;
.//JPEG/jccolor.cpp:432:    if (cinfo->num_components != 4)
.//JPEG/jccolor.cpp:434:    if (cinfo->in_color_space == JCS_CMYK)
.//JPEG/jccolor.cpp:435:      cconvert->pub.color_convert = null_convert;
.//JPEG/jccolor.cpp:441:    if (cinfo->num_components != 4)
.//JPEG/jccolor.cpp:443:    if (cinfo->in_color_space == JCS_CMYK) {
.//JPEG/jccolor.cpp:444:      cconvert->pub.start_pass = rgb_ycc_start;
.//JPEG/jccolor.cpp:445:      cconvert->pub.color_convert = cmyk_ycck_convert;
.//JPEG/jccolor.cpp:446:    } else if (cinfo->in_color_space == JCS_YCCK)
.//JPEG/jccolor.cpp:447:      cconvert->pub.color_convert = null_convert;
.//JPEG/jccolor.cpp:453:    if (cinfo->jpeg_color_space != cinfo->in_color_space ||
.//JPEG/jccolor.cpp:454:	cinfo->num_components != cinfo->input_components)
.//JPEG/jccolor.cpp:456:    cconvert->pub.color_convert = null_convert;
.//JPEG/jcdctmgr.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jcdctmgr.cpp:8: * This file contains the forward-DCT management logic.
.//JPEG/jcdctmgr.cpp:28:  /* The actual post-DCT divisors --- not identical to the quant table
.//JPEG/jcdctmgr.cpp:35:  /* Same as above for the floating-point case. */
.//JPEG/jcdctmgr.cpp:46: * Verify that all referenced Q-tables are present, and set up
.//JPEG/jcdctmgr.cpp:56:  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
.//JPEG/jcdctmgr.cpp:62:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcdctmgr.cpp:64:    qtblno = compptr->quant_tbl_no;
.//JPEG/jcdctmgr.cpp:67:	cinfo->quant_tbl_ptrs[qtblno] == NULL)
.//JPEG/jcdctmgr.cpp:69:    qtbl = cinfo->quant_tbl_ptrs[qtblno];
.//JPEG/jcdctmgr.cpp:72:    switch (cinfo->dct_method) {
.//JPEG/jcdctmgr.cpp:78:      if (fdct->divisors[qtblno] == NULL) {
.//JPEG/jcdctmgr.cpp:79:	fdct->divisors[qtblno] = (DCTELEM *)
.//JPEG/jcdctmgr.cpp:80:	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcdctmgr.cpp:83:      dtbl = fdct->divisors[qtblno];
.//JPEG/jcdctmgr.cpp:85:	dtbl[i] = ((DCTELEM) qtbl->quantval[i]) << 3;
.//JPEG/jcdctmgr.cpp:112:	if (fdct->divisors[qtblno] == NULL) {
.//JPEG/jcdctmgr.cpp:113:	  fdct->divisors[qtblno] = (DCTELEM *)
.//JPEG/jcdctmgr.cpp:114:	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcdctmgr.cpp:117:	dtbl = fdct->divisors[qtblno];
.//JPEG/jcdctmgr.cpp:120:	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
.//JPEG/jcdctmgr.cpp:122:		    CONST_BITS-3);
.//JPEG/jcdctmgr.cpp:145:	if (fdct->float_divisors[qtblno] == NULL) {
.//JPEG/jcdctmgr.cpp:146:	  fdct->float_divisors[qtblno] = (FAST_FLOAT *)
.//JPEG/jcdctmgr.cpp:147:	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcdctmgr.cpp:150:	fdtbl = fdct->float_divisors[qtblno];
.//JPEG/jcdctmgr.cpp:155:	      (1.0 / (((double) qtbl->quantval[i] *
.//JPEG/jcdctmgr.cpp:187:  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
.//JPEG/jcdctmgr.cpp:188:  forward_DCT_method_ptr do_dct = fdct->do_dct;
.//JPEG/jcdctmgr.cpp:189:  DCTELEM * divisors = fdct->divisors[compptr->quant_tbl_no];
.//JPEG/jcdctmgr.cpp:196:    /* Load data into workspace, applying unsigned->signed conversion */
.//JPEG/jcdctmgr.cpp:205:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//JPEG/jcdctmgr.cpp:206:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//JPEG/jcdctmgr.cpp:207:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//JPEG/jcdctmgr.cpp:208:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//JPEG/jcdctmgr.cpp:209:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//JPEG/jcdctmgr.cpp:210:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//JPEG/jcdctmgr.cpp:211:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//JPEG/jcdctmgr.cpp:212:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//JPEG/jcdctmgr.cpp:215:	  for (elemc = DCTSIZE; elemc > 0; elemc--) {
.//JPEG/jcdctmgr.cpp:216:	    *workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//JPEG/jcdctmgr.cpp:239:	 * (at default quantization settings, more like three-quarters...)
.//JPEG/jcdctmgr.cpp:252:	  temp = -temp;
.//JPEG/jcdctmgr.cpp:255:	  temp = -temp;
.//JPEG/jcdctmgr.cpp:274:/* This version is used for floating-point DCT implementations. */
.//JPEG/jcdctmgr.cpp:277:  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
.//JPEG/jcdctmgr.cpp:278:  float_DCT_method_ptr do_dct = fdct->do_float_dct;
.//JPEG/jcdctmgr.cpp:279:  FAST_FLOAT * divisors = fdct->float_divisors[compptr->quant_tbl_no];
.//JPEG/jcdctmgr.cpp:286:    /* Load data into workspace, applying unsigned->signed conversion */
.//JPEG/jcdctmgr.cpp:295:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//JPEG/jcdctmgr.cpp:296:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//JPEG/jcdctmgr.cpp:297:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//JPEG/jcdctmgr.cpp:298:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//JPEG/jcdctmgr.cpp:299:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//JPEG/jcdctmgr.cpp:300:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//JPEG/jcdctmgr.cpp:301:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//JPEG/jcdctmgr.cpp:302:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//JPEG/jcdctmgr.cpp:305:	  for (elemc = DCTSIZE; elemc > 0; elemc--) {
.//JPEG/jcdctmgr.cpp:307:	      (GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//JPEG/jcdctmgr.cpp:328:	 * The maximum coefficient size is +-16K (for 12-bit data), so this
.//JPEG/jcdctmgr.cpp:329:	 * code should work for either 16-bit or 32-bit ints.
.//JPEG/jcdctmgr.cpp:331:	output_ptr[i] = (JCOEF) ((int) (temp + (FAST_FLOAT) 16384.5) - 16384);
.//JPEG/jcdctmgr.cpp:351:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcdctmgr.cpp:353:  cinfo->fdct = (struct jpeg_forward_dct *) fdct;
.//JPEG/jcdctmgr.cpp:354:  fdct->pub.start_pass = start_pass_fdctmgr;
.//JPEG/jcdctmgr.cpp:356:  switch (cinfo->dct_method) {
.//JPEG/jcdctmgr.cpp:359:    fdct->pub.forward_DCT = forward_DCT;
.//JPEG/jcdctmgr.cpp:360:    fdct->do_dct = jpeg_fdct_islow;
.//JPEG/jcdctmgr.cpp:365:    fdct->pub.forward_DCT = forward_DCT;
.//JPEG/jcdctmgr.cpp:366:    fdct->do_dct = jpeg_fdct_ifast;
.//JPEG/jcdctmgr.cpp:371:    fdct->pub.forward_DCT = forward_DCT_float;
.//JPEG/jcdctmgr.cpp:372:    fdct->do_float_dct = jpeg_fdct_float;
.//JPEG/jcdctmgr.cpp:382:    fdct->divisors[i] = NULL;
.//JPEG/jcdctmgr.cpp:384:    fdct->float_divisors[i] = NULL;
.//JPEG/jchuff.cpp:4:* Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jchuff.cpp:30:	INT32 put_buffer;		/* current bit-accumulation buffer */
.//JPEG/jchuff.cpp:62:	int next_restart_num;		/* next restart number to write (0-7) */
.//JPEG/jchuff.cpp:100:* Initialize for a Huffman-compressed scan.
.//JPEG/jchuff.cpp:108:	huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//JPEG/jchuff.cpp:114:		entropy->pub.encode_mcu = encode_mcu_gather;
.//JPEG/jchuff.cpp:115:		entropy->pub.finish_pass = finish_pass_gather;
.//JPEG/jchuff.cpp:120:		entropy->pub.encode_mcu = encode_mcu_huff;
.//JPEG/jchuff.cpp:121:		entropy->pub.finish_pass = finish_pass_huff;
.//JPEG/jchuff.cpp:124:	for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jchuff.cpp:125:		compptr = cinfo->cur_comp_info[ci];
.//JPEG/jchuff.cpp:126:		dctbl = compptr->dc_tbl_no;
.//JPEG/jchuff.cpp:127:		actbl = compptr->ac_tbl_no;
.//JPEG/jchuff.cpp:138:			if (entropy->dc_count_ptrs[dctbl] == NULL)
.//JPEG/jchuff.cpp:139:				entropy->dc_count_ptrs[dctbl] = (long *)
.//JPEG/jchuff.cpp:140:				(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jchuff.cpp:142:			MEMZERO(entropy->dc_count_ptrs[dctbl], 257 * SIZEOF(long));
.//JPEG/jchuff.cpp:143:			if (entropy->ac_count_ptrs[actbl] == NULL)
.//JPEG/jchuff.cpp:144:				entropy->ac_count_ptrs[actbl] = (long *)
.//JPEG/jchuff.cpp:145:				(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jchuff.cpp:147:			MEMZERO(entropy->ac_count_ptrs[actbl], 257 * SIZEOF(long));
.//JPEG/jchuff.cpp:153:				& entropy->dc_derived_tbls[dctbl]);
.//JPEG/jchuff.cpp:155:				& entropy->ac_derived_tbls[actbl]);
.//JPEG/jchuff.cpp:158:		entropy->saved.last_dc_val[ci] = 0;
.//JPEG/jchuff.cpp:162:	entropy->saved.put_buffer = 0;
.//JPEG/jchuff.cpp:163:	entropy->saved.put_bits = 0;
.//JPEG/jchuff.cpp:166:	entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jchuff.cpp:167:	entropy->next_restart_num = 0;
.//JPEG/jchuff.cpp:189:	/* Note that huffsize[] and huffcode[] are filled in code-length order,
.//JPEG/jchuff.cpp:190:	* paralleling the order of the symbols themselves in htbl->huffval[].
.//JPEG/jchuff.cpp:197:		isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
.//JPEG/jchuff.cpp:204:		(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jchuff.cpp:212:		i = (int) htbl->bits[l];
.//JPEG/jchuff.cpp:215:		while (i--)
.//JPEG/jchuff.cpp:248:	MEMZERO(dtbl->ehufsi, SIZEOF(dtbl->ehufsi));
.//JPEG/jchuff.cpp:250:	/* This is also a convenient place to check for out-of-range
.//JPEG/jchuff.cpp:258:		i = htbl->huffval[p];
.//JPEG/jchuff.cpp:259:		if (i < 0 || i > maxsymbol || dtbl->ehufsi[i])
.//JPEG/jchuff.cpp:261:		dtbl->ehufco[i] = huffcode[p];
.//JPEG/jchuff.cpp:262:		dtbl->ehufsi[i] = huffsize[p];
.//JPEG/jchuff.cpp:271:{ *(state)->next_output_byte++ = (JOCTET) (val);  \
.//JPEG/jchuff.cpp:272:	if (--(state)->free_in_buffer == 0)  \
.//JPEG/jchuff.cpp:281:	struct jpeg_destination_mgr * dest = state->cinfo->dest;
.//JPEG/jchuff.cpp:283:	if (! (*dest->empty_output_buffer) (state->cinfo))
.//JPEG/jchuff.cpp:286:	state->next_output_byte = dest->next_output_byte;
.//JPEG/jchuff.cpp:287:	state->free_in_buffer = dest->free_in_buffer;
.//JPEG/jchuff.cpp:295:* left-justified in this part.  At most 16 bits can be passed to emit_bits
.//JPEG/jchuff.cpp:307:	register int put_bits = state->cur.put_bits;
.//JPEG/jchuff.cpp:311:		ERREXIT(state->cinfo, JERR_HUFF_MISSING_CODE);
.//JPEG/jchuff.cpp:313:	put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
.//JPEG/jchuff.cpp:317:	put_buffer <<= 24 - put_bits; /* align incoming bits */
.//JPEG/jchuff.cpp:319:	put_buffer |= state->cur.put_buffer; /* and merge with old buffer contents */
.//JPEG/jchuff.cpp:329:		put_bits -= 8;
.//JPEG/jchuff.cpp:332:	state->cur.put_buffer = put_buffer; /* update state variables */
.//JPEG/jchuff.cpp:333:	state->cur.put_bits = put_bits;
.//JPEG/jchuff.cpp:344:	state->cur.put_buffer = 0;	/* and reset bit-buffer to empty */
.//JPEG/jchuff.cpp:345:	state->cur.put_bits = 0;
.//JPEG/jchuff.cpp:362:	temp = temp2 = block[0] - last_dc_val;
.//JPEG/jchuff.cpp:365:		temp = -temp;		/* temp is abs value of input */
.//JPEG/jchuff.cpp:368:		temp2--;
.//JPEG/jchuff.cpp:377:	/* Check for out-of-range coefficient values.
.//JPEG/jchuff.cpp:381:		ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
.//JPEG/jchuff.cpp:383:	/* Emit the Huffman-coded symbol for the number of bits */
.//JPEG/jchuff.cpp:384:	if (! emit_bits(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))
.//JPEG/jchuff.cpp:401:				/* if run length > 15, must emit special run-length-16 codes (0xF0) */
.//JPEG/jchuff.cpp:403:					if (! emit_bits(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))
.//JPEG/jchuff.cpp:405:					r -= 16;
.//JPEG/jchuff.cpp:410:					temp = -temp;		/* temp is abs value of input */
.//JPEG/jchuff.cpp:412:					temp2--;
.//JPEG/jchuff.cpp:419:				/* Check for out-of-range coefficient values */
.//JPEG/jchuff.cpp:421:					ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
.//JPEG/jchuff.cpp:425:				if (! emit_bits(state, actbl->ehufco[i], actbl->ehufsi[i]))
.//JPEG/jchuff.cpp:437:		/* If the last coef(s) were zero, emit an end-of-block code */
.//JPEG/jchuff.cpp:439:			if (! emit_bits(state, actbl->ehufco[0], actbl->ehufsi[0]))
.//JPEG/jchuff.cpp:461:	/* Re-initialize DC predictions to 0 */
.//JPEG/jchuff.cpp:462:	for (ci = 0; ci < state->cinfo->comps_in_scan; ci++)
.//JPEG/jchuff.cpp:463:		state->cur.last_dc_val[ci] = 0;
.//JPEG/jchuff.cpp:472:* Encode and output one MCU's worth of Huffman-compressed coefficients.
.//JPEG/jchuff.cpp:478:	huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//JPEG/jchuff.cpp:484:	state.next_output_byte = cinfo->dest->next_output_byte;
.//JPEG/jchuff.cpp:485:	state.free_in_buffer = cinfo->dest->free_in_buffer;
.//JPEG/jchuff.cpp:486:	ASSIGN_STATE(state.cur, entropy->saved);
.//JPEG/jchuff.cpp:490:	if (cinfo->restart_interval) {
.//JPEG/jchuff.cpp:491:		if (entropy->restarts_to_go == 0)
.//JPEG/jchuff.cpp:492:			if (! emit_restart(&state, entropy->next_restart_num))
.//JPEG/jchuff.cpp:497:	for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//JPEG/jchuff.cpp:498:		ci = cinfo->MCU_membership[blkn];
.//JPEG/jchuff.cpp:499:		compptr = cinfo->cur_comp_info[ci];
.//JPEG/jchuff.cpp:502:			entropy->dc_derived_tbls[compptr->dc_tbl_no],
.//JPEG/jchuff.cpp:503:			entropy->ac_derived_tbls[compptr->ac_tbl_no]))
.//JPEG/jchuff.cpp:510:	cinfo->dest->next_output_byte = state.next_output_byte;
.//JPEG/jchuff.cpp:511:	cinfo->dest->free_in_buffer = state.free_in_buffer;
.//JPEG/jchuff.cpp:512:	ASSIGN_STATE(entropy->saved, state.cur);
.//JPEG/jchuff.cpp:514:	/* Update restart-interval state too */
.//JPEG/jchuff.cpp:515:	if (cinfo->restart_interval) {
.//JPEG/jchuff.cpp:516:		if (entropy->restarts_to_go == 0) {
.//JPEG/jchuff.cpp:517:			entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jchuff.cpp:518:			entropy->next_restart_num++;
.//JPEG/jchuff.cpp:519:			entropy->next_restart_num &= 7;
.//JPEG/jchuff.cpp:521:		entropy->restarts_to_go--;
.//JPEG/jchuff.cpp:529:* Finish up at the end of a Huffman-compressed scan.
.//JPEG/jchuff.cpp:535:	huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//JPEG/jchuff.cpp:539:	state.next_output_byte = cinfo->dest->next_output_byte;
.//JPEG/jchuff.cpp:540:	state.free_in_buffer = cinfo->dest->free_in_buffer;
.//JPEG/jchuff.cpp:541:	ASSIGN_STATE(state.cur, entropy->saved);
.//JPEG/jchuff.cpp:549:	cinfo->dest->next_output_byte = state.next_output_byte;
.//JPEG/jchuff.cpp:550:	cinfo->dest->free_in_buffer = state.free_in_buffer;
.//JPEG/jchuff.cpp:551:	ASSIGN_STATE(entropy->saved, state.cur);
.//JPEG/jchuff.cpp:559:* that is to be Huffman-coded. (This process MUST agree with the code above.)
.//JPEG/jchuff.cpp:581:	temp = block[0] - last_dc_val;
.//JPEG/jchuff.cpp:583:		temp = -temp;
.//JPEG/jchuff.cpp:591:	/* Check for out-of-range coefficient values.
.//JPEG/jchuff.cpp:608:			/* if run length > 15, must emit special run-length-16 codes (0xF0) */
.//JPEG/jchuff.cpp:611:				r -= 16;
.//JPEG/jchuff.cpp:616:				temp = -temp;
.//JPEG/jchuff.cpp:622:			/* Check for out-of-range coefficient values */
.//JPEG/jchuff.cpp:633:	/* If the last coef(s) were zero, emit an end-of-block code */
.//JPEG/jchuff.cpp:640:* Trial-encode one MCU's worth of Huffman-compressed coefficients.
.//JPEG/jchuff.cpp:647:	huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//JPEG/jchuff.cpp:652:	if (cinfo->restart_interval) {
.//JPEG/jchuff.cpp:653:		if (entropy->restarts_to_go == 0) {
.//JPEG/jchuff.cpp:654:			/* Re-initialize DC predictions to 0 */
.//JPEG/jchuff.cpp:655:			for (ci = 0; ci < cinfo->comps_in_scan; ci++)
.//JPEG/jchuff.cpp:656:				entropy->saved.last_dc_val[ci] = 0;
.//JPEG/jchuff.cpp:658:			entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jchuff.cpp:660:		entropy->restarts_to_go--;
.//JPEG/jchuff.cpp:663:	for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//JPEG/jchuff.cpp:664:		ci = cinfo->MCU_membership[blkn];
.//JPEG/jchuff.cpp:665:		compptr = cinfo->cur_comp_info[ci];
.//JPEG/jchuff.cpp:666:		htest_one_block(cinfo, MCU_data[blkn][0], entropy->saved.last_dc_val[ci],
.//JPEG/jchuff.cpp:667:			entropy->dc_count_ptrs[compptr->dc_tbl_no],
.//JPEG/jchuff.cpp:668:			entropy->ac_count_ptrs[compptr->ac_tbl_no]);
.//JPEG/jchuff.cpp:669:		entropy->saved.last_dc_val[ci] = MCU_data[blkn][0][0];
.//JPEG/jchuff.cpp:689:* practice, because it produces more all-ones bytes (which incur stuffed
.//JPEG/jchuff.cpp:696:* optimal; it may not choose the best possible limited-length code.  But
.//JPEG/jchuff.cpp:697:* typically only very-low-frequency symbols will be given less-than-optimal
.//JPEG/jchuff.cpp:699:* an optimal limited-length-code algorithm indicate that the difference is
.//JPEG/jchuff.cpp:700:* microscopic --- usually less than a hundredth of a percent of total size.
.//JPEG/jchuff.cpp:720:		others[i] = -1;		/* init links to empty */
.//JPEG/jchuff.cpp:723:						/* Including the pseudo-symbol 256 in the Huffman procedure guarantees
.//JPEG/jchuff.cpp:724:						* that no real symbol is given code-value of all ones, because 256
.//JPEG/jchuff.cpp:733:		c1 = -1;
.//JPEG/jchuff.cpp:744:		c2 = -1;
.//JPEG/jchuff.cpp:801:	for (i = MAX_CLEN; i > 16; i--) {
.//JPEG/jchuff.cpp:803:			j = i - 2;		/* find length of new prefix to be used */
.//JPEG/jchuff.cpp:805:				j--;
.//JPEG/jchuff.cpp:807:			bits[i] -= 2;		/* remove two symbols */
.//JPEG/jchuff.cpp:808:			bits[i-1]++;		/* one goes in this length */
.//JPEG/jchuff.cpp:810:			bits[j]--;		/* symbol of this length is now a prefix */
.//JPEG/jchuff.cpp:814:	/* Remove the count for the pseudo-symbol 256 from the largest codelength */
.//JPEG/jchuff.cpp:816:		i--;
.//JPEG/jchuff.cpp:817:	bits[i]--;
.//JPEG/jchuff.cpp:820:	MEMCOPY(htbl->bits, bits, SIZEOF(htbl->bits));
.//JPEG/jchuff.cpp:830:				htbl->huffval[p] = (UINT8) j;
.//JPEG/jchuff.cpp:837:	htbl->sent_table = FALSE;
.//JPEG/jchuff.cpp:842:* Finish up a statistics-gathering pass and create the new Huffman tables.
.//JPEG/jchuff.cpp:848:	huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//JPEG/jchuff.cpp:861:	for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jchuff.cpp:862:		compptr = cinfo->cur_comp_info[ci];
.//JPEG/jchuff.cpp:863:		dctbl = compptr->dc_tbl_no;
.//JPEG/jchuff.cpp:864:		actbl = compptr->ac_tbl_no;
.//JPEG/jchuff.cpp:866:			htblptr = & cinfo->dc_huff_tbl_ptrs[dctbl];
.//JPEG/jchuff.cpp:869:			jpeg_gen_optimal_table(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);
.//JPEG/jchuff.cpp:873:			htblptr = & cinfo->ac_huff_tbl_ptrs[actbl];
.//JPEG/jchuff.cpp:876:			jpeg_gen_optimal_table(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);
.//JPEG/jchuff.cpp:897:		(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jchuff.cpp:899:	cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
.//JPEG/jchuff.cpp:900:	entropy->pub.start_pass = start_pass_huff;
.//JPEG/jchuff.cpp:904:		entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
.//JPEG/jchuff.cpp:906:		entropy->dc_count_ptrs[i] = entropy->ac_count_ptrs[i] = NULL;
.//JPEG/jchuff.h:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jchuff.h:14: *  -1024 .. +1023  for 8-bit data;
.//JPEG/jchuff.h:15: * -16384 .. +16383 for 12-bit data.
.//JPEG/jchuff.h:33:/* Short forms of external names for systems with brain-damaged linkers. */
.//JPEG/jcinit.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jcinit.cpp:14: * For a transcoding-only application, we want to be able to use jcmaster.c
.//JPEG/jcinit.cpp:36:  if (! cinfo->raw_data_in) {
.//JPEG/jcinit.cpp:44:  if (cinfo->arith_code) {
.//JPEG/jcinit.cpp:47:    if (cinfo->progressive_mode) {
.//JPEG/jcinit.cpp:57:  /* Need a full-image coefficient buffer in any multi-pass mode. */
.//JPEG/jcinit.cpp:59:		(boolean) (cinfo->num_scans > 1 || cinfo->optimize_coding));
.//JPEG/jcinit.cpp:65:  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
.//JPEG/jcinit.cpp:71:  (*cinfo->marker->write_file_header) (cinfo);
.//JPEG/jcmainct.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jcmainct.cpp:9: * The main buffer lies between the pre-processor and the JPEG
.//JPEG/jcmainct.cpp:18:/* Note: currently, there is no operating mode in which a full-image buffer
.//JPEG/jcmainct.cpp:37:   * (we allocate one for each component).  In the full-image case, this
.//JPEG/jcmainct.cpp:43:  /* If using full-image storage, this array holds pointers to virtual-array
.//JPEG/jcmainct.cpp:44:   * control blocks for each component.  Unused if not full-image storage.
.//JPEG/jcmainct.cpp:71:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//JPEG/jcmainct.cpp:73:  /* Do nothing in raw-data mode. */
.//JPEG/jcmainct.cpp:74:  if (cinfo->raw_data_in)
.//JPEG/jcmainct.cpp:77:  main->cur_iMCU_row = 0;	/* initialize counters */
.//JPEG/jcmainct.cpp:78:  main->rowgroup_ctr = 0;
.//JPEG/jcmainct.cpp:79:  main->suspended = FALSE;
.//JPEG/jcmainct.cpp:80:  main->pass_mode = pass_mode;	/* save mode for use by process_data */
.//JPEG/jcmainct.cpp:85:    if (main->whole_image[0] != NULL)
.//JPEG/jcmainct.cpp:88:    main->pub.process_data = process_data_simple_main;
.//JPEG/jcmainct.cpp:94:    if (main->whole_image[0] == NULL)
.//JPEG/jcmainct.cpp:96:    main->pub.process_data = process_data_buffer_main;
.//JPEG/jcmainct.cpp:108: * This routine handles the simple pass-through mode,
.//JPEG/jcmainct.cpp:117:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//JPEG/jcmainct.cpp:119:  while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
.//JPEG/jcmainct.cpp:121:    if (main->rowgroup_ctr < DCTSIZE)
.//JPEG/jcmainct.cpp:122:      (*cinfo->prep->pre_process_data) (cinfo,
.//JPEG/jcmainct.cpp:124:					main->buffer, &main->rowgroup_ctr,
.//JPEG/jcmainct.cpp:131:    if (main->rowgroup_ctr != DCTSIZE)
.//JPEG/jcmainct.cpp:135:    if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
.//JPEG/jcmainct.cpp:142:      if (! main->suspended) {
.//JPEG/jcmainct.cpp:143:	(*in_row_ctr)--;
.//JPEG/jcmainct.cpp:144:	main->suspended = TRUE;
.//JPEG/jcmainct.cpp:151:    if (main->suspended) {
.//JPEG/jcmainct.cpp:153:      main->suspended = FALSE;
.//JPEG/jcmainct.cpp:155:    main->rowgroup_ctr = 0;
.//JPEG/jcmainct.cpp:156:    main->cur_iMCU_row++;
.//JPEG/jcmainct.cpp:165: * This routine handles all of the modes that use a full-size buffer.
.//JPEG/jcmainct.cpp:173:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//JPEG/jcmainct.cpp:176:  boolean writing = (main->pass_mode != JBUF_CRANK_DEST);
.//JPEG/jcmainct.cpp:178:  while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
.//JPEG/jcmainct.cpp:180:    if (main->rowgroup_ctr == 0) {
.//JPEG/jcmainct.cpp:181:      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcmainct.cpp:183:	main->buffer[ci] = (*cinfo->mem->access_virt_sarray)
.//JPEG/jcmainct.cpp:184:	  ((j_common_ptr) cinfo, main->whole_image[ci],
.//JPEG/jcmainct.cpp:185:	   main->cur_iMCU_row * (compptr->v_samp_factor * DCTSIZE),
.//JPEG/jcmainct.cpp:186:	   (JDIMENSION) (compptr->v_samp_factor * DCTSIZE), writing);
.//JPEG/jcmainct.cpp:190:	*in_row_ctr += cinfo->max_v_samp_factor * DCTSIZE;
.//JPEG/jcmainct.cpp:191:	main->rowgroup_ctr = DCTSIZE;
.//JPEG/jcmainct.cpp:198:      (*cinfo->prep->pre_process_data) (cinfo,
.//JPEG/jcmainct.cpp:200:					main->buffer, &main->rowgroup_ctr,
.//JPEG/jcmainct.cpp:203:      if (main->rowgroup_ctr < DCTSIZE)
.//JPEG/jcmainct.cpp:207:    /* Emit data, unless this is a sink-only pass. */
.//JPEG/jcmainct.cpp:208:    if (main->pass_mode != JBUF_SAVE_SOURCE) {
.//JPEG/jcmainct.cpp:209:      if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
.//JPEG/jcmainct.cpp:216:	if (! main->suspended) {
.//JPEG/jcmainct.cpp:217:	  (*in_row_ctr)--;
.//JPEG/jcmainct.cpp:218:	  main->suspended = TRUE;
.//JPEG/jcmainct.cpp:225:      if (main->suspended) {
.//JPEG/jcmainct.cpp:227:	main->suspended = FALSE;
.//JPEG/jcmainct.cpp:232:    main->rowgroup_ctr = 0;
.//JPEG/jcmainct.cpp:233:    main->cur_iMCU_row++;
.//JPEG/jcmainct.cpp:252:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcmainct.cpp:254:  cinfo->main = (struct jpeg_c_main_controller *) main;
.//JPEG/jcmainct.cpp:255:  main->pub.start_pass = start_pass_main;
.//JPEG/jcmainct.cpp:257:  /* We don't need to create a buffer in raw-data mode. */
.//JPEG/jcmainct.cpp:258:  if (cinfo->raw_data_in)
.//JPEG/jcmainct.cpp:266:    /* Allocate a full-image virtual array for each component */
.//JPEG/jcmainct.cpp:268:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcmainct.cpp:270:      main->whole_image[ci] = (*cinfo->mem->request_virt_sarray)
.//JPEG/jcmainct.cpp:272:	 compptr->width_in_blocks * DCTSIZE,
.//JPEG/jcmainct.cpp:273:	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
.//JPEG/jcmainct.cpp:274:				(long) compptr->v_samp_factor) * DCTSIZE,
.//JPEG/jcmainct.cpp:275:	 (JDIMENSION) (compptr->v_samp_factor * DCTSIZE));
.//JPEG/jcmainct.cpp:282:    main->whole_image[0] = NULL; /* flag for no virtual arrays */
.//JPEG/jcmainct.cpp:285:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcmainct.cpp:287:      main->buffer[ci] = (*cinfo->mem->alloc_sarray)
.//JPEG/jcmainct.cpp:289:	 compptr->width_in_blocks * DCTSIZE,
.//JPEG/jcmainct.cpp:290:	 (JDIMENSION) (compptr->v_samp_factor * DCTSIZE));
.//JPEG/jcmarker.cpp:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//JPEG/jcmarker.cpp:100: * enough buffer space for the initial markers (typ. 600-700 bytes) before
.//JPEG/jcmarker.cpp:111:  struct jpeg_destination_mgr * dest = cinfo->dest;
.//JPEG/jcmarker.cpp:113:  *(dest->next_output_byte)++ = (JOCTET) val;
.//JPEG/jcmarker.cpp:114:  if (--dest->free_in_buffer == 0) {
.//JPEG/jcmarker.cpp:115:    if (! (*dest->empty_output_buffer) (cinfo))
.//JPEG/jcmarker.cpp:132:/* Emit a 2-byte integer; these are always MSB first in JPEG files */
.//JPEG/jcmarker.cpp:148:  JQUANT_TBL * qtbl = cinfo->quant_tbl_ptrs[index];
.//JPEG/jcmarker.cpp:157:    if (qtbl->quantval[i] > 255)
.//JPEG/jcmarker.cpp:161:  if (! qtbl->sent_table) {
.//JPEG/jcmarker.cpp:170:      unsigned int qval = qtbl->quantval[jpeg_natural_order[i]];
.//JPEG/jcmarker.cpp:176:    qtbl->sent_table = TRUE;
.//JPEG/jcmarker.cpp:191:    htbl = cinfo->ac_huff_tbl_ptrs[index];
.//JPEG/jcmarker.cpp:194:    htbl = cinfo->dc_huff_tbl_ptrs[index];
.//JPEG/jcmarker.cpp:200:  if (! htbl->sent_table) {
.//JPEG/jcmarker.cpp:205:      length += htbl->bits[i];
.//JPEG/jcmarker.cpp:211:      emit_byte(cinfo, htbl->bits[i]);
.//JPEG/jcmarker.cpp:214:      emit_byte(cinfo, htbl->huffval[i]);
.//JPEG/jcmarker.cpp:216:    htbl->sent_table = TRUE;
.//JPEG/jcmarker.cpp:236:  for (i = 0; i < cinfo->comps_in_scan; i++) {
.//JPEG/jcmarker.cpp:237:    compptr = cinfo->cur_comp_info[i];
.//JPEG/jcmarker.cpp:238:    dc_in_use[compptr->dc_tbl_no] = 1;
.//JPEG/jcmarker.cpp:239:    ac_in_use[compptr->ac_tbl_no] = 1;
.//JPEG/jcmarker.cpp:253:      emit_byte(cinfo, cinfo->arith_dc_L[i] + (cinfo->arith_dc_U[i]<<4));
.//JPEG/jcmarker.cpp:257:      emit_byte(cinfo, cinfo->arith_ac_K[i]);
.//JPEG/jcmarker.cpp:272:  emit_2bytes(cinfo, (int) cinfo->restart_interval);
.//JPEG/jcmarker.cpp:285:  emit_2bytes(cinfo, 3 * cinfo->num_components + 2 + 5 + 1); /* length */
.//JPEG/jcmarker.cpp:288:  if ((long) cinfo->image_height > 65535L ||
.//JPEG/jcmarker.cpp:289:      (long) cinfo->image_width > 65535L)
.//JPEG/jcmarker.cpp:292:  emit_byte(cinfo, cinfo->data_precision);
.//JPEG/jcmarker.cpp:293:  emit_2bytes(cinfo, (int) cinfo->image_height);
.//JPEG/jcmarker.cpp:294:  emit_2bytes(cinfo, (int) cinfo->image_width);
.//JPEG/jcmarker.cpp:296:  emit_byte(cinfo, cinfo->num_components);
.//JPEG/jcmarker.cpp:298:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcmarker.cpp:300:    emit_byte(cinfo, compptr->component_id);
.//JPEG/jcmarker.cpp:301:    emit_byte(cinfo, (compptr->h_samp_factor << 4) + compptr->v_samp_factor);
.//JPEG/jcmarker.cpp:302:    emit_byte(cinfo, compptr->quant_tbl_no);
.//JPEG/jcmarker.cpp:316:  emit_2bytes(cinfo, 2 * cinfo->comps_in_scan + 2 + 1 + 3); /* length */
.//JPEG/jcmarker.cpp:318:  emit_byte(cinfo, cinfo->comps_in_scan);
.//JPEG/jcmarker.cpp:320:  for (i = 0; i < cinfo->comps_in_scan; i++) {
.//JPEG/jcmarker.cpp:321:    compptr = cinfo->cur_comp_info[i];
.//JPEG/jcmarker.cpp:322:    emit_byte(cinfo, compptr->component_id);
.//JPEG/jcmarker.cpp:323:    td = compptr->dc_tbl_no;
.//JPEG/jcmarker.cpp:324:    ta = compptr->ac_tbl_no;
.//JPEG/jcmarker.cpp:325:    if (cinfo->progressive_mode) {
.//JPEG/jcmarker.cpp:331:      if (cinfo->Ss == 0) {
.//JPEG/jcmarker.cpp:333:	if (cinfo->Ah != 0 && !cinfo->arith_code)
.//JPEG/jcmarker.cpp:342:  emit_byte(cinfo, cinfo->Ss);
.//JPEG/jcmarker.cpp:343:  emit_byte(cinfo, cinfo->Se);
.//JPEG/jcmarker.cpp:344:  emit_byte(cinfo, (cinfo->Ah << 4) + cinfo->Al);
.//JPEG/jcmarker.cpp:350:/* Emit a JFIF-compliant APP0 marker */
.//JPEG/jcmarker.cpp:354:   * Block ID			(4 bytes - ASCII "JFIF")
.//JPEG/jcmarker.cpp:356:   * Version Major, Minor	(2 bytes - major first)
.//JPEG/jcmarker.cpp:357:   * Units			(1 byte - 0x00 = none, 0x01 = inch, 0x02 = cm)
.//JPEG/jcmarker.cpp:358:   * Xdpu			(2 bytes - dots per unit horizontal)
.//JPEG/jcmarker.cpp:359:   * Ydpu			(2 bytes - dots per unit vertical)
.//JPEG/jcmarker.cpp:373:  emit_byte(cinfo, cinfo->JFIF_major_version); /* Version fields */
.//JPEG/jcmarker.cpp:374:  emit_byte(cinfo, cinfo->JFIF_minor_version);
.//JPEG/jcmarker.cpp:375:  emit_byte(cinfo, cinfo->density_unit); /* Pixel size information */
.//JPEG/jcmarker.cpp:376:  emit_2bytes(cinfo, (int) cinfo->X_density);
.//JPEG/jcmarker.cpp:377:  emit_2bytes(cinfo, (int) cinfo->Y_density);
.//JPEG/jcmarker.cpp:389:   * Block ID			(5 bytes - ASCII "Adobe")
.//JPEG/jcmarker.cpp:390:   * Version Number		(2 bytes - currently 100)
.//JPEG/jcmarker.cpp:391:   * Flags0			(2 bytes - currently 0)
.//JPEG/jcmarker.cpp:392:   * Flags1			(2 bytes - currently 0)
.//JPEG/jcmarker.cpp:415:  switch (cinfo->jpeg_color_space) {
.//JPEG/jcmarker.cpp:471:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//JPEG/jcmarker.cpp:476:  marker->last_restart_interval = 0;
.//JPEG/jcmarker.cpp:478:  if (cinfo->write_JFIF_header)	/* next an optional JFIF APP0 */
.//JPEG/jcmarker.cpp:480:  if (cinfo->write_Adobe_marker) /* next an optional Adobe APP14 */
.//JPEG/jcmarker.cpp:490: * try to error-check the quant table numbers as soon as they see the SOF.
.//JPEG/jcmarker.cpp:504:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcmarker.cpp:506:    prec += emit_dqt(cinfo, compptr->quant_tbl_no);
.//JPEG/jcmarker.cpp:508:  /* now prec is nonzero iff there are any 16-bit quant tables. */
.//JPEG/jcmarker.cpp:510:  /* Check for a non-baseline specification.
.//JPEG/jcmarker.cpp:513:  if (cinfo->arith_code || cinfo->progressive_mode ||
.//JPEG/jcmarker.cpp:514:      cinfo->data_precision != 8) {
.//JPEG/jcmarker.cpp:518:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcmarker.cpp:520:      if (compptr->dc_tbl_no > 1 || compptr->ac_tbl_no > 1)
.//JPEG/jcmarker.cpp:531:  if (cinfo->arith_code) {
.//JPEG/jcmarker.cpp:534:    if (cinfo->progressive_mode)
.//JPEG/jcmarker.cpp:539:      emit_sof(cinfo, M_SOF1);	/* SOF code for non-baseline Huffman file */
.//JPEG/jcmarker.cpp:553:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//JPEG/jcmarker.cpp:557:  if (cinfo->arith_code) {
.//JPEG/jcmarker.cpp:567:    for (i = 0; i < cinfo->comps_in_scan; i++) {
.//JPEG/jcmarker.cpp:568:      compptr = cinfo->cur_comp_info[i];
.//JPEG/jcmarker.cpp:569:      if (cinfo->progressive_mode) {
.//JPEG/jcmarker.cpp:571:	if (cinfo->Ss == 0) {
.//JPEG/jcmarker.cpp:572:	  if (cinfo->Ah == 0)	/* DC needs no table for refinement scan */
.//JPEG/jcmarker.cpp:573:	    emit_dht(cinfo, compptr->dc_tbl_no, FALSE);
.//JPEG/jcmarker.cpp:575:	  emit_dht(cinfo, compptr->ac_tbl_no, TRUE);
.//JPEG/jcmarker.cpp:579:	emit_dht(cinfo, compptr->dc_tbl_no, FALSE);
.//JPEG/jcmarker.cpp:580:	emit_dht(cinfo, compptr->ac_tbl_no, TRUE);
.//JPEG/jcmarker.cpp:585:  /* Emit DRI if required --- note that DRI value could change for each scan.
.//JPEG/jcmarker.cpp:588:  if (cinfo->restart_interval != marker->last_restart_interval) {
.//JPEG/jcmarker.cpp:590:    marker->last_restart_interval = cinfo->restart_interval;
.//JPEG/jcmarker.cpp:609: * Write an abbreviated table-specification datastream.
.//JPEG/jcmarker.cpp:623:    if (cinfo->quant_tbl_ptrs[i] != NULL)
.//JPEG/jcmarker.cpp:627:  if (! cinfo->arith_code) {
.//JPEG/jcmarker.cpp:629:      if (cinfo->dc_huff_tbl_ptrs[i] != NULL)
.//JPEG/jcmarker.cpp:631:      if (cinfo->ac_huff_tbl_ptrs[i] != NULL)
.//JPEG/jcmarker.cpp:651:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcmarker.cpp:653:  cinfo->marker = (struct jpeg_marker_writer *) marker;
.//JPEG/jcmarker.cpp:655:  marker->pub.write_file_header = write_file_header;
.//JPEG/jcmarker.cpp:656:  marker->pub.write_frame_header = write_frame_header;
.//JPEG/jcmarker.cpp:657:  marker->pub.write_scan_header = write_scan_header;
.//JPEG/jcmarker.cpp:658:  marker->pub.write_file_trailer = write_file_trailer;
.//JPEG/jcmarker.cpp:659:  marker->pub.write_tables_only = write_tables_only;
.//JPEG/jcmarker.cpp:660:  marker->pub.write_marker_header = write_marker_header;
.//JPEG/jcmarker.cpp:661:  marker->pub.write_marker_byte = write_marker_byte;
.//JPEG/jcmarker.cpp:663:  marker->last_restart_interval = 0;
.//JPEG/jcmaster.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jcmaster.cpp:10: * and inter-pass control (determining the number of passes and the work 
.//JPEG/jcmaster.cpp:55:  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
.//JPEG/jcmaster.cpp:56:      || cinfo->num_components <= 0 || cinfo->input_components <= 0)
.//JPEG/jcmaster.cpp:60:  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
.//JPEG/jcmaster.cpp:61:      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
.//JPEG/jcmaster.cpp:65:  samplesperrow = (long) cinfo->image_width * (long) cinfo->input_components;
.//JPEG/jcmaster.cpp:70:  /* For now, precision must match compiled-in value... */
.//JPEG/jcmaster.cpp:71:  if (cinfo->data_precision != BITS_IN_JSAMPLE)
.//JPEG/jcmaster.cpp:72:    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
.//JPEG/jcmaster.cpp:75:  if (cinfo->num_components > MAX_COMPONENTS)
.//JPEG/jcmaster.cpp:76:    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
.//JPEG/jcmaster.cpp:80:  cinfo->max_h_samp_factor = 1;
.//JPEG/jcmaster.cpp:81:  cinfo->max_v_samp_factor = 1;
.//JPEG/jcmaster.cpp:82:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcmaster.cpp:84:    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
.//JPEG/jcmaster.cpp:85:	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
.//JPEG/jcmaster.cpp:87:    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
.//JPEG/jcmaster.cpp:88:				   compptr->h_samp_factor);
.//JPEG/jcmaster.cpp:89:    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
.//JPEG/jcmaster.cpp:90:				   compptr->v_samp_factor);
.//JPEG/jcmaster.cpp:94:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcmaster.cpp:97:    compptr->component_index = ci;
.//JPEG/jcmaster.cpp:99:    compptr->DCT_scaled_size = DCTSIZE;
.//JPEG/jcmaster.cpp:101:    compptr->width_in_blocks = (JDIMENSION)
.//JPEG/jcmaster.cpp:102:      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
.//JPEG/jcmaster.cpp:103:		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
.//JPEG/jcmaster.cpp:104:    compptr->height_in_blocks = (JDIMENSION)
.//JPEG/jcmaster.cpp:105:      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
.//JPEG/jcmaster.cpp:106:		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
.//JPEG/jcmaster.cpp:108:    compptr->downsampled_width = (JDIMENSION)
.//JPEG/jcmaster.cpp:109:      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
.//JPEG/jcmaster.cpp:110:		    (long) cinfo->max_h_samp_factor);
.//JPEG/jcmaster.cpp:111:    compptr->downsampled_height = (JDIMENSION)
.//JPEG/jcmaster.cpp:112:      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
.//JPEG/jcmaster.cpp:113:		    (long) cinfo->max_v_samp_factor);
.//JPEG/jcmaster.cpp:115:    compptr->component_needed = TRUE;
.//JPEG/jcmaster.cpp:121:  cinfo->total_iMCU_rows = (JDIMENSION)
.//JPEG/jcmaster.cpp:122:    jdiv_round_up((long) cinfo->image_height,
.//JPEG/jcmaster.cpp:123:		  (long) (cinfo->max_v_samp_factor*DCTSIZE));
.//JPEG/jcmaster.cpp:131:/* Verify that the scan script in cinfo->scan_info[] is valid; also
.//JPEG/jcmaster.cpp:132: * determine whether it uses progressive JPEG, and set cinfo->progressive_mode.
.//JPEG/jcmaster.cpp:142:  /* -1 until that coefficient has been seen; then last Al for it */
.//JPEG/jcmaster.cpp:145:  if (cinfo->num_scans <= 0)
.//JPEG/jcmaster.cpp:148:  /* For sequential JPEG, all scans must have Ss=0, Se=DCTSIZE2-1;
.//JPEG/jcmaster.cpp:151:  scanptr = cinfo->scan_info;
.//JPEG/jcmaster.cpp:152:  if (scanptr->Ss != 0 || scanptr->Se != DCTSIZE2-1) {
.//JPEG/jcmaster.cpp:154:    cinfo->progressive_mode = TRUE;
.//JPEG/jcmaster.cpp:156:    for (ci = 0; ci < cinfo->num_components; ci++) 
.//JPEG/jcmaster.cpp:158:	*last_bitpos_ptr++ = -1;
.//JPEG/jcmaster.cpp:163:    cinfo->progressive_mode = FALSE;
.//JPEG/jcmaster.cpp:164:    for (ci = 0; ci < cinfo->num_components; ci++) 
.//JPEG/jcmaster.cpp:168:  for (scanno = 1; scanno <= cinfo->num_scans; scanptr++, scanno++) {
.//JPEG/jcmaster.cpp:170:    ncomps = scanptr->comps_in_scan;
.//JPEG/jcmaster.cpp:174:      thisi = scanptr->component_index[ci];
.//JPEG/jcmaster.cpp:175:      if (thisi < 0 || thisi >= cinfo->num_components)
.//JPEG/jcmaster.cpp:178:      if (ci > 0 && thisi <= scanptr->component_index[ci-1])
.//JPEG/jcmaster.cpp:182:    Ss = scanptr->Ss;
.//JPEG/jcmaster.cpp:183:    Se = scanptr->Se;
.//JPEG/jcmaster.cpp:184:    Ah = scanptr->Ah;
.//JPEG/jcmaster.cpp:185:    Al = scanptr->Al;
.//JPEG/jcmaster.cpp:186:    if (cinfo->progressive_mode) {
.//JPEG/jcmaster.cpp:190:       * Perhaps they really meant 0..N+1 for N-bit precision.
.//JPEG/jcmaster.cpp:191:       * Here we allow 0..10 for 8-bit data; Al larger than 10 results in
.//JPEG/jcmaster.cpp:192:       * out-of-range reconstructed DC values during the first DC scan,
.//JPEG/jcmaster.cpp:211:	last_bitpos_ptr = & last_bitpos[scanptr->component_index[ci]][0];
.//JPEG/jcmaster.cpp:221:	    if (Ah != last_bitpos_ptr[coefi] || Al != Ah-1)
.//JPEG/jcmaster.cpp:230:      if (Ss != 0 || Se != DCTSIZE2-1 || Ah != 0 || Al != 0)
.//JPEG/jcmaster.cpp:234:	thisi = scanptr->component_index[ci];
.//JPEG/jcmaster.cpp:243:  if (cinfo->progressive_mode) {
.//JPEG/jcmaster.cpp:250:    for (ci = 0; ci < cinfo->num_components; ci++) {
.//JPEG/jcmaster.cpp:256:    for (ci = 0; ci < cinfo->num_components; ci++) {
.//JPEG/jcmaster.cpp:273:  if (cinfo->scan_info != NULL) {
.//JPEG/jcmaster.cpp:274:    /* Prepare for current scan --- the script is already validated */
.//JPEG/jcmaster.cpp:275:    my_master_ptr master = (my_master_ptr) cinfo->master;
.//JPEG/jcmaster.cpp:276:    const jpeg_scan_info * scanptr = cinfo->scan_info + master->scan_number;
.//JPEG/jcmaster.cpp:278:    cinfo->comps_in_scan = scanptr->comps_in_scan;
.//JPEG/jcmaster.cpp:279:    for (ci = 0; ci < scanptr->comps_in_scan; ci++) {
.//JPEG/jcmaster.cpp:280:      cinfo->cur_comp_info[ci] =
.//JPEG/jcmaster.cpp:281:	&cinfo->comp_info[scanptr->component_index[ci]];
.//JPEG/jcmaster.cpp:283:    cinfo->Ss = scanptr->Ss;
.//JPEG/jcmaster.cpp:284:    cinfo->Se = scanptr->Se;
.//JPEG/jcmaster.cpp:285:    cinfo->Ah = scanptr->Ah;
.//JPEG/jcmaster.cpp:286:    cinfo->Al = scanptr->Al;
.//JPEG/jcmaster.cpp:291:    /* Prepare for single sequential-JPEG scan containing all components */
.//JPEG/jcmaster.cpp:292:    if (cinfo->num_components > MAX_COMPS_IN_SCAN)
.//JPEG/jcmaster.cpp:293:      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
.//JPEG/jcmaster.cpp:295:    cinfo->comps_in_scan = cinfo->num_components;
.//JPEG/jcmaster.cpp:296:    for (ci = 0; ci < cinfo->num_components; ci++) {
.//JPEG/jcmaster.cpp:297:      cinfo->cur_comp_info[ci] = &cinfo->comp_info[ci];
.//JPEG/jcmaster.cpp:299:    cinfo->Ss = 0;
.//JPEG/jcmaster.cpp:300:    cinfo->Se = DCTSIZE2-1;
.//JPEG/jcmaster.cpp:301:    cinfo->Ah = 0;
.//JPEG/jcmaster.cpp:302:    cinfo->Al = 0;
.//JPEG/jcmaster.cpp:310:/* cinfo->comps_in_scan and cinfo->cur_comp_info[] are already set */
.//JPEG/jcmaster.cpp:315:  if (cinfo->comps_in_scan == 1) {
.//JPEG/jcmaster.cpp:317:    /* Noninterleaved (single-component) scan */
.//JPEG/jcmaster.cpp:318:    compptr = cinfo->cur_comp_info[0];
.//JPEG/jcmaster.cpp:321:    cinfo->MCUs_per_row = compptr->width_in_blocks;
.//JPEG/jcmaster.cpp:322:    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
.//JPEG/jcmaster.cpp:325:    compptr->MCU_width = 1;
.//JPEG/jcmaster.cpp:326:    compptr->MCU_height = 1;
.//JPEG/jcmaster.cpp:327:    compptr->MCU_blocks = 1;
.//JPEG/jcmaster.cpp:328:    compptr->MCU_sample_width = DCTSIZE;
.//JPEG/jcmaster.cpp:329:    compptr->last_col_width = 1;
.//JPEG/jcmaster.cpp:333:    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
.//JPEG/jcmaster.cpp:334:    if (tmp == 0) tmp = compptr->v_samp_factor;
.//JPEG/jcmaster.cpp:335:    compptr->last_row_height = tmp;
.//JPEG/jcmaster.cpp:338:    cinfo->blocks_in_MCU = 1;
.//JPEG/jcmaster.cpp:339:    cinfo->MCU_membership[0] = 0;
.//JPEG/jcmaster.cpp:343:    /* Interleaved (multi-component) scan */
.//JPEG/jcmaster.cpp:344:    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
.//JPEG/jcmaster.cpp:345:      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
.//JPEG/jcmaster.cpp:349:    cinfo->MCUs_per_row = (JDIMENSION)
.//JPEG/jcmaster.cpp:350:      jdiv_round_up((long) cinfo->image_width,
.//JPEG/jcmaster.cpp:351:		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
.//JPEG/jcmaster.cpp:352:    cinfo->MCU_rows_in_scan = (JDIMENSION)
.//JPEG/jcmaster.cpp:353:      jdiv_round_up((long) cinfo->image_height,
.//JPEG/jcmaster.cpp:354:		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
.//JPEG/jcmaster.cpp:356:    cinfo->blocks_in_MCU = 0;
.//JPEG/jcmaster.cpp:358:    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jcmaster.cpp:359:      compptr = cinfo->cur_comp_info[ci];
.//JPEG/jcmaster.cpp:361:      compptr->MCU_width = compptr->h_samp_factor;
.//JPEG/jcmaster.cpp:362:      compptr->MCU_height = compptr->v_samp_factor;
.//JPEG/jcmaster.cpp:363:      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
.//JPEG/jcmaster.cpp:364:      compptr->MCU_sample_width = compptr->MCU_width * DCTSIZE;
.//JPEG/jcmaster.cpp:365:      /* Figure number of non-dummy blocks in last MCU column & row */
.//JPEG/jcmaster.cpp:366:      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
.//JPEG/jcmaster.cpp:367:      if (tmp == 0) tmp = compptr->MCU_width;
.//JPEG/jcmaster.cpp:368:      compptr->last_col_width = tmp;
.//JPEG/jcmaster.cpp:369:      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
.//JPEG/jcmaster.cpp:370:      if (tmp == 0) tmp = compptr->MCU_height;
.//JPEG/jcmaster.cpp:371:      compptr->last_row_height = tmp;
.//JPEG/jcmaster.cpp:373:      mcublks = compptr->MCU_blocks;
.//JPEG/jcmaster.cpp:374:      if (cinfo->blocks_in_MCU + mcublks > C_MAX_BLOCKS_IN_MCU)
.//JPEG/jcmaster.cpp:376:      while (mcublks-- > 0) {
.//JPEG/jcmaster.cpp:377:	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
.//JPEG/jcmaster.cpp:385:  if (cinfo->restart_in_rows > 0) {
.//JPEG/jcmaster.cpp:386:    long nominal = (long) cinfo->restart_in_rows * (long) cinfo->MCUs_per_row;
.//JPEG/jcmaster.cpp:387:    cinfo->restart_interval = (unsigned int) MIN(nominal, 65535L);
.//JPEG/jcmaster.cpp:393: * Per-pass setup.
.//JPEG/jcmaster.cpp:403:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//JPEG/jcmaster.cpp:405:  switch (master->pass_type) {
.//JPEG/jcmaster.cpp:412:    if (! cinfo->raw_data_in) {
.//JPEG/jcmaster.cpp:413:      (*cinfo->cconvert->start_pass) (cinfo);
.//JPEG/jcmaster.cpp:414:      (*cinfo->downsample->start_pass) (cinfo);
.//JPEG/jcmaster.cpp:415:      (*cinfo->prep->start_pass) (cinfo, JBUF_PASS_THRU);
.//JPEG/jcmaster.cpp:417:    (*cinfo->fdct->start_pass) (cinfo);
.//JPEG/jcmaster.cpp:418:    (*cinfo->entropy->start_pass) (cinfo, cinfo->optimize_coding);
.//JPEG/jcmaster.cpp:419:    (*cinfo->coef->start_pass) (cinfo,
.//JPEG/jcmaster.cpp:420:				(master->total_passes > 1 ?
.//JPEG/jcmaster.cpp:422:    (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
.//JPEG/jcmaster.cpp:423:    if (cinfo->optimize_coding) {
.//JPEG/jcmaster.cpp:425:      master->pub.call_pass_startup = FALSE;
.//JPEG/jcmaster.cpp:428:      master->pub.call_pass_startup = TRUE;
.//JPEG/jcmaster.cpp:436:    if (cinfo->Ss != 0 || cinfo->Ah == 0 || cinfo->arith_code) {
.//JPEG/jcmaster.cpp:437:      (*cinfo->entropy->start_pass) (cinfo, TRUE);
.//JPEG/jcmaster.cpp:438:      (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);
.//JPEG/jcmaster.cpp:439:      master->pub.call_pass_startup = FALSE;
.//JPEG/jcmaster.cpp:445:    master->pass_type = output_pass;
.//JPEG/jcmaster.cpp:446:    master->pass_number++;
.//JPEG/jcmaster.cpp:450:    /* Do a data-output pass. */
.//JPEG/jcmaster.cpp:451:    /* We need not repeat per-scan setup if prior optimization pass did it. */
.//JPEG/jcmaster.cpp:452:    if (! cinfo->optimize_coding) {
.//JPEG/jcmaster.cpp:456:    (*cinfo->entropy->start_pass) (cinfo, FALSE);
.//JPEG/jcmaster.cpp:457:    (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);
.//JPEG/jcmaster.cpp:459:    if (master->scan_number == 0)
.//JPEG/jcmaster.cpp:460:      (*cinfo->marker->write_frame_header) (cinfo);
.//JPEG/jcmaster.cpp:461:    (*cinfo->marker->write_scan_header) (cinfo);
.//JPEG/jcmaster.cpp:462:    master->pub.call_pass_startup = FALSE;
.//JPEG/jcmaster.cpp:468:  master->pub.is_last_pass = (master->pass_number == master->total_passes-1);
.//JPEG/jcmaster.cpp:471:  if (cinfo->progress != NULL) {
.//JPEG/jcmaster.cpp:472:    cinfo->progress->completed_passes = master->pass_number;
.//JPEG/jcmaster.cpp:473:    cinfo->progress->total_passes = master->total_passes;
.//JPEG/jcmaster.cpp:479: * Special start-of-pass hook.
.//JPEG/jcmaster.cpp:481: * In single-pass processing, we need this hook because we don't want to
.//JPEG/jcmaster.cpp:485: * In multi-pass processing, this routine is not used.
.//JPEG/jcmaster.cpp:491:  cinfo->master->call_pass_startup = FALSE; /* reset flag so call only once */
.//JPEG/jcmaster.cpp:493:  (*cinfo->marker->write_frame_header) (cinfo);
.//JPEG/jcmaster.cpp:494:  (*cinfo->marker->write_scan_header) (cinfo);
.//JPEG/jcmaster.cpp:505:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//JPEG/jcmaster.cpp:507:  /* The entropy coder always needs an end-of-pass call,
.//JPEG/jcmaster.cpp:510:  (*cinfo->entropy->finish_pass) (cinfo);
.//JPEG/jcmaster.cpp:513:  switch (master->pass_type) {
.//JPEG/jcmaster.cpp:518:    master->pass_type = output_pass;
.//JPEG/jcmaster.cpp:519:    if (! cinfo->optimize_coding)
.//JPEG/jcmaster.cpp:520:      master->scan_number++;
.//JPEG/jcmaster.cpp:524:    master->pass_type = output_pass;
.//JPEG/jcmaster.cpp:528:    if (cinfo->optimize_coding)
.//JPEG/jcmaster.cpp:529:      master->pass_type = huff_opt_pass;
.//JPEG/jcmaster.cpp:530:    master->scan_number++;
.//JPEG/jcmaster.cpp:534:  master->pass_number++;
.//JPEG/jcmaster.cpp:548:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcmaster.cpp:550:  cinfo->master = (struct jpeg_comp_master *) master;
.//JPEG/jcmaster.cpp:551:  master->pub.prepare_for_pass = prepare_for_pass;
.//JPEG/jcmaster.cpp:552:  master->pub.pass_startup = pass_startup;
.//JPEG/jcmaster.cpp:553:  master->pub.finish_pass = finish_pass_master;
.//JPEG/jcmaster.cpp:554:  master->pub.is_last_pass = FALSE;
.//JPEG/jcmaster.cpp:559:  if (cinfo->scan_info != NULL) {
.//JPEG/jcmaster.cpp:566:    cinfo->progressive_mode = FALSE;
.//JPEG/jcmaster.cpp:567:    cinfo->num_scans = 1;
.//JPEG/jcmaster.cpp:570:  if (cinfo->progressive_mode)	/*  TEMPORARY HACK ??? */
.//JPEG/jcmaster.cpp:571:    cinfo->optimize_coding = TRUE; /* assume default tables no good for progressive mode */
.//JPEG/jcmaster.cpp:576:    if (cinfo->optimize_coding)
.//JPEG/jcmaster.cpp:577:      master->pass_type = huff_opt_pass;
.//JPEG/jcmaster.cpp:579:      master->pass_type = output_pass;
.//JPEG/jcmaster.cpp:582:    master->pass_type = main_pass;
.//JPEG/jcmaster.cpp:584:  master->scan_number = 0;
.//JPEG/jcmaster.cpp:585:  master->pass_number = 0;
.//JPEG/jcmaster.cpp:586:  if (cinfo->optimize_coding)
.//JPEG/jcmaster.cpp:587:    master->total_passes = cinfo->num_scans * 2;
.//JPEG/jcmaster.cpp:589:    master->total_passes = cinfo->num_scans;
.//JPEG/jcomapi.cpp:4: * Copyright (C) 1994-1997, Thomas G. Lane.
.//JPEG/jcomapi.cpp:33:  /* Do nothing if called on a not-initialized or destroyed JPEG object. */
.//JPEG/jcomapi.cpp:34:  if (cinfo->mem == NULL)
.//JPEG/jcomapi.cpp:38:   * with some (brain-damaged) malloc libraries.
.//JPEG/jcomapi.cpp:40:  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
.//JPEG/jcomapi.cpp:41:    (*cinfo->mem->free_pool) (cinfo, pool);
.//JPEG/jcomapi.cpp:45:  if (cinfo->is_decompressor) {
.//JPEG/jcomapi.cpp:46:    cinfo->global_state = DSTATE_START;
.//JPEG/jcomapi.cpp:47:    /* Try to keep application from accessing now-deleted marker list.
.//JPEG/jcomapi.cpp:50:    ((j_decompress_ptr) cinfo)->marker_list = NULL;
.//JPEG/jcomapi.cpp:52:    cinfo->global_state = CSTATE_START;
.//JPEG/jcomapi.cpp:73:  if (cinfo->mem != NULL)
.//JPEG/jcomapi.cpp:74:    (*cinfo->mem->self_destruct) (cinfo);
.//JPEG/jcomapi.cpp:75:  cinfo->mem = NULL;		/* be safe if jpeg_destroy is called twice */
.//JPEG/jcomapi.cpp:76:  cinfo->global_state = 0;	/* mark it destroyed */
.//JPEG/jcomapi.cpp:91:    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));
.//JPEG/jcomapi.cpp:92:  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
.//JPEG/jcomapi.cpp:103:    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JHUFF_TBL));
.//JPEG/jcomapi.cpp:104:  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
.//JPEG/jconfig.h:1:/* jconfig.h --- generated by ckconfig.c */
.//JPEG/jconfig.h:32:#undef TWO_FILE_COMMANDLINE	/* You may need this on non-Unix systems */
.//JPEG/jcparam.cpp:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//JPEG/jcparam.cpp:8: * This file contains optional default-setting code for the JPEG compressor.
.//JPEG/jcparam.cpp:37:  if (cinfo->global_state != CSTATE_START)
.//JPEG/jcparam.cpp:38:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jcparam.cpp:43:  qtblptr = & cinfo->quant_tbl_ptrs[which_tbl];
.//JPEG/jcparam.cpp:55:    (*qtblptr)->quantval[i] = (UINT16) temp;
.//JPEG/jcparam.cpp:59:  (*qtblptr)->sent_table = FALSE;
.//JPEG/jcparam.cpp:67: * and a straight percentage-scaling quality scale.  In most cases it's better
.//JPEG/jcparam.cpp:107:/* Convert a user-specified quality rating to a percentage scaling factor
.//JPEG/jcparam.cpp:116:  /* The basic table is used as-is (scaling 100) for a quality of 50.
.//JPEG/jcparam.cpp:117:   * Qualities 50..100 are converted to scaling percentage 200 - 2*Q;
.//JPEG/jcparam.cpp:125:    quality = 200 - quality*2;
.//JPEG/jcparam.cpp:134: * This is the standard quality-adjusting entry point for typical user
.//JPEG/jcparam.cpp:139:  /* Convert user 0-100 rating to percentage scaling */
.//JPEG/jcparam.cpp:161:  /* Copy the number-of-symbols-of-each-code-length counts */
.//JPEG/jcparam.cpp:162:  MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
.//JPEG/jcparam.cpp:174:  MEMCOPY((*htblptr)->huffval, val, nsymbols * SIZEOF(UINT8));
.//JPEG/jcparam.cpp:177:  (*htblptr)->sent_table = FALSE;
.//JPEG/jcparam.cpp:184:/* IMPORTANT: these are only valid for 8-bit data precision! */
.//JPEG/jcparam.cpp:187:    { /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
.//JPEG/jcparam.cpp:192:    { /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
.//JPEG/jcparam.cpp:197:    { /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
.//JPEG/jcparam.cpp:222:    { /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };
.//JPEG/jcparam.cpp:246:  add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[0],
.//JPEG/jcparam.cpp:248:  add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[0],
.//JPEG/jcparam.cpp:250:  add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[1],
.//JPEG/jcparam.cpp:252:  add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[1],
.//JPEG/jcparam.cpp:273:  if (cinfo->global_state != CSTATE_START)
.//JPEG/jcparam.cpp:274:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jcparam.cpp:280:  if (cinfo->comp_info == NULL)
.//JPEG/jcparam.cpp:281:    cinfo->comp_info = (jpeg_component_info *)
.//JPEG/jcparam.cpp:282:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//JPEG/jcparam.cpp:287:  cinfo->data_precision = BITS_IN_JSAMPLE;
.//JPEG/jcparam.cpp:295:    cinfo->arith_dc_L[i] = 0;
.//JPEG/jcparam.cpp:296:    cinfo->arith_dc_U[i] = 1;
.//JPEG/jcparam.cpp:297:    cinfo->arith_ac_K[i] = 5;
.//JPEG/jcparam.cpp:300:  /* Default is no multiple-scan output */
.//JPEG/jcparam.cpp:301:  cinfo->scan_info = NULL;
.//JPEG/jcparam.cpp:302:  cinfo->num_scans = 0;
.//JPEG/jcparam.cpp:305:  cinfo->raw_data_in = FALSE;
.//JPEG/jcparam.cpp:308:  cinfo->arith_code = FALSE;
.//JPEG/jcparam.cpp:311:  cinfo->optimize_coding = FALSE;
.//JPEG/jcparam.cpp:312:  /* The standard Huffman tables are only valid for 8-bit data precision.
.//JPEG/jcparam.cpp:317:  if (cinfo->data_precision > 8)
.//JPEG/jcparam.cpp:318:    cinfo->optimize_coding = TRUE;
.//JPEG/jcparam.cpp:320:  /* By default, use the simpler non-cosited sampling alignment */
.//JPEG/jcparam.cpp:321:  cinfo->CCIR601_sampling = FALSE;
.//JPEG/jcparam.cpp:324:  cinfo->smoothing_factor = 0;
.//JPEG/jcparam.cpp:327:  cinfo->dct_method = JDCT_DEFAULT;
.//JPEG/jcparam.cpp:330:  cinfo->restart_interval = 0;
.//JPEG/jcparam.cpp:331:  cinfo->restart_in_rows = 0;
.//JPEG/jcparam.cpp:342:  cinfo->JFIF_major_version = 1; /* Default JFIF version = 1.01 */
.//JPEG/jcparam.cpp:343:  cinfo->JFIF_minor_version = 1;
.//JPEG/jcparam.cpp:344:  cinfo->density_unit = 0;	/* Pixel size is unknown by default */
.//JPEG/jcparam.cpp:345:  cinfo->X_density = 1;		/* Pixel aspect ratio is square by default */
.//JPEG/jcparam.cpp:346:  cinfo->Y_density = 1;
.//JPEG/jcparam.cpp:361:  switch (cinfo->in_color_space) {
.//JPEG/jcparam.cpp:387: * Set the JPEG colorspace, and choose colorspace-dependent default values.
.//JPEG/jcparam.cpp:397:  (compptr = &cinfo->comp_info[index], \
.//JPEG/jcparam.cpp:398:   compptr->component_id = (id), \
.//JPEG/jcparam.cpp:399:   compptr->h_samp_factor = (hsamp), \
.//JPEG/jcparam.cpp:400:   compptr->v_samp_factor = (vsamp), \
.//JPEG/jcparam.cpp:401:   compptr->quant_tbl_no = (quant), \
.//JPEG/jcparam.cpp:402:   compptr->dc_tbl_no = (dctbl), \
.//JPEG/jcparam.cpp:403:   compptr->ac_tbl_no = (actbl) )
.//JPEG/jcparam.cpp:406:  if (cinfo->global_state != CSTATE_START)
.//JPEG/jcparam.cpp:407:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jcparam.cpp:413:  cinfo->jpeg_color_space = colorspace;
.//JPEG/jcparam.cpp:415:  cinfo->write_JFIF_header = FALSE; /* No marker for non-JFIF colorspaces */
.//JPEG/jcparam.cpp:416:  cinfo->write_Adobe_marker = FALSE; /* write no Adobe marker by default */
.//JPEG/jcparam.cpp:420:    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
.//JPEG/jcparam.cpp:421:    cinfo->num_components = 1;
.//JPEG/jcparam.cpp:426:    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag RGB */
.//JPEG/jcparam.cpp:427:    cinfo->num_components = 3;
.//JPEG/jcparam.cpp:433:    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
.//JPEG/jcparam.cpp:434:    cinfo->num_components = 3;
.//JPEG/jcparam.cpp:442:    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag CMYK */
.//JPEG/jcparam.cpp:443:    cinfo->num_components = 4;
.//JPEG/jcparam.cpp:450:    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag YCCK */
.//JPEG/jcparam.cpp:451:    cinfo->num_components = 4;
.//JPEG/jcparam.cpp:458:    cinfo->num_components = cinfo->input_components;
.//JPEG/jcparam.cpp:459:    if (cinfo->num_components < 1 || cinfo->num_components > MAX_COMPONENTS)
.//JPEG/jcparam.cpp:460:      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
.//JPEG/jcparam.cpp:462:    for (ci = 0; ci < cinfo->num_components; ci++) {
.//JPEG/jcparam.cpp:479:  scanptr->comps_in_scan = 1;
.//JPEG/jcparam.cpp:480:  scanptr->component_index[0] = ci;
.//JPEG/jcparam.cpp:481:  scanptr->Ss = Ss;
.//JPEG/jcparam.cpp:482:  scanptr->Se = Se;
.//JPEG/jcparam.cpp:483:  scanptr->Ah = Ah;
.//JPEG/jcparam.cpp:484:  scanptr->Al = Al;
.//JPEG/jcparam.cpp:497:    scanptr->comps_in_scan = 1;
.//JPEG/jcparam.cpp:498:    scanptr->component_index[0] = ci;
.//JPEG/jcparam.cpp:499:    scanptr->Ss = Ss;
.//JPEG/jcparam.cpp:500:    scanptr->Se = Se;
.//JPEG/jcparam.cpp:501:    scanptr->Ah = Ah;
.//JPEG/jcparam.cpp:502:    scanptr->Al = Al;
.//JPEG/jcparam.cpp:516:    scanptr->comps_in_scan = ncomps;
.//JPEG/jcparam.cpp:518:      scanptr->component_index[ci] = ci;
.//JPEG/jcparam.cpp:519:    scanptr->Ss = scanptr->Se = 0;
.//JPEG/jcparam.cpp:520:    scanptr->Ah = Ah;
.//JPEG/jcparam.cpp:521:    scanptr->Al = Al;
.//JPEG/jcparam.cpp:532: * Create a recommended progressive-JPEG script.
.//JPEG/jcparam.cpp:533: * cinfo->num_components and cinfo->jpeg_color_space must be correct.
.//JPEG/jcparam.cpp:539:  int ncomps = cinfo->num_components;
.//JPEG/jcparam.cpp:544:  if (cinfo->global_state != CSTATE_START)
.//JPEG/jcparam.cpp:545:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jcparam.cpp:548:  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {
.//JPEG/jcparam.cpp:552:    /* All-purpose script for other color spaces. */
.//JPEG/jcparam.cpp:563:   * object, we try to re-use previously allocated space, and we allocate
.//JPEG/jcparam.cpp:566:  if (cinfo->script_space == NULL || cinfo->script_space_size < nscans) {
.//JPEG/jcparam.cpp:567:    cinfo->script_space_size = MAX(nscans, 10);
.//JPEG/jcparam.cpp:568:    cinfo->script_space = (jpeg_scan_info *)
.//JPEG/jcparam.cpp:569:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//JPEG/jcparam.cpp:570:			cinfo->script_space_size * SIZEOF(jpeg_scan_info));
.//JPEG/jcparam.cpp:572:  scanptr = cinfo->script_space;
.//JPEG/jcparam.cpp:573:  cinfo->scan_info = scanptr;
.//JPEG/jcparam.cpp:574:  cinfo->num_scans = nscans;
.//JPEG/jcparam.cpp:576:  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {
.//JPEG/jcparam.cpp:597:    /* All-purpose script for other color spaces. */
.//JPEG/jcphuff.cpp:4: * Copyright (C) 1995-1997, Thomas G. Lane.
.//JPEG/jcphuff.cpp:11: * currently does not allow multiple-scan files to be written with output
.//JPEG/jcphuff.cpp:30:  /* Bit-level coding status.
.//JPEG/jcphuff.cpp:31:   * next_output_byte/free_in_buffer are local copies of cinfo->dest fields.
.//JPEG/jcphuff.cpp:35:  INT32 put_buffer;		/* current bit-accumulation buffer */
.//JPEG/jcphuff.cpp:50:  int next_restart_num;		/* next restart number to write (0-7) */
.//JPEG/jcphuff.cpp:64:/* MAX_CORR_BITS is the number of bits the AC refinement correction-bit
.//JPEG/jcphuff.cpp:81:	 (ishift_temp >> (shft)) | ((~0) << (16-(shft))) : \
.//JPEG/jcphuff.cpp:102: * Initialize for a Huffman-compressed scan using progressive JPEG.
.//JPEG/jcphuff.cpp:108:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jcphuff.cpp:113:  entropy->cinfo = cinfo;
.//JPEG/jcphuff.cpp:114:  entropy->gather_statistics = gather_statistics;
.//JPEG/jcphuff.cpp:116:  is_DC_band = (cinfo->Ss == 0);
.//JPEG/jcphuff.cpp:121:  if (cinfo->Ah == 0) {
.//JPEG/jcphuff.cpp:123:      entropy->pub.encode_mcu = encode_mcu_DC_first;
.//JPEG/jcphuff.cpp:125:      entropy->pub.encode_mcu = encode_mcu_AC_first;
.//JPEG/jcphuff.cpp:128:      entropy->pub.encode_mcu = encode_mcu_DC_refine;
.//JPEG/jcphuff.cpp:130:      entropy->pub.encode_mcu = encode_mcu_AC_refine;
.//JPEG/jcphuff.cpp:132:      if (entropy->bit_buffer == NULL)
.//JPEG/jcphuff.cpp:133:	entropy->bit_buffer = (char *)
.//JPEG/jcphuff.cpp:134:	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcphuff.cpp:139:    entropy->pub.finish_pass = finish_pass_gather_phuff;
.//JPEG/jcphuff.cpp:141:    entropy->pub.finish_pass = finish_pass_phuff;
.//JPEG/jcphuff.cpp:143:  /* Only DC coefficients may be interleaved, so cinfo->comps_in_scan = 1
.//JPEG/jcphuff.cpp:146:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jcphuff.cpp:147:    compptr = cinfo->cur_comp_info[ci];
.//JPEG/jcphuff.cpp:149:    entropy->last_dc_val[ci] = 0;
.//JPEG/jcphuff.cpp:152:      if (cinfo->Ah != 0)	/* DC refinement needs no table */
.//JPEG/jcphuff.cpp:154:      tbl = compptr->dc_tbl_no;
.//JPEG/jcphuff.cpp:156:      entropy->ac_tbl_no = tbl = compptr->ac_tbl_no;
.//JPEG/jcphuff.cpp:165:      if (entropy->count_ptrs[tbl] == NULL)
.//JPEG/jcphuff.cpp:166:	entropy->count_ptrs[tbl] = (long *)
.//JPEG/jcphuff.cpp:167:	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcphuff.cpp:169:      MEMZERO(entropy->count_ptrs[tbl], 257 * SIZEOF(long));
.//JPEG/jcphuff.cpp:174:			      & entropy->derived_tbls[tbl]);
.//JPEG/jcphuff.cpp:179:  entropy->EOBRUN = 0;
.//JPEG/jcphuff.cpp:180:  entropy->BE = 0;
.//JPEG/jcphuff.cpp:183:  entropy->put_buffer = 0;
.//JPEG/jcphuff.cpp:184:  entropy->put_bits = 0;
.//JPEG/jcphuff.cpp:187:  entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jcphuff.cpp:188:  entropy->next_restart_num = 0;
.//JPEG/jcphuff.cpp:194: * that is, entropy->gather_statistics == FALSE.
.//JPEG/jcphuff.cpp:199:	{ *(entropy)->next_output_byte++ = (JOCTET) (val);  \
.//JPEG/jcphuff.cpp:200:	  if (--(entropy)->free_in_buffer == 0)  \
.//JPEG/jcphuff.cpp:208:  struct jpeg_destination_mgr * dest = entropy->cinfo->dest;
.//JPEG/jcphuff.cpp:210:  if (! (*dest->empty_output_buffer) (entropy->cinfo))
.//JPEG/jcphuff.cpp:211:    ERREXIT(entropy->cinfo, JERR_CANT_SUSPEND);
.//JPEG/jcphuff.cpp:213:  entropy->next_output_byte = dest->next_output_byte;
.//JPEG/jcphuff.cpp:214:  entropy->free_in_buffer = dest->free_in_buffer;
.//JPEG/jcphuff.cpp:221: * left-justified in this part.  At most 16 bits can be passed to emit_bits
.//JPEG/jcphuff.cpp:233:  register int put_bits = entropy->put_bits;
.//JPEG/jcphuff.cpp:237:    ERREXIT(entropy->cinfo, JERR_HUFF_MISSING_CODE);
.//JPEG/jcphuff.cpp:239:  if (entropy->gather_statistics)
.//JPEG/jcphuff.cpp:242:  put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
.//JPEG/jcphuff.cpp:246:  put_buffer <<= 24 - put_bits; /* align incoming bits */
.//JPEG/jcphuff.cpp:248:  put_buffer |= entropy->put_buffer; /* and merge with old buffer contents */
.//JPEG/jcphuff.cpp:258:    put_bits -= 8;
.//JPEG/jcphuff.cpp:261:  entropy->put_buffer = put_buffer; /* update variables */
.//JPEG/jcphuff.cpp:262:  entropy->put_bits = put_bits;
.//JPEG/jcphuff.cpp:270:  entropy->put_buffer = 0;     /* and reset bit-buffer to empty */
.//JPEG/jcphuff.cpp:271:  entropy->put_bits = 0;
.//JPEG/jcphuff.cpp:283:  if (entropy->gather_statistics)
.//JPEG/jcphuff.cpp:284:    entropy->count_ptrs[tbl_no][symbol]++;
.//JPEG/jcphuff.cpp:286:    c_derived_tbl * tbl = entropy->derived_tbls[tbl_no];
.//JPEG/jcphuff.cpp:287:    emit_bits(entropy, tbl->ehufco[symbol], tbl->ehufsi[symbol]);
.//JPEG/jcphuff.cpp:300:  if (entropy->gather_statistics)
.//JPEG/jcphuff.cpp:306:    nbits--;
.//JPEG/jcphuff.cpp:320:  if (entropy->EOBRUN > 0) {	/* if there is any pending EOBRUN */
.//JPEG/jcphuff.cpp:321:    temp = entropy->EOBRUN;
.//JPEG/jcphuff.cpp:325:    /* safety check: shouldn't happen given limited correction-bit buffer */
.//JPEG/jcphuff.cpp:327:      ERREXIT(entropy->cinfo, JERR_HUFF_MISSING_CODE);
.//JPEG/jcphuff.cpp:329:    emit_symbol(entropy, entropy->ac_tbl_no, nbits << 4);
.//JPEG/jcphuff.cpp:331:      emit_bits(entropy, entropy->EOBRUN, nbits);
.//JPEG/jcphuff.cpp:333:    entropy->EOBRUN = 0;
.//JPEG/jcphuff.cpp:336:    emit_buffered_bits(entropy, entropy->bit_buffer, entropy->BE);
.//JPEG/jcphuff.cpp:337:    entropy->BE = 0;
.//JPEG/jcphuff.cpp:353:  if (! entropy->gather_statistics) {
.//JPEG/jcphuff.cpp:359:  if (entropy->cinfo->Ss == 0) {
.//JPEG/jcphuff.cpp:360:    /* Re-initialize DC predictions to 0 */
.//JPEG/jcphuff.cpp:361:    for (ci = 0; ci < entropy->cinfo->comps_in_scan; ci++)
.//JPEG/jcphuff.cpp:362:      entropy->last_dc_val[ci] = 0;
.//JPEG/jcphuff.cpp:364:    /* Re-initialize all AC-related fields to 0 */
.//JPEG/jcphuff.cpp:365:    entropy->EOBRUN = 0;
.//JPEG/jcphuff.cpp:366:    entropy->BE = 0;
.//JPEG/jcphuff.cpp:379:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jcphuff.cpp:383:  int Al = cinfo->Al;
.//JPEG/jcphuff.cpp:388:  entropy->next_output_byte = cinfo->dest->next_output_byte;
.//JPEG/jcphuff.cpp:389:  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
.//JPEG/jcphuff.cpp:392:  if (cinfo->restart_interval)
.//JPEG/jcphuff.cpp:393:    if (entropy->restarts_to_go == 0)
.//JPEG/jcphuff.cpp:394:      emit_restart(entropy, entropy->next_restart_num);
.//JPEG/jcphuff.cpp:397:  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//JPEG/jcphuff.cpp:399:    ci = cinfo->MCU_membership[blkn];
.//JPEG/jcphuff.cpp:400:    compptr = cinfo->cur_comp_info[ci];
.//JPEG/jcphuff.cpp:407:    /* DC differences are figured on the point-transformed values. */
.//JPEG/jcphuff.cpp:408:    temp = temp2 - entropy->last_dc_val[ci];
.//JPEG/jcphuff.cpp:409:    entropy->last_dc_val[ci] = temp2;
.//JPEG/jcphuff.cpp:414:      temp = -temp;		/* temp is abs value of input */
.//JPEG/jcphuff.cpp:417:      temp2--;
.//JPEG/jcphuff.cpp:426:    /* Check for out-of-range coefficient values.
.//JPEG/jcphuff.cpp:432:    /* Count/emit the Huffman-coded symbol for the number of bits */
.//JPEG/jcphuff.cpp:433:    emit_symbol(entropy, compptr->dc_tbl_no, nbits);
.//JPEG/jcphuff.cpp:441:  cinfo->dest->next_output_byte = entropy->next_output_byte;
.//JPEG/jcphuff.cpp:442:  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
.//JPEG/jcphuff.cpp:444:  /* Update restart-interval state too */
.//JPEG/jcphuff.cpp:445:  if (cinfo->restart_interval) {
.//JPEG/jcphuff.cpp:446:    if (entropy->restarts_to_go == 0) {
.//JPEG/jcphuff.cpp:447:      entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jcphuff.cpp:448:      entropy->next_restart_num++;
.//JPEG/jcphuff.cpp:449:      entropy->next_restart_num &= 7;
.//JPEG/jcphuff.cpp:451:    entropy->restarts_to_go--;
.//JPEG/jcphuff.cpp:466:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jcphuff.cpp:470:  int Se = cinfo->Se;
.//JPEG/jcphuff.cpp:471:  int Al = cinfo->Al;
.//JPEG/jcphuff.cpp:474:  entropy->next_output_byte = cinfo->dest->next_output_byte;
.//JPEG/jcphuff.cpp:475:  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
.//JPEG/jcphuff.cpp:478:  if (cinfo->restart_interval)
.//JPEG/jcphuff.cpp:479:    if (entropy->restarts_to_go == 0)
.//JPEG/jcphuff.cpp:480:      emit_restart(entropy, entropy->next_restart_num);
.//JPEG/jcphuff.cpp:489:  for (k = cinfo->Ss; k <= Se; k++) {
.//JPEG/jcphuff.cpp:500:      temp = -temp;		/* temp is abs value of input */
.//JPEG/jcphuff.cpp:515:    if (entropy->EOBRUN > 0)
.//JPEG/jcphuff.cpp:517:    /* if run length > 15, must emit special run-length-16 codes (0xF0) */
.//JPEG/jcphuff.cpp:519:      emit_symbol(entropy, entropy->ac_tbl_no, 0xF0);
.//JPEG/jcphuff.cpp:520:      r -= 16;
.//JPEG/jcphuff.cpp:527:    /* Check for out-of-range coefficient values */
.//JPEG/jcphuff.cpp:532:    emit_symbol(entropy, entropy->ac_tbl_no, (r << 4) + nbits);
.//JPEG/jcphuff.cpp:542:    entropy->EOBRUN++;		/* count an EOB */
.//JPEG/jcphuff.cpp:543:    if (entropy->EOBRUN == 0x7FFF)
.//JPEG/jcphuff.cpp:547:  cinfo->dest->next_output_byte = entropy->next_output_byte;
.//JPEG/jcphuff.cpp:548:  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
.//JPEG/jcphuff.cpp:550:  /* Update restart-interval state too */
.//JPEG/jcphuff.cpp:551:  if (cinfo->restart_interval) {
.//JPEG/jcphuff.cpp:552:    if (entropy->restarts_to_go == 0) {
.//JPEG/jcphuff.cpp:553:      entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jcphuff.cpp:554:      entropy->next_restart_num++;
.//JPEG/jcphuff.cpp:555:      entropy->next_restart_num &= 7;
.//JPEG/jcphuff.cpp:557:    entropy->restarts_to_go--;
.//JPEG/jcphuff.cpp:566: * Note: we assume such scans can be multi-component, although the spec
.//JPEG/jcphuff.cpp:573:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jcphuff.cpp:576:  int Al = cinfo->Al;
.//JPEG/jcphuff.cpp:579:  entropy->next_output_byte = cinfo->dest->next_output_byte;
.//JPEG/jcphuff.cpp:580:  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
.//JPEG/jcphuff.cpp:583:  if (cinfo->restart_interval)
.//JPEG/jcphuff.cpp:584:    if (entropy->restarts_to_go == 0)
.//JPEG/jcphuff.cpp:585:      emit_restart(entropy, entropy->next_restart_num);
.//JPEG/jcphuff.cpp:588:  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//JPEG/jcphuff.cpp:596:  cinfo->dest->next_output_byte = entropy->next_output_byte;
.//JPEG/jcphuff.cpp:597:  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
.//JPEG/jcphuff.cpp:599:  /* Update restart-interval state too */
.//JPEG/jcphuff.cpp:600:  if (cinfo->restart_interval) {
.//JPEG/jcphuff.cpp:601:    if (entropy->restarts_to_go == 0) {
.//JPEG/jcphuff.cpp:602:      entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jcphuff.cpp:603:      entropy->next_restart_num++;
.//JPEG/jcphuff.cpp:604:      entropy->next_restart_num &= 7;
.//JPEG/jcphuff.cpp:606:    entropy->restarts_to_go--;
.//JPEG/jcphuff.cpp:620:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jcphuff.cpp:626:  int Se = cinfo->Se;
.//JPEG/jcphuff.cpp:627:  int Al = cinfo->Al;
.//JPEG/jcphuff.cpp:631:  entropy->next_output_byte = cinfo->dest->next_output_byte;
.//JPEG/jcphuff.cpp:632:  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
.//JPEG/jcphuff.cpp:635:  if (cinfo->restart_interval)
.//JPEG/jcphuff.cpp:636:    if (entropy->restarts_to_go == 0)
.//JPEG/jcphuff.cpp:637:      emit_restart(entropy, entropy->next_restart_num);
.//JPEG/jcphuff.cpp:642:  /* It is convenient to make a pre-pass to determine the transformed
.//JPEG/jcphuff.cpp:646:  for (k = cinfo->Ss; k <= Se; k++) {
.//JPEG/jcphuff.cpp:653:      temp = -temp;		/* temp is abs value of input */
.//JPEG/jcphuff.cpp:657:      EOB = k;			/* EOB = index of last newly-nonzero coef */
.//JPEG/jcphuff.cpp:664:  BR_buffer = entropy->bit_buffer + entropy->BE; /* Append bits to buffer */
.//JPEG/jcphuff.cpp:666:  for (k = cinfo->Ss; k <= Se; k++) {
.//JPEG/jcphuff.cpp:677:      emit_symbol(entropy, entropy->ac_tbl_no, 0xF0);
.//JPEG/jcphuff.cpp:678:      r -= 16;
.//JPEG/jcphuff.cpp:681:      BR_buffer = entropy->bit_buffer; /* BE bits are gone now */
.//JPEG/jcphuff.cpp:700:    emit_symbol(entropy, entropy->ac_tbl_no, (r << 4) + 1);
.//JPEG/jcphuff.cpp:702:    /* Emit output bit for newly-nonzero coef */
.//JPEG/jcphuff.cpp:708:    BR_buffer = entropy->bit_buffer; /* BE bits are gone now */
.//JPEG/jcphuff.cpp:714:    entropy->EOBRUN++;		/* count an EOB */
.//JPEG/jcphuff.cpp:715:    entropy->BE += BR;		/* concat my correction bits to older ones */
.//JPEG/jcphuff.cpp:720:    if (entropy->EOBRUN == 0x7FFF || entropy->BE > (MAX_CORR_BITS-DCTSIZE2+1))
.//JPEG/jcphuff.cpp:724:  cinfo->dest->next_output_byte = entropy->next_output_byte;
.//JPEG/jcphuff.cpp:725:  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
.//JPEG/jcphuff.cpp:727:  /* Update restart-interval state too */
.//JPEG/jcphuff.cpp:728:  if (cinfo->restart_interval) {
.//JPEG/jcphuff.cpp:729:    if (entropy->restarts_to_go == 0) {
.//JPEG/jcphuff.cpp:730:      entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jcphuff.cpp:731:      entropy->next_restart_num++;
.//JPEG/jcphuff.cpp:732:      entropy->next_restart_num &= 7;
.//JPEG/jcphuff.cpp:734:    entropy->restarts_to_go--;
.//JPEG/jcphuff.cpp:742: * Finish up at the end of a Huffman-compressed progressive scan.
.//JPEG/jcphuff.cpp:748:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jcphuff.cpp:750:  entropy->next_output_byte = cinfo->dest->next_output_byte;
.//JPEG/jcphuff.cpp:751:  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
.//JPEG/jcphuff.cpp:757:  cinfo->dest->next_output_byte = entropy->next_output_byte;
.//JPEG/jcphuff.cpp:758:  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
.//JPEG/jcphuff.cpp:763: * Finish up a statistics-gathering pass and create the new Huffman tables.
.//JPEG/jcphuff.cpp:769:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jcphuff.cpp:779:  is_DC_band = (cinfo->Ss == 0);
.//JPEG/jcphuff.cpp:786:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jcphuff.cpp:787:    compptr = cinfo->cur_comp_info[ci];
.//JPEG/jcphuff.cpp:789:      if (cinfo->Ah != 0)	/* DC refinement needs no table */
.//JPEG/jcphuff.cpp:791:      tbl = compptr->dc_tbl_no;
.//JPEG/jcphuff.cpp:793:      tbl = compptr->ac_tbl_no;
.//JPEG/jcphuff.cpp:797:        htblptr = & cinfo->dc_huff_tbl_ptrs[tbl];
.//JPEG/jcphuff.cpp:799:        htblptr = & cinfo->ac_huff_tbl_ptrs[tbl];
.//JPEG/jcphuff.cpp:802:      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->count_ptrs[tbl]);
.//JPEG/jcphuff.cpp:820:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcphuff.cpp:822:  cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
.//JPEG/jcphuff.cpp:823:  entropy->pub.start_pass = start_pass_phuff;
.//JPEG/jcphuff.cpp:827:    entropy->derived_tbls[i] = NULL;
.//JPEG/jcphuff.cpp:828:    entropy->count_ptrs[i] = NULL;
.//JPEG/jcphuff.cpp:830:  entropy->bit_buffer = NULL;	/* needed only in AC refinement scan */
.//JPEG/jcprepct.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jcprepct.cpp:24: * or other more-complex downsampling procedures.  The code to support
.//JPEG/jcprepct.cpp:33: * For the simple (no-context-row) case, we just need to buffer one
.//JPEG/jcprepct.cpp:56:  /* Downsampling input buffer.  This buffer holds color-converted data
.//JPEG/jcprepct.cpp:80:  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
.//JPEG/jcprepct.cpp:85:  /* Initialize total-height counter for detecting bottom of image */
.//JPEG/jcprepct.cpp:86:  prep->rows_to_go = cinfo->image_height;
.//JPEG/jcprepct.cpp:88:  prep->next_buf_row = 0;
.//JPEG/jcprepct.cpp:91:   * These aren't used in non-context mode, so we needn't test which mode.
.//JPEG/jcprepct.cpp:93:  prep->this_row_group = 0;
.//JPEG/jcprepct.cpp:95:  prep->next_buf_stop = 2 * cinfo->max_v_samp_factor;
.//JPEG/jcprepct.cpp:112:    jcopy_sample_rows(image_data, input_rows-1, image_data, row,
.//JPEG/jcprepct.cpp:119: * Process some data in the simple no-context case.
.//JPEG/jcprepct.cpp:134:  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
.//JPEG/jcprepct.cpp:142:    inrows = in_rows_avail - *in_row_ctr;
.//JPEG/jcprepct.cpp:143:    numrows = cinfo->max_v_samp_factor - prep->next_buf_row;
.//JPEG/jcprepct.cpp:145:    (*cinfo->cconvert->color_convert) (cinfo, input_buf + *in_row_ctr,
.//JPEG/jcprepct.cpp:146:				       prep->color_buf,
.//JPEG/jcprepct.cpp:147:				       (JDIMENSION) prep->next_buf_row,
.//JPEG/jcprepct.cpp:150:    prep->next_buf_row += numrows;
.//JPEG/jcprepct.cpp:151:    prep->rows_to_go -= numrows;
.//JPEG/jcprepct.cpp:153:    if (prep->rows_to_go == 0 &&
.//JPEG/jcprepct.cpp:154:	prep->next_buf_row < cinfo->max_v_samp_factor) {
.//JPEG/jcprepct.cpp:155:      for (ci = 0; ci < cinfo->num_components; ci++) {
.//JPEG/jcprepct.cpp:156:	expand_bottom_edge(prep->color_buf[ci], cinfo->image_width,
.//JPEG/jcprepct.cpp:157:			   prep->next_buf_row, cinfo->max_v_samp_factor);
.//JPEG/jcprepct.cpp:159:      prep->next_buf_row = cinfo->max_v_samp_factor;
.//JPEG/jcprepct.cpp:162:    if (prep->next_buf_row == cinfo->max_v_samp_factor) {
.//JPEG/jcprepct.cpp:163:      (*cinfo->downsample->downsample) (cinfo,
.//JPEG/jcprepct.cpp:164:					prep->color_buf, (JDIMENSION) 0,
.//JPEG/jcprepct.cpp:166:      prep->next_buf_row = 0;
.//JPEG/jcprepct.cpp:170:     * Note we assume the caller is providing a one-iMCU-height output buffer!
.//JPEG/jcprepct.cpp:172:    if (prep->rows_to_go == 0 &&
.//JPEG/jcprepct.cpp:174:      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcprepct.cpp:177:			   compptr->width_in_blocks * DCTSIZE,
.//JPEG/jcprepct.cpp:178:			   (int) (*out_row_group_ctr * compptr->v_samp_factor),
.//JPEG/jcprepct.cpp:179:			   (int) (out_row_groups_avail * compptr->v_samp_factor));
.//JPEG/jcprepct.cpp:201:  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
.//JPEG/jcprepct.cpp:203:  int buf_height = cinfo->max_v_samp_factor * 3;
.//JPEG/jcprepct.cpp:209:      inrows = in_rows_avail - *in_row_ctr;
.//JPEG/jcprepct.cpp:210:      numrows = prep->next_buf_stop - prep->next_buf_row;
.//JPEG/jcprepct.cpp:212:      (*cinfo->cconvert->color_convert) (cinfo, input_buf + *in_row_ctr,
.//JPEG/jcprepct.cpp:213:					 prep->color_buf,
.//JPEG/jcprepct.cpp:214:					 (JDIMENSION) prep->next_buf_row,
.//JPEG/jcprepct.cpp:217:      if (prep->rows_to_go == cinfo->image_height) {
.//JPEG/jcprepct.cpp:218:	for (ci = 0; ci < cinfo->num_components; ci++) {
.//JPEG/jcprepct.cpp:220:	  for (row = 1; row <= cinfo->max_v_samp_factor; row++) {
.//JPEG/jcprepct.cpp:221:	    jcopy_sample_rows(prep->color_buf[ci], 0,
.//JPEG/jcprepct.cpp:222:			      prep->color_buf[ci], -row,
.//JPEG/jcprepct.cpp:223:			      1, cinfo->image_width);
.//JPEG/jcprepct.cpp:228:      prep->next_buf_row += numrows;
.//JPEG/jcprepct.cpp:229:      prep->rows_to_go -= numrows;
.//JPEG/jcprepct.cpp:232:      if (prep->rows_to_go != 0)
.//JPEG/jcprepct.cpp:235:      if (prep->next_buf_row < prep->next_buf_stop) {
.//JPEG/jcprepct.cpp:236:	for (ci = 0; ci < cinfo->num_components; ci++) {
.//JPEG/jcprepct.cpp:237:	  expand_bottom_edge(prep->color_buf[ci], cinfo->image_width,
.//JPEG/jcprepct.cpp:238:			     prep->next_buf_row, prep->next_buf_stop);
.//JPEG/jcprepct.cpp:240:	prep->next_buf_row = prep->next_buf_stop;
.//JPEG/jcprepct.cpp:244:    if (prep->next_buf_row == prep->next_buf_stop) {
.//JPEG/jcprepct.cpp:245:      (*cinfo->downsample->downsample) (cinfo,
.//JPEG/jcprepct.cpp:246:					prep->color_buf,
.//JPEG/jcprepct.cpp:247:					(JDIMENSION) prep->this_row_group,
.//JPEG/jcprepct.cpp:251:      prep->this_row_group += cinfo->max_v_samp_factor;
.//JPEG/jcprepct.cpp:252:      if (prep->this_row_group >= buf_height)
.//JPEG/jcprepct.cpp:253:	prep->this_row_group = 0;
.//JPEG/jcprepct.cpp:254:      if (prep->next_buf_row >= buf_height)
.//JPEG/jcprepct.cpp:255:	prep->next_buf_row = 0;
.//JPEG/jcprepct.cpp:256:      prep->next_buf_stop = prep->next_buf_row + cinfo->max_v_samp_factor;
.//JPEG/jcprepct.cpp:263: * Create the wrapped-around downsampling input buffer needed for context mode.
.//JPEG/jcprepct.cpp:269:  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
.//JPEG/jcprepct.cpp:270:  int rgroup_height = cinfo->max_v_samp_factor;
.//JPEG/jcprepct.cpp:279:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcprepct.cpp:280:				(cinfo->num_components * 5 * rgroup_height) *
.//JPEG/jcprepct.cpp:283:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcprepct.cpp:286:     * We make the buffer wide enough to allow the downsampler to edge-expand
.//JPEG/jcprepct.cpp:289:    true_buffer = (*cinfo->mem->alloc_sarray)
.//JPEG/jcprepct.cpp:291:       (JDIMENSION) (((long) compptr->width_in_blocks * DCTSIZE *
.//JPEG/jcprepct.cpp:292:		      cinfo->max_h_samp_factor) / compptr->h_samp_factor),
.//JPEG/jcprepct.cpp:302:    prep->color_buf[ci] = fake_buffer + rgroup_height;
.//JPEG/jcprepct.cpp:325:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcprepct.cpp:327:  cinfo->prep = (struct jpeg_c_prep_controller *) prep;
.//JPEG/jcprepct.cpp:328:  prep->pub.start_pass = start_pass_prep;
.//JPEG/jcprepct.cpp:331:   * We make the buffer wide enough to allow the downsampler to edge-expand
.//JPEG/jcprepct.cpp:334:  if (cinfo->downsample->need_context_rows) {
.//JPEG/jcprepct.cpp:337:    prep->pub.pre_process_data = pre_process_context;
.//JPEG/jcprepct.cpp:344:    prep->pub.pre_process_data = pre_process_data;
.//JPEG/jcprepct.cpp:345:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcprepct.cpp:347:      prep->color_buf[ci] = (*cinfo->mem->alloc_sarray)
.//JPEG/jcprepct.cpp:349:	 (JDIMENSION) (((long) compptr->width_in_blocks * DCTSIZE *
.//JPEG/jcprepct.cpp:350:			cinfo->max_h_samp_factor) / compptr->h_samp_factor),
.//JPEG/jcprepct.cpp:351:	 (JDIMENSION) cinfo->max_v_samp_factor);
.//JPEG/jcsample.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//JPEG/jcsample.cpp:15: * The downsampler is responsible for edge-expansion of its output data
.//JPEG/jcsample.cpp:23: * one row group's worth of pixels above and below the passed-in data;
.//JPEG/jcsample.cpp:29: *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.
.//JPEG/jcsample.cpp:32: * pixels covered by the output pixel.  The hi-falutin sampling literature
.//JPEG/jcsample.cpp:39: * A simple input-smoothing capability is provided.  This is mainly intended
.//JPEG/jcsample.cpp:40: * for cleaning up color-dithered GIF input files (if you find it inadequate,
.//JPEG/jcsample.cpp:43: * eight neighbors.  P's weight is 1-8*SF and each neighbor's weight is SF,
.//JPEG/jcsample.cpp:94:  int numcols = (int) (output_cols - input_cols);
.//JPEG/jcsample.cpp:99:      pixval = ptr[-1];		/* don't need GETJSAMPLE() here */
.//JPEG/jcsample.cpp:100:      for (count = numcols; count > 0; count--)
.//JPEG/jcsample.cpp:118:  my_downsample_ptr downsample = (my_downsample_ptr) cinfo->downsample;
.//JPEG/jcsample.cpp:123:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcsample.cpp:126:    out_ptr = output_buf[ci] + (out_row_group_index * compptr->v_samp_factor);
.//JPEG/jcsample.cpp:127:    (*downsample->methods[ci]) (cinfo, compptr, in_ptr, out_ptr);
.//JPEG/jcsample.cpp:145:  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
.//JPEG/jcsample.cpp:149:  h_expand = cinfo->max_h_samp_factor / compptr->h_samp_factor;
.//JPEG/jcsample.cpp:150:  v_expand = cinfo->max_v_samp_factor / compptr->v_samp_factor;
.//JPEG/jcsample.cpp:155:   * by the standard loop.  Special-casing padded output would be more
.//JPEG/jcsample.cpp:158:  expand_right_edge(input_data, cinfo->max_v_samp_factor,
.//JPEG/jcsample.cpp:159:		    cinfo->image_width, output_cols * h_expand);
.//JPEG/jcsample.cpp:162:  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
.//JPEG/jcsample.cpp:182: * This version handles the special case of a full-size component,
.//JPEG/jcsample.cpp:192:		    cinfo->max_v_samp_factor, cinfo->image_width);
.//JPEG/jcsample.cpp:193:  /* Edge-expand */
.//JPEG/jcsample.cpp:194:  expand_right_edge(output_data, cinfo->max_v_samp_factor,
.//JPEG/jcsample.cpp:195:		    cinfo->image_width, compptr->width_in_blocks * DCTSIZE);
.//JPEG/jcsample.cpp:217:  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
.//JPEG/jcsample.cpp:222:   * by the standard loop.  Special-casing padded output would be more
.//JPEG/jcsample.cpp:225:  expand_right_edge(input_data, cinfo->max_v_samp_factor,
.//JPEG/jcsample.cpp:226:		    cinfo->image_width, output_cols * 2);
.//JPEG/jcsample.cpp:228:  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
.//JPEG/jcsample.cpp:254:  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
.//JPEG/jcsample.cpp:259:   * by the standard loop.  Special-casing padded output would be more
.//JPEG/jcsample.cpp:262:  expand_right_edge(input_data, cinfo->max_v_samp_factor,
.//JPEG/jcsample.cpp:263:		    cinfo->image_width, output_cols * 2);
.//JPEG/jcsample.cpp:266:  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
.//JPEG/jcsample.cpp:297:  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
.//JPEG/jcsample.cpp:302:   * by the standard loop.  Special-casing padded output would be more
.//JPEG/jcsample.cpp:305:  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
.//JPEG/jcsample.cpp:306:		    cinfo->image_width, output_cols * 2);
.//JPEG/jcsample.cpp:311:   * (1-8*SF) to its own smoothed image and a fraction SF to each of the three
.//JPEG/jcsample.cpp:312:   * other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final
.//JPEG/jcsample.cpp:313:   * output.  The four corner-adjacent neighbor pixels contribute a fraction
.//JPEG/jcsample.cpp:315:   * eight edge-adjacent neighbors contribute SF to each of two smoothed
.//JPEG/jcsample.cpp:321:  memberscale = 16384 - cinfo->smoothing_factor * 80; /* scaled (1-5*SF)/4 */
.//JPEG/jcsample.cpp:322:  neighscale = cinfo->smoothing_factor * 16; /* scaled SF/4 */
.//JPEG/jcsample.cpp:325:  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
.//JPEG/jcsample.cpp:329:    above_ptr = input_data[inrow-1];
.//JPEG/jcsample.cpp:332:    /* Special case for first column: pretend column -1 is same as column 0 */
.//JPEG/jcsample.cpp:346:    for (colctr = output_cols - 2; colctr > 0; colctr--) {
.//JPEG/jcsample.cpp:350:      /* sum of edge-neighbor pixels */
.//JPEG/jcsample.cpp:353:		 GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[2]) +
.//JPEG/jcsample.cpp:354:		 GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[2]);
.//JPEG/jcsample.cpp:355:      /* The edge-neighbors count twice as much as corner-neighbors */
.//JPEG/jcsample.cpp:357:      /* Add in the corner-neighbors */
.//JPEG/jcsample.cpp:358:      neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[2]) +
.//JPEG/jcsample.cpp:359:		  GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[2]);
.//JPEG/jcsample.cpp:372:	       GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[1]) +
.//JPEG/jcsample.cpp:373:	       GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[1]);
.//JPEG/jcsample.cpp:375:    neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[1]) +
.//JPEG/jcsample.cpp:376:		GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[1]);
.//JPEG/jcsample.cpp:387: * This version handles the special case of a full-size component,
.//JPEG/jcsample.cpp:397:  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
.//JPEG/jcsample.cpp:403:   * by the standard loop.  Special-casing padded output would be more
.//JPEG/jcsample.cpp:406:  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
.//JPEG/jcsample.cpp:407:		    cinfo->image_width, output_cols);
.//JPEG/jcsample.cpp:410:   * smoothed pixel, while the main pixel contributes (1-8*SF).  In order
.//JPEG/jcsample.cpp:415:  memberscale = 65536L - cinfo->smoothing_factor * 512L; /* scaled 1-8*SF */
.//JPEG/jcsample.cpp:416:  neighscale = cinfo->smoothing_factor * 64; /* scaled SF */
.//JPEG/jcsample.cpp:418:  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
.//JPEG/jcsample.cpp:421:    above_ptr = input_data[outrow-1];
.//JPEG/jcsample.cpp:430:    neighsum = colsum + (colsum - membersum) + nextcolsum;
.//JPEG/jcsample.cpp:435:    for (colctr = output_cols - 2; colctr > 0; colctr--) {
.//JPEG/jcsample.cpp:440:      neighsum = lastcolsum + (colsum - membersum) + nextcolsum;
.//JPEG/jcsample.cpp:448:    neighsum = lastcolsum + (colsum - membersum) + colsum;
.//JPEG/jcsample.cpp:472:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jcsample.cpp:474:  cinfo->downsample = (struct jpeg_downsampler *) downsample;
.//JPEG/jcsample.cpp:475:  downsample->pub.start_pass = start_pass_downsample;
.//JPEG/jcsample.cpp:476:  downsample->pub.downsample = sep_downsample;
.//JPEG/jcsample.cpp:477:  downsample->pub.need_context_rows = FALSE;
.//JPEG/jcsample.cpp:479:  if (cinfo->CCIR601_sampling)
.//JPEG/jcsample.cpp:483:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jcsample.cpp:485:    if (compptr->h_samp_factor == cinfo->max_h_samp_factor &&
.//JPEG/jcsample.cpp:486:	compptr->v_samp_factor == cinfo->max_v_samp_factor) {
.//JPEG/jcsample.cpp:488:      if (cinfo->smoothing_factor) {
.//JPEG/jcsample.cpp:489:	downsample->methods[ci] = fullsize_smooth_downsample;
.//JPEG/jcsample.cpp:490:	downsample->pub.need_context_rows = TRUE;
.//JPEG/jcsample.cpp:493:	downsample->methods[ci] = fullsize_downsample;
.//JPEG/jcsample.cpp:494:    } else if (compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&
.//JPEG/jcsample.cpp:495:	       compptr->v_samp_factor == cinfo->max_v_samp_factor) {
.//JPEG/jcsample.cpp:497:      downsample->methods[ci] = h2v1_downsample;
.//JPEG/jcsample.cpp:498:    } else if (compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&
.//JPEG/jcsample.cpp:499:	       compptr->v_samp_factor * 2 == cinfo->max_v_samp_factor) {
.//JPEG/jcsample.cpp:501:      if (cinfo->smoothing_factor) {
.//JPEG/jcsample.cpp:502:	downsample->methods[ci] = h2v2_smooth_downsample;
.//JPEG/jcsample.cpp:503:	downsample->pub.need_context_rows = TRUE;
.//JPEG/jcsample.cpp:506:	downsample->methods[ci] = h2v2_downsample;
.//JPEG/jcsample.cpp:507:    } else if ((cinfo->max_h_samp_factor % compptr->h_samp_factor) == 0 &&
.//JPEG/jcsample.cpp:508:	       (cinfo->max_v_samp_factor % compptr->v_samp_factor) == 0) {
.//JPEG/jcsample.cpp:510:      downsample->methods[ci] = int_downsample;
.//JPEG/jcsample.cpp:516:  if (cinfo->smoothing_factor && !smoothok)
.//JPEG/jctrans.cpp:4: * Copyright (C) 1995-1998, Thomas G. Lane.
.//JPEG/jctrans.cpp:26: * Compression initialization for writing raw-coefficient data.
.//JPEG/jctrans.cpp:30: * The number of passed virtual arrays must match cinfo->num_components.
.//JPEG/jctrans.cpp:40:  if (cinfo->global_state != CSTATE_START)
.//JPEG/jctrans.cpp:41:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jctrans.cpp:45:  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
.//JPEG/jctrans.cpp:46:  (*cinfo->dest->init_destination) (cinfo);
.//JPEG/jctrans.cpp:50:  cinfo->next_scanline = 0;	/* so jpeg_write_marker works */
.//JPEG/jctrans.cpp:51:  cinfo->global_state = CSTATE_WRCOEFS;
.//JPEG/jctrans.cpp:72:  if (dstinfo->global_state != CSTATE_START)
.//JPEG/jctrans.cpp:73:    ERREXIT1(dstinfo, JERR_BAD_STATE, dstinfo->global_state);
.//JPEG/jctrans.cpp:75:  dstinfo->image_width = srcinfo->image_width;
.//JPEG/jctrans.cpp:76:  dstinfo->image_height = srcinfo->image_height;
.//JPEG/jctrans.cpp:77:  dstinfo->input_components = srcinfo->num_components;
.//JPEG/jctrans.cpp:78:  dstinfo->in_color_space = srcinfo->jpeg_color_space;
.//JPEG/jctrans.cpp:84:  jpeg_set_colorspace(dstinfo, srcinfo->jpeg_color_space);
.//JPEG/jctrans.cpp:85:  dstinfo->data_precision = srcinfo->data_precision;
.//JPEG/jctrans.cpp:86:  dstinfo->CCIR601_sampling = srcinfo->CCIR601_sampling;
.//JPEG/jctrans.cpp:89:    if (srcinfo->quant_tbl_ptrs[tblno] != NULL) {
.//JPEG/jctrans.cpp:90:      qtblptr = & dstinfo->quant_tbl_ptrs[tblno];
.//JPEG/jctrans.cpp:93:      MEMCOPY((*qtblptr)->quantval,
.//JPEG/jctrans.cpp:94:	      srcinfo->quant_tbl_ptrs[tblno]->quantval,
.//JPEG/jctrans.cpp:95:	      SIZEOF((*qtblptr)->quantval));
.//JPEG/jctrans.cpp:96:      (*qtblptr)->sent_table = FALSE;
.//JPEG/jctrans.cpp:99:  /* Copy the source's per-component info.
.//JPEG/jctrans.cpp:102:  dstinfo->num_components = srcinfo->num_components;
.//JPEG/jctrans.cpp:103:  if (dstinfo->num_components < 1 || dstinfo->num_components > MAX_COMPONENTS)
.//JPEG/jctrans.cpp:104:    ERREXIT2(dstinfo, JERR_COMPONENT_COUNT, dstinfo->num_components,
.//JPEG/jctrans.cpp:106:  for (ci = 0, incomp = srcinfo->comp_info, outcomp = dstinfo->comp_info;
.//JPEG/jctrans.cpp:107:       ci < dstinfo->num_components; ci++, incomp++, outcomp++) {
.//JPEG/jctrans.cpp:108:    outcomp->component_id = incomp->component_id;
.//JPEG/jctrans.cpp:109:    outcomp->h_samp_factor = incomp->h_samp_factor;
.//JPEG/jctrans.cpp:110:    outcomp->v_samp_factor = incomp->v_samp_factor;
.//JPEG/jctrans.cpp:111:    outcomp->quant_tbl_no = incomp->quant_tbl_no;
.//JPEG/jctrans.cpp:113:     * slot.  If not, the input file re-used this qtable slot.
.//JPEG/jctrans.cpp:116:    tblno = outcomp->quant_tbl_no;
.//JPEG/jctrans.cpp:118:	srcinfo->quant_tbl_ptrs[tblno] == NULL)
.//JPEG/jctrans.cpp:120:    slot_quant = srcinfo->quant_tbl_ptrs[tblno];
.//JPEG/jctrans.cpp:121:    c_quant = incomp->quant_table;
.//JPEG/jctrans.cpp:124:	if (c_quant->quantval[coefi] != slot_quant->quantval[coefi])
.//JPEG/jctrans.cpp:140:  if (srcinfo->saw_JFIF_marker) {
.//JPEG/jctrans.cpp:141:    if (srcinfo->JFIF_major_version == 1) {
.//JPEG/jctrans.cpp:142:      dstinfo->JFIF_major_version = srcinfo->JFIF_major_version;
.//JPEG/jctrans.cpp:143:      dstinfo->JFIF_minor_version = srcinfo->JFIF_minor_version;
.//JPEG/jctrans.cpp:145:    dstinfo->density_unit = srcinfo->density_unit;
.//JPEG/jctrans.cpp:146:    dstinfo->X_density = srcinfo->X_density;
.//JPEG/jctrans.cpp:147:    dstinfo->Y_density = srcinfo->Y_density;
.//JPEG/jctrans.cpp:164:  cinfo->input_components = 1;
.//JPEG/jctrans.cpp:169:  if (cinfo->arith_code) {
.//JPEG/jctrans.cpp:172:    if (cinfo->progressive_mode) {
.//JPEG/jctrans.cpp:188:  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
.//JPEG/jctrans.cpp:194:  (*cinfo->marker->write_file_header) (cinfo);
.//JPEG/jctrans.cpp:202: * dummy padding blocks on-the-fly rather than expecting them to be present
.//JPEG/jctrans.cpp:228:/* Reset within-iMCU-row counters for a new row */
.//JPEG/jctrans.cpp:230:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jctrans.cpp:236:  if (cinfo->comps_in_scan > 1) {
.//JPEG/jctrans.cpp:237:    coef->MCU_rows_per_iMCU_row = 1;
.//JPEG/jctrans.cpp:239:    if (coef->iMCU_row_num < (cinfo->total_iMCU_rows-1))
.//JPEG/jctrans.cpp:240:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
.//JPEG/jctrans.cpp:242:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
.//JPEG/jctrans.cpp:245:  coef->mcu_ctr = 0;
.//JPEG/jctrans.cpp:246:  coef->MCU_vert_offset = 0;
.//JPEG/jctrans.cpp:257:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jctrans.cpp:262:  coef->iMCU_row_num = 0;
.//JPEG/jctrans.cpp:280:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jctrans.cpp:282:  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
.//JPEG/jctrans.cpp:283:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//JPEG/jctrans.cpp:292:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jctrans.cpp:293:    compptr = cinfo->cur_comp_info[ci];
.//JPEG/jctrans.cpp:294:    buffer[ci] = (*cinfo->mem->access_virt_barray)
.//JPEG/jctrans.cpp:295:      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
.//JPEG/jctrans.cpp:296:       coef->iMCU_row_num * compptr->v_samp_factor,
.//JPEG/jctrans.cpp:297:       (JDIMENSION) compptr->v_samp_factor, FALSE);
.//JPEG/jctrans.cpp:301:  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
.//JPEG/jctrans.cpp:303:    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;
.//JPEG/jctrans.cpp:307:      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jctrans.cpp:308:	compptr = cinfo->cur_comp_info[ci];
.//JPEG/jctrans.cpp:309:	start_col = MCU_col_num * compptr->MCU_width;
.//JPEG/jctrans.cpp:310:	blockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
.//JPEG/jctrans.cpp:311:						: compptr->last_col_width;
.//JPEG/jctrans.cpp:312:	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
.//JPEG/jctrans.cpp:313:	  if (coef->iMCU_row_num < last_iMCU_row ||
.//JPEG/jctrans.cpp:314:	      yindex+yoffset < compptr->last_row_height) {
.//JPEG/jctrans.cpp:329:	  for (; xindex < compptr->MCU_width; xindex++) {
.//JPEG/jctrans.cpp:330:	    MCU_buffer[blkn] = coef->dummy_buffer[blkn];
.//JPEG/jctrans.cpp:331:	    MCU_buffer[blkn][0][0] = MCU_buffer[blkn-1][0][0];
.//JPEG/jctrans.cpp:337:      if (! (*cinfo->entropy->encode_mcu) (cinfo, MCU_buffer)) {
.//JPEG/jctrans.cpp:339:	coef->MCU_vert_offset = yoffset;
.//JPEG/jctrans.cpp:340:	coef->mcu_ctr = MCU_col_num;
.//JPEG/jctrans.cpp:345:    coef->mcu_ctr = 0;
.//JPEG/jctrans.cpp:348:  coef->iMCU_row_num++;
.//JPEG/jctrans.cpp:371:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jctrans.cpp:373:  cinfo->coef = (struct jpeg_c_coef_controller *) coef;
.//JPEG/jctrans.cpp:374:  coef->pub.start_pass = start_pass_coef;
.//JPEG/jctrans.cpp:375:  coef->pub.compress_data = compress_output;
.//JPEG/jctrans.cpp:378:  coef->whole_image = coef_arrays;
.//JPEG/jctrans.cpp:380:  /* Allocate and pre-zero space for dummy DCT blocks. */
.//JPEG/jctrans.cpp:382:    (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jctrans.cpp:386:    coef->dummy_buffer[i] = buffer + i;
.//JPEG/jdapimin.cpp:4:* Copyright (C) 1994-1998, Thomas G. Lane.
.//JPEG/jdapimin.cpp:10:* needed in either the normal full-decompression case or the
.//JPEG/jdapimin.cpp:11:* transcoding-only case.
.//JPEG/jdapimin.cpp:35:	cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
.//JPEG/jdapimin.cpp:49:		struct jpeg_error_mgr * err = cinfo->err;
.//JPEG/jdapimin.cpp:50:		void * client_data = cinfo->client_data; /* ignore Purify complaint here */
.//JPEG/jdapimin.cpp:52:		cinfo->err = err;
.//JPEG/jdapimin.cpp:53:		cinfo->client_data = client_data;
.//JPEG/jdapimin.cpp:55:	cinfo->is_decompressor = TRUE;
.//JPEG/jdapimin.cpp:61:	cinfo->progress = NULL;
.//JPEG/jdapimin.cpp:62:	cinfo->src = NULL;
.//JPEG/jdapimin.cpp:65:		cinfo->quant_tbl_ptrs[i] = NULL;
.//JPEG/jdapimin.cpp:68:		cinfo->dc_huff_tbl_ptrs[i] = NULL;
.//JPEG/jdapimin.cpp:69:		cinfo->ac_huff_tbl_ptrs[i] = NULL;
.//JPEG/jdapimin.cpp:75:	cinfo->marker_list = NULL;
.//JPEG/jdapimin.cpp:82:	cinfo->global_state = DSTATE_START;
.//JPEG/jdapimin.cpp:119:	switch (cinfo->num_components) {
.//JPEG/jdapimin.cpp:121:		cinfo->jpeg_color_space = JCS_GRAYSCALE;
.//JPEG/jdapimin.cpp:122:		cinfo->out_color_space = JCS_GRAYSCALE;
.//JPEG/jdapimin.cpp:126:		if (cinfo->saw_JFIF_marker) {
.//JPEG/jdapimin.cpp:127:			cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */
.//JPEG/jdapimin.cpp:128:		} else if (cinfo->saw_Adobe_marker) {
.//JPEG/jdapimin.cpp:129:			switch (cinfo->Adobe_transform) {
.//JPEG/jdapimin.cpp:131:				cinfo->jpeg_color_space = JCS_RGB;
.//JPEG/jdapimin.cpp:134:				cinfo->jpeg_color_space = JCS_YCbCr;
.//JPEG/jdapimin.cpp:137:				WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
.//JPEG/jdapimin.cpp:138:				cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
.//JPEG/jdapimin.cpp:143:			int cid0 = cinfo->comp_info[0].component_id;
.//JPEG/jdapimin.cpp:144:			int cid1 = cinfo->comp_info[1].component_id;
.//JPEG/jdapimin.cpp:145:			int cid2 = cinfo->comp_info[2].component_id;
.//JPEG/jdapimin.cpp:148:				cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */
.//JPEG/jdapimin.cpp:150:				cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
.//JPEG/jdapimin.cpp:153:				cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
.//JPEG/jdapimin.cpp:157:		cinfo->out_color_space = JCS_RGB;
.//JPEG/jdapimin.cpp:161:				if (cinfo->saw_Adobe_marker) {
.//JPEG/jdapimin.cpp:162:					switch (cinfo->Adobe_transform) {
.//JPEG/jdapimin.cpp:164:						cinfo->jpeg_color_space = JCS_CMYK;
.//JPEG/jdapimin.cpp:167:						cinfo->jpeg_color_space = JCS_YCCK;
.//JPEG/jdapimin.cpp:170:						WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
.//JPEG/jdapimin.cpp:171:						cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */
.//JPEG/jdapimin.cpp:176:					cinfo->jpeg_color_space = JCS_CMYK;
.//JPEG/jdapimin.cpp:178:				cinfo->out_color_space = JCS_CMYK;
.//JPEG/jdapimin.cpp:182:						cinfo->jpeg_color_space = JCS_UNKNOWN;
.//JPEG/jdapimin.cpp:183:						cinfo->out_color_space = JCS_UNKNOWN;
.//JPEG/jdapimin.cpp:188:	cinfo->scale_num = 1;		/* 1:1 scaling */
.//JPEG/jdapimin.cpp:189:	cinfo->scale_denom = 1;
.//JPEG/jdapimin.cpp:190:	cinfo->output_gamma = 1.0;
.//JPEG/jdapimin.cpp:191:	cinfo->buffered_image = FALSE;
.//JPEG/jdapimin.cpp:192:	cinfo->raw_data_out = FALSE;
.//JPEG/jdapimin.cpp:193:	cinfo->dct_method = JDCT_DEFAULT;
.//JPEG/jdapimin.cpp:194:	cinfo->do_fancy_upsampling = TRUE;
.//JPEG/jdapimin.cpp:195:	cinfo->do_block_smoothing = TRUE;
.//JPEG/jdapimin.cpp:196:	cinfo->quantize_colors = FALSE;
.//JPEG/jdapimin.cpp:198:	cinfo->dither_mode = JDITHER_FS;
.//JPEG/jdapimin.cpp:200:	cinfo->two_pass_quantize = TRUE;
.//JPEG/jdapimin.cpp:202:	cinfo->two_pass_quantize = FALSE;
.//JPEG/jdapimin.cpp:204:	cinfo->desired_number_of_colors = 256;
.//JPEG/jdapimin.cpp:205:	cinfo->colormap = NULL;
.//JPEG/jdapimin.cpp:206:	/* Initialize for no mode change in buffered-image mode. */
.//JPEG/jdapimin.cpp:207:	cinfo->enable_1pass_quant = FALSE;
.//JPEG/jdapimin.cpp:208:	cinfo->enable_external_quant = FALSE;
.//JPEG/jdapimin.cpp:209:	cinfo->enable_2pass_quant = FALSE;
.//JPEG/jdapimin.cpp:227:* re-use the JPEG object to read the abbreviated image datastream(s).
.//JPEG/jdapimin.cpp:231:* should load more source data and then re-call jpeg_read_header to resume
.//JPEG/jdapimin.cpp:233:* If a non-suspending data source is used and require_image is TRUE, then the
.//JPEG/jdapimin.cpp:245:	if (cinfo->global_state != DSTATE_START &&
.//JPEG/jdapimin.cpp:246:		cinfo->global_state != DSTATE_INHEADER)
.//JPEG/jdapimin.cpp:247:		ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdapimin.cpp:280:* of critical state-transition actions, namely initial setup and
.//JPEG/jdapimin.cpp:281:* transition from header scanning to ready-for-start_decompress.
.//JPEG/jdapimin.cpp:292:	switch (cinfo->global_state) {
.//JPEG/jdapimin.cpp:294:		/* Start-of-datastream actions: reset appropriate modules */
.//JPEG/jdapimin.cpp:295:		(*cinfo->inputctl->reset_input_controller) (cinfo);
.//JPEG/jdapimin.cpp:297:		(*cinfo->src->init_source) (cinfo);
.//JPEG/jdapimin.cpp:298:		cinfo->global_state = DSTATE_INHEADER;
.//JPEG/jdapimin.cpp:301:		retcode = (*cinfo->inputctl->consume_input) (cinfo);
.//JPEG/jdapimin.cpp:306:			cinfo->global_state = DSTATE_READY;
.//JPEG/jdapimin.cpp:320:		retcode = (*cinfo->inputctl->consume_input) (cinfo);
.//JPEG/jdapimin.cpp:323:		ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdapimin.cpp:337:	if (cinfo->global_state < DSTATE_START ||
.//JPEG/jdapimin.cpp:338:		cinfo->global_state > DSTATE_STOPPING)
.//JPEG/jdapimin.cpp:339:		ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdapimin.cpp:340:	return cinfo->inputctl->eoi_reached;
.//JPEG/jdapimin.cpp:352:	if (cinfo->global_state < DSTATE_READY ||
.//JPEG/jdapimin.cpp:353:		cinfo->global_state > DSTATE_STOPPING)
.//JPEG/jdapimin.cpp:354:		ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdapimin.cpp:355:	return cinfo->inputctl->has_multiple_scans;
.//JPEG/jdapimin.cpp:370:	if ((cinfo->global_state == DSTATE_SCANNING ||
.//JPEG/jdapimin.cpp:371:		cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
.//JPEG/jdapimin.cpp:372:		/* Terminate final pass of non-buffered mode */
.//JPEG/jdapimin.cpp:373:		if (cinfo->output_scanline < cinfo->output_height)
.//JPEG/jdapimin.cpp:375:		(*cinfo->master->finish_output_pass) (cinfo);
.//JPEG/jdapimin.cpp:376:		cinfo->global_state = DSTATE_STOPPING;
.//JPEG/jdapimin.cpp:377:	} else if (cinfo->global_state == DSTATE_BUFIMAGE) {
.//JPEG/jdapimin.cpp:378:		/* Finishing after a buffered-image operation */
.//JPEG/jdapimin.cpp:379:		cinfo->global_state = DSTATE_STOPPING;
.//JPEG/jdapimin.cpp:380:	} else if (cinfo->global_state != DSTATE_STOPPING) {
.//JPEG/jdapimin.cpp:382:		ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdapimin.cpp:385:	while (! cinfo->inputctl->eoi_reached) {
.//JPEG/jdapimin.cpp:386:		if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
.//JPEG/jdapimin.cpp:390:	(*cinfo->src->term_source) (cinfo);
.//JPEG/jdapistd.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jdapistd.cpp:10: * used in the normal full-decompression case.  They are not used by a
.//JPEG/jdapistd.cpp:11: * transcoding-only application.  Note that if an application links in
.//JPEG/jdapistd.cpp:40:  if (cinfo->global_state == DSTATE_READY) {
.//JPEG/jdapistd.cpp:43:    if (cinfo->buffered_image) {
.//JPEG/jdapistd.cpp:45:      cinfo->global_state = DSTATE_BUFIMAGE;
.//JPEG/jdapistd.cpp:48:    cinfo->global_state = DSTATE_PRELOAD;
.//JPEG/jdapistd.cpp:50:  if (cinfo->global_state == DSTATE_PRELOAD) {
.//JPEG/jdapistd.cpp:52:    if (cinfo->inputctl->has_multiple_scans) {
.//JPEG/jdapistd.cpp:57:	if (cinfo->progress != NULL)
.//JPEG/jdapistd.cpp:58:	  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//JPEG/jdapistd.cpp:60:	retcode = (*cinfo->inputctl->consume_input) (cinfo);
.//JPEG/jdapistd.cpp:66:	if (cinfo->progress != NULL &&
.//JPEG/jdapistd.cpp:68:	  if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
.//JPEG/jdapistd.cpp:70:	    cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
.//JPEG/jdapistd.cpp:78:    cinfo->output_scan_number = cinfo->input_scan_number;
.//JPEG/jdapistd.cpp:79:  } else if (cinfo->global_state != DSTATE_PRESCAN)
.//JPEG/jdapistd.cpp:80:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdapistd.cpp:97:  if (cinfo->global_state != DSTATE_PRESCAN) {
.//JPEG/jdapistd.cpp:99:    (*cinfo->master->prepare_for_output_pass) (cinfo);
.//JPEG/jdapistd.cpp:100:    cinfo->output_scanline = 0;
.//JPEG/jdapistd.cpp:101:    cinfo->global_state = DSTATE_PRESCAN;
.//JPEG/jdapistd.cpp:104:  while (cinfo->master->is_dummy_pass) {
.//JPEG/jdapistd.cpp:107:    while (cinfo->output_scanline < cinfo->output_height) {
.//JPEG/jdapistd.cpp:110:      if (cinfo->progress != NULL) {
.//JPEG/jdapistd.cpp:111:	cinfo->progress->pass_counter = (long) cinfo->output_scanline;
.//JPEG/jdapistd.cpp:112:	cinfo->progress->pass_limit = (long) cinfo->output_height;
.//JPEG/jdapistd.cpp:113:	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//JPEG/jdapistd.cpp:116:      last_scanline = cinfo->output_scanline;
.//JPEG/jdapistd.cpp:117:      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,
.//JPEG/jdapistd.cpp:118:				    &cinfo->output_scanline, (JDIMENSION) 0);
.//JPEG/jdapistd.cpp:119:      if (cinfo->output_scanline == last_scanline)
.//JPEG/jdapistd.cpp:123:    (*cinfo->master->finish_output_pass) (cinfo);
.//JPEG/jdapistd.cpp:124:    (*cinfo->master->prepare_for_output_pass) (cinfo);
.//JPEG/jdapistd.cpp:125:    cinfo->output_scanline = 0;
.//JPEG/jdapistd.cpp:133:  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;
.//JPEG/jdapistd.cpp:157:  if (cinfo->global_state != DSTATE_SCANNING)
.//JPEG/jdapistd.cpp:158:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdapistd.cpp:159:  if (cinfo->output_scanline >= cinfo->output_height) {
.//JPEG/jdapistd.cpp:165:  if (cinfo->progress != NULL) {
.//JPEG/jdapistd.cpp:166:    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
.//JPEG/jdapistd.cpp:167:    cinfo->progress->pass_limit = (long) cinfo->output_height;
.//JPEG/jdapistd.cpp:168:    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//JPEG/jdapistd.cpp:173:  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);
.//JPEG/jdapistd.cpp:174:  cinfo->output_scanline += row_ctr;
.//JPEG/jdapistd.cpp:190:  if (cinfo->global_state != DSTATE_RAW_OK)
.//JPEG/jdapistd.cpp:191:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdapistd.cpp:192:  if (cinfo->output_scanline >= cinfo->output_height) {
.//JPEG/jdapistd.cpp:198:  if (cinfo->progress != NULL) {
.//JPEG/jdapistd.cpp:199:    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
.//JPEG/jdapistd.cpp:200:    cinfo->progress->pass_limit = (long) cinfo->output_height;
.//JPEG/jdapistd.cpp:201:    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//JPEG/jdapistd.cpp:205:  lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size;
.//JPEG/jdapistd.cpp:210:  if (! (*cinfo->coef->decompress_data) (cinfo, data))
.//JPEG/jdapistd.cpp:214:  cinfo->output_scanline += lines_per_iMCU_row;
.//JPEG/jdapistd.cpp:219:/* Additional entry points for buffered-image mode. */
.//JPEG/jdapistd.cpp:224: * Initialize for an output pass in buffered-image mode.
.//JPEG/jdapistd.cpp:230:  if (cinfo->global_state != DSTATE_BUFIMAGE &&
.//JPEG/jdapistd.cpp:231:      cinfo->global_state != DSTATE_PRESCAN)
.//JPEG/jdapistd.cpp:232:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdapistd.cpp:236:  if (cinfo->inputctl->eoi_reached &&
.//JPEG/jdapistd.cpp:237:      scan_number > cinfo->input_scan_number)
.//JPEG/jdapistd.cpp:238:    scan_number = cinfo->input_scan_number;
.//JPEG/jdapistd.cpp:239:  cinfo->output_scan_number = scan_number;
.//JPEG/jdapistd.cpp:246: * Finish up after an output pass in buffered-image mode.
.//JPEG/jdapistd.cpp:255:  if ((cinfo->global_state == DSTATE_SCANNING ||
.//JPEG/jdapistd.cpp:256:       cinfo->global_state == DSTATE_RAW_OK) && cinfo->buffered_image) {
.//JPEG/jdapistd.cpp:259:    (*cinfo->master->finish_output_pass) (cinfo);
.//JPEG/jdapistd.cpp:260:    cinfo->global_state = DSTATE_BUFPOST;
.//JPEG/jdapistd.cpp:261:  } else if (cinfo->global_state != DSTATE_BUFPOST) {
.//JPEG/jdapistd.cpp:263:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdapistd.cpp:266:  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
.//JPEG/jdapistd.cpp:267:	 ! cinfo->inputctl->eoi_reached) {
.//JPEG/jdapistd.cpp:268:    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
.//JPEG/jdapistd.cpp:271:  cinfo->global_state = DSTATE_BUFIMAGE;
.//JPEG/jdatadst.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jdatadst.cpp:13: * JOCTETs into 8-bit-wide elements on external storage.  If char is wider
.//JPEG/jdatadst.cpp:38: * Initialize destination --- called by jpeg_start_compress
.//JPEG/jdatadst.cpp:45:  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
.//JPEG/jdatadst.cpp:47:  /* Allocate the output buffer --- it will be released when done with image */
.//JPEG/jdatadst.cpp:48:  dest->buffer = (JOCTET *)
.//JPEG/jdatadst.cpp:49:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdatadst.cpp:52:  dest->pub.next_output_byte = dest->buffer;
.//JPEG/jdatadst.cpp:53:  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;
.//JPEG/jdatadst.cpp:58: * Empty the output buffer --- called whenever buffer fills up.
.//JPEG/jdatadst.cpp:71: * suspension --- see the documentation.
.//JPEG/jdatadst.cpp:83:  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
.//JPEG/jdatadst.cpp:85:  if (JFWRITE(dest->outfile, dest->buffer, OUTPUT_BUF_SIZE) !=
.//JPEG/jdatadst.cpp:89:  dest->pub.next_output_byte = dest->buffer;
.//JPEG/jdatadst.cpp:90:  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;
.//JPEG/jdatadst.cpp:97: * Terminate destination --- called by jpeg_finish_compress
.//JPEG/jdatadst.cpp:108:  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
.//JPEG/jdatadst.cpp:109:  size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;
.//JPEG/jdatadst.cpp:113:    if (JFWRITE(dest->outfile, dest->buffer, datacount) != datacount)
.//JPEG/jdatadst.cpp:116:  fflush(dest->outfile);
.//JPEG/jdatadst.cpp:118:  if (ferror(dest->outfile))
.//JPEG/jdatadst.cpp:135:   * can be written to the same file without re-executing jpeg_stdio_dest.
.//JPEG/jdatadst.cpp:140:  if (cinfo->dest == NULL) {	/* first time for this JPEG object? */
.//JPEG/jdatadst.cpp:141:    cinfo->dest = (struct jpeg_destination_mgr *)
.//JPEG/jdatadst.cpp:142:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//JPEG/jdatadst.cpp:146:  dest = (my_dest_ptr) cinfo->dest;
.//JPEG/jdatadst.cpp:147:  dest->pub.init_destination = init_destination;
.//JPEG/jdatadst.cpp:148:  dest->pub.empty_output_buffer = empty_output_buffer;
.//JPEG/jdatadst.cpp:149:  dest->pub.term_destination = term_destination;
.//JPEG/jdatadst.cpp:150:  dest->outfile = outfile;
.//JPEG/jdatasrc.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jdatasrc.cpp:13: * JOCTETs from 8-bit-wide elements on external storage.  If char is wider
.//JPEG/jdatasrc.cpp:39: * Initialize source --- called by jpeg_read_header
.//JPEG/jdatasrc.cpp:46:  my_src_ptr src = (my_src_ptr) cinfo->src;
.//JPEG/jdatasrc.cpp:48:  /* We reset the empty-input-file flag for each image,
.//JPEG/jdatasrc.cpp:52:  src->start_of_file = TRUE;
.//JPEG/jdatasrc.cpp:57: * Fill the input buffer --- called whenever buffer is emptied.
.//JPEG/jdatasrc.cpp:68: * fake EOI marker is the best course of action --- this will allow the
.//JPEG/jdatasrc.cpp:79: * that there are substantial restrictions on the use of suspension --- see
.//JPEG/jdatasrc.cpp:92:  my_src_ptr src = (my_src_ptr) cinfo->src;
.//JPEG/jdatasrc.cpp:95:  nbytes = JFREAD(src->infile, src->buffer, INPUT_BUF_SIZE);
.//JPEG/jdatasrc.cpp:98:    if (src->start_of_file)	/* Treat empty input file as fatal error */
.//JPEG/jdatasrc.cpp:102:    src->buffer[0] = (JOCTET) 0xFF;
.//JPEG/jdatasrc.cpp:103:    src->buffer[1] = (JOCTET) JPEG_EOI;
.//JPEG/jdatasrc.cpp:107:  src->pub.next_input_byte = src->buffer;
.//JPEG/jdatasrc.cpp:108:  src->pub.bytes_in_buffer = nbytes;
.//JPEG/jdatasrc.cpp:109:  src->start_of_file = FALSE;
.//JPEG/jdatasrc.cpp:116: * Skip data --- used to skip over a potentially large amount of
.//JPEG/jdatasrc.cpp:119: * Writers of suspendable-input applications must note that skip_input_data
.//JPEG/jdatasrc.cpp:130:  my_src_ptr src = (my_src_ptr) cinfo->src;
.//JPEG/jdatasrc.cpp:134:   * any trouble anyway --- large skips are infrequent.
.//JPEG/jdatasrc.cpp:137:    while (num_bytes > (long) src->pub.bytes_in_buffer) {
.//JPEG/jdatasrc.cpp:138:      num_bytes -= (long) src->pub.bytes_in_buffer;
.//JPEG/jdatasrc.cpp:144:    src->pub.next_input_byte += (size_t) num_bytes;
.//JPEG/jdatasrc.cpp:145:    src->pub.bytes_in_buffer -= (size_t) num_bytes;
.//JPEG/jdatasrc.cpp:160: * Terminate source --- called by jpeg_finish_decompress
.//JPEG/jdatasrc.cpp:161: * after all data has been read.  Often a no-op.
.//JPEG/jdatasrc.cpp:193:  if (cinfo->src == NULL) {	/* first time for this JPEG object? */
.//JPEG/jdatasrc.cpp:194:    cinfo->src = (struct jpeg_source_mgr *)
.//JPEG/jdatasrc.cpp:195:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//JPEG/jdatasrc.cpp:197:    src = (my_src_ptr) cinfo->src;
.//JPEG/jdatasrc.cpp:198:    src->buffer = (JOCTET *)
.//JPEG/jdatasrc.cpp:199:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//JPEG/jdatasrc.cpp:203:  src = (my_src_ptr) cinfo->src;
.//JPEG/jdatasrc.cpp:204:  src->pub.init_source = init_source;
.//JPEG/jdatasrc.cpp:205:  src->pub.fill_input_buffer = fill_input_buffer;
.//JPEG/jdatasrc.cpp:206:  src->pub.skip_input_data = skip_input_data;
.//JPEG/jdatasrc.cpp:207:  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
.//JPEG/jdatasrc.cpp:208:  src->pub.term_source = term_source;
.//JPEG/jdatasrc.cpp:209:  src->infile = infile;
.//JPEG/jdatasrc.cpp:210:  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
.//JPEG/jdatasrc.cpp:211:  src->pub.next_input_byte = NULL; /* until buffer loaded */
.//JPEG/jdcoefct.cpp:4: * Copyright (C) 1994-1997, Thomas G. Lane.
.//JPEG/jdcoefct.cpp:10: * The coefficient buffer lies between entropy decoding and inverse-DCT steps.
.//JPEG/jdcoefct.cpp:12: * In buffered-image mode, this controller is the interface between
.//JPEG/jdcoefct.cpp:13: * input-oriented processing and output-oriented processing.
.//JPEG/jdcoefct.cpp:32:  /* cinfo->input_iMCU_row is also used for this. */
.//JPEG/jdcoefct.cpp:37:  /* The output side's location is represented by cinfo->output_iMCU_row. */
.//JPEG/jdcoefct.cpp:39:  /* In single-pass modes, it's sufficient to buffer just one MCU.
.//JPEG/jdcoefct.cpp:45:   * In multi-pass modes, this array points to the current MCU's blocks
.//JPEG/jdcoefct.cpp:51:  /* In multi-pass modes, we need a virtual block array for each component. */
.//JPEG/jdcoefct.cpp:80:/* Reset within-iMCU-row counters for a new row (input side) */
.//JPEG/jdcoefct.cpp:82:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jdcoefct.cpp:88:  if (cinfo->comps_in_scan > 1) {
.//JPEG/jdcoefct.cpp:89:    coef->MCU_rows_per_iMCU_row = 1;
.//JPEG/jdcoefct.cpp:91:    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
.//JPEG/jdcoefct.cpp:92:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
.//JPEG/jdcoefct.cpp:94:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
.//JPEG/jdcoefct.cpp:97:  coef->MCU_ctr = 0;
.//JPEG/jdcoefct.cpp:98:  coef->MCU_vert_offset = 0;
.//JPEG/jdcoefct.cpp:109:  cinfo->input_iMCU_row = 0;
.//JPEG/jdcoefct.cpp:122:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jdcoefct.cpp:125:  if (coef->pub.coef_arrays != NULL) {
.//JPEG/jdcoefct.cpp:126:    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
.//JPEG/jdcoefct.cpp:127:      coef->pub.decompress_data = decompress_smooth_data;
.//JPEG/jdcoefct.cpp:129:      coef->pub.decompress_data = decompress_data;
.//JPEG/jdcoefct.cpp:132:  cinfo->output_iMCU_row = 0;
.//JPEG/jdcoefct.cpp:137: * Decompress and return some data in the single-pass case.
.//JPEG/jdcoefct.cpp:139: * Input and output must run in lockstep since we have only a one-MCU buffer.
.//JPEG/jdcoefct.cpp:149:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jdcoefct.cpp:151:  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
.//JPEG/jdcoefct.cpp:152:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//JPEG/jdcoefct.cpp:160:  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
.//JPEG/jdcoefct.cpp:162:    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
.//JPEG/jdcoefct.cpp:165:      jzero_far((void FAR *) coef->MCU_buffer[0],
.//JPEG/jdcoefct.cpp:166:		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
.//JPEG/jdcoefct.cpp:167:      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
.//JPEG/jdcoefct.cpp:169:	coef->MCU_vert_offset = yoffset;
.//JPEG/jdcoefct.cpp:170:	coef->MCU_ctr = MCU_col_num;
.//JPEG/jdcoefct.cpp:179:      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jdcoefct.cpp:180:	compptr = cinfo->cur_comp_info[ci];
.//JPEG/jdcoefct.cpp:182:	if (! compptr->component_needed) {
.//JPEG/jdcoefct.cpp:183:	  blkn += compptr->MCU_blocks;
.//JPEG/jdcoefct.cpp:186:	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
.//JPEG/jdcoefct.cpp:187:	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
.//JPEG/jdcoefct.cpp:188:						    : compptr->last_col_width;
.//JPEG/jdcoefct.cpp:189:	output_ptr = output_buf[compptr->component_index] +
.//JPEG/jdcoefct.cpp:190:	  yoffset * compptr->DCT_scaled_size;
.//JPEG/jdcoefct.cpp:191:	start_col = MCU_col_num * compptr->MCU_sample_width;
.//JPEG/jdcoefct.cpp:192:	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
.//JPEG/jdcoefct.cpp:193:	  if (cinfo->input_iMCU_row < last_iMCU_row ||
.//JPEG/jdcoefct.cpp:194:	      yoffset+yindex < compptr->last_row_height) {
.//JPEG/jdcoefct.cpp:198:			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
.//JPEG/jdcoefct.cpp:200:	      output_col += compptr->DCT_scaled_size;
.//JPEG/jdcoefct.cpp:203:	  blkn += compptr->MCU_width;
.//JPEG/jdcoefct.cpp:204:	  output_ptr += compptr->DCT_scaled_size;
.//JPEG/jdcoefct.cpp:209:    coef->MCU_ctr = 0;
.//JPEG/jdcoefct.cpp:212:  cinfo->output_iMCU_row++;
.//JPEG/jdcoefct.cpp:213:  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
.//JPEG/jdcoefct.cpp:218:  (*cinfo->inputctl->finish_input_pass) (cinfo);
.//JPEG/jdcoefct.cpp:224: * Dummy consume-input routine for single-pass operation.
.//JPEG/jdcoefct.cpp:237: * Consume input data and store it in the full-image coefficient buffer.
.//JPEG/jdcoefct.cpp:246:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jdcoefct.cpp:255:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jdcoefct.cpp:256:    compptr = cinfo->cur_comp_info[ci];
.//JPEG/jdcoefct.cpp:257:    buffer[ci] = (*cinfo->mem->access_virt_barray)
.//JPEG/jdcoefct.cpp:258:      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
.//JPEG/jdcoefct.cpp:259:       cinfo->input_iMCU_row * compptr->v_samp_factor,
.//JPEG/jdcoefct.cpp:260:       (JDIMENSION) compptr->v_samp_factor, TRUE);
.//JPEG/jdcoefct.cpp:263:     * because we requested a pre-zeroed array.
.//JPEG/jdcoefct.cpp:268:  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
.//JPEG/jdcoefct.cpp:270:    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
.//JPEG/jdcoefct.cpp:274:      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jdcoefct.cpp:275:	compptr = cinfo->cur_comp_info[ci];
.//JPEG/jdcoefct.cpp:276:	start_col = MCU_col_num * compptr->MCU_width;
.//JPEG/jdcoefct.cpp:277:	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
.//JPEG/jdcoefct.cpp:279:	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
.//JPEG/jdcoefct.cpp:280:	    coef->MCU_buffer[blkn++] = buffer_ptr++;
.//JPEG/jdcoefct.cpp:285:      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
.//JPEG/jdcoefct.cpp:287:	coef->MCU_vert_offset = yoffset;
.//JPEG/jdcoefct.cpp:288:	coef->MCU_ctr = MCU_col_num;
.//JPEG/jdcoefct.cpp:293:    coef->MCU_ctr = 0;
.//JPEG/jdcoefct.cpp:296:  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
.//JPEG/jdcoefct.cpp:301:  (*cinfo->inputctl->finish_input_pass) (cinfo);
.//JPEG/jdcoefct.cpp:307: * Decompress and return some data in the multi-pass case.
.//JPEG/jdcoefct.cpp:317:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jdcoefct.cpp:318:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//JPEG/jdcoefct.cpp:329:  while (cinfo->input_scan_number < cinfo->output_scan_number ||
.//JPEG/jdcoefct.cpp:330:	 (cinfo->input_scan_number == cinfo->output_scan_number &&
.//JPEG/jdcoefct.cpp:331:	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
.//JPEG/jdcoefct.cpp:332:    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
.//JPEG/jdcoefct.cpp:337:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdcoefct.cpp:340:    if (! compptr->component_needed)
.//JPEG/jdcoefct.cpp:343:    buffer = (*cinfo->mem->access_virt_barray)
.//JPEG/jdcoefct.cpp:344:      ((j_common_ptr) cinfo, coef->whole_image[ci],
.//JPEG/jdcoefct.cpp:345:       cinfo->output_iMCU_row * compptr->v_samp_factor,
.//JPEG/jdcoefct.cpp:346:       (JDIMENSION) compptr->v_samp_factor, FALSE);
.//JPEG/jdcoefct.cpp:347:    /* Count non-dummy DCT block rows in this iMCU row. */
.//JPEG/jdcoefct.cpp:348:    if (cinfo->output_iMCU_row < last_iMCU_row)
.//JPEG/jdcoefct.cpp:349:      block_rows = compptr->v_samp_factor;
.//JPEG/jdcoefct.cpp:351:      /* NB: can't use last_row_height here; it is input-side-dependent! */
.//JPEG/jdcoefct.cpp:352:      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
.//JPEG/jdcoefct.cpp:353:      if (block_rows == 0) block_rows = compptr->v_samp_factor;
.//JPEG/jdcoefct.cpp:355:    inverse_DCT = cinfo->idct->inverse_DCT[ci];
.//JPEG/jdcoefct.cpp:361:      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
.//JPEG/jdcoefct.cpp:365:	output_col += compptr->DCT_scaled_size;
.//JPEG/jdcoefct.cpp:367:      output_ptr += compptr->DCT_scaled_size;
.//JPEG/jdcoefct.cpp:371:  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
.//JPEG/jdcoefct.cpp:389:/* Natural-order array positions of the first 5 zigzag-order coefficients */
.//JPEG/jdcoefct.cpp:407:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jdcoefct.cpp:415:  if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)
.//JPEG/jdcoefct.cpp:419:  if (coef->coef_bits_latch == NULL)
.//JPEG/jdcoefct.cpp:420:    coef->coef_bits_latch = (int *)
.//JPEG/jdcoefct.cpp:421:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdcoefct.cpp:422:				  cinfo->num_components *
.//JPEG/jdcoefct.cpp:424:  coef_bits_latch = coef->coef_bits_latch;
.//JPEG/jdcoefct.cpp:426:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdcoefct.cpp:429:    if ((qtable = compptr->quant_table) == NULL)
.//JPEG/jdcoefct.cpp:431:    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
.//JPEG/jdcoefct.cpp:432:    if (qtable->quantval[0] == 0 ||
.//JPEG/jdcoefct.cpp:433:	qtable->quantval[Q01_POS] == 0 ||
.//JPEG/jdcoefct.cpp:434:	qtable->quantval[Q10_POS] == 0 ||
.//JPEG/jdcoefct.cpp:435:	qtable->quantval[Q20_POS] == 0 ||
.//JPEG/jdcoefct.cpp:436:	qtable->quantval[Q11_POS] == 0 ||
.//JPEG/jdcoefct.cpp:437:	qtable->quantval[Q02_POS] == 0)
.//JPEG/jdcoefct.cpp:440:    coef_bits = cinfo->coef_bits[ci];
.//JPEG/jdcoefct.cpp:463:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//JPEG/jdcoefct.cpp:464:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//JPEG/jdcoefct.cpp:482:  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
.//JPEG/jdcoefct.cpp:483:	 ! cinfo->inputctl->eoi_reached) {
.//JPEG/jdcoefct.cpp:484:    if (cinfo->input_scan_number == cinfo->output_scan_number) {
.//JPEG/jdcoefct.cpp:490:      JDIMENSION delta = (cinfo->Ss == 0) ? 1 : 0;
.//JPEG/jdcoefct.cpp:491:      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)
.//JPEG/jdcoefct.cpp:494:    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
.//JPEG/jdcoefct.cpp:499:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdcoefct.cpp:502:    if (! compptr->component_needed)
.//JPEG/jdcoefct.cpp:504:    /* Count non-dummy DCT block rows in this iMCU row. */
.//JPEG/jdcoefct.cpp:505:    if (cinfo->output_iMCU_row < last_iMCU_row) {
.//JPEG/jdcoefct.cpp:506:      block_rows = compptr->v_samp_factor;
.//JPEG/jdcoefct.cpp:510:      /* NB: can't use last_row_height here; it is input-side-dependent! */
.//JPEG/jdcoefct.cpp:511:      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
.//JPEG/jdcoefct.cpp:512:      if (block_rows == 0) block_rows = compptr->v_samp_factor;
.//JPEG/jdcoefct.cpp:517:    if (cinfo->output_iMCU_row > 0) {
.//JPEG/jdcoefct.cpp:518:      access_rows += compptr->v_samp_factor; /* prior iMCU row too */
.//JPEG/jdcoefct.cpp:519:      buffer = (*cinfo->mem->access_virt_barray)
.//JPEG/jdcoefct.cpp:520:	((j_common_ptr) cinfo, coef->whole_image[ci],
.//JPEG/jdcoefct.cpp:521:	 (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,
.//JPEG/jdcoefct.cpp:523:      buffer += compptr->v_samp_factor;	/* point to current iMCU row */
.//JPEG/jdcoefct.cpp:526:      buffer = (*cinfo->mem->access_virt_barray)
.//JPEG/jdcoefct.cpp:527:	((j_common_ptr) cinfo, coef->whole_image[ci],
.//JPEG/jdcoefct.cpp:531:    /* Fetch component-dependent info */
.//JPEG/jdcoefct.cpp:532:    coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);
.//JPEG/jdcoefct.cpp:533:    quanttbl = compptr->quant_table;
.//JPEG/jdcoefct.cpp:534:    Q00 = quanttbl->quantval[0];
.//JPEG/jdcoefct.cpp:535:    Q01 = quanttbl->quantval[Q01_POS];
.//JPEG/jdcoefct.cpp:536:    Q10 = quanttbl->quantval[Q10_POS];
.//JPEG/jdcoefct.cpp:537:    Q20 = quanttbl->quantval[Q20_POS];
.//JPEG/jdcoefct.cpp:538:    Q11 = quanttbl->quantval[Q11_POS];
.//JPEG/jdcoefct.cpp:539:    Q02 = quanttbl->quantval[Q02_POS];
.//JPEG/jdcoefct.cpp:540:    inverse_DCT = cinfo->idct->inverse_DCT[ci];
.//JPEG/jdcoefct.cpp:548:	prev_block_row = buffer[block_row-1];
.//JPEG/jdcoefct.cpp:549:      if (last_row && block_row == block_rows-1)
.//JPEG/jdcoefct.cpp:553:      /* We fetch the surrounding DC values using a sliding-register approach.
.//JPEG/jdcoefct.cpp:560:      last_block_column = compptr->width_in_blocks - 1;
.//JPEG/jdcoefct.cpp:576:	  num = 36 * Q00 * (DC4 - DC6);
.//JPEG/jdcoefct.cpp:580:	      pred = (1<<Al)-1;
.//JPEG/jdcoefct.cpp:582:	    pred = (int) (((Q01<<7) - num) / (Q01<<8));
.//JPEG/jdcoefct.cpp:584:	      pred = (1<<Al)-1;
.//JPEG/jdcoefct.cpp:585:	    pred = -pred;
.//JPEG/jdcoefct.cpp:591:	  num = 36 * Q00 * (DC2 - DC8);
.//JPEG/jdcoefct.cpp:595:	      pred = (1<<Al)-1;
.//JPEG/jdcoefct.cpp:597:	    pred = (int) (((Q10<<7) - num) / (Q10<<8));
.//JPEG/jdcoefct.cpp:599:	      pred = (1<<Al)-1;
.//JPEG/jdcoefct.cpp:600:	    pred = -pred;
.//JPEG/jdcoefct.cpp:606:	  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);
.//JPEG/jdcoefct.cpp:610:	      pred = (1<<Al)-1;
.//JPEG/jdcoefct.cpp:612:	    pred = (int) (((Q20<<7) - num) / (Q20<<8));
.//JPEG/jdcoefct.cpp:614:	      pred = (1<<Al)-1;
.//JPEG/jdcoefct.cpp:615:	    pred = -pred;
.//JPEG/jdcoefct.cpp:621:	  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);
.//JPEG/jdcoefct.cpp:625:	      pred = (1<<Al)-1;
.//JPEG/jdcoefct.cpp:627:	    pred = (int) (((Q11<<7) - num) / (Q11<<8));
.//JPEG/jdcoefct.cpp:629:	      pred = (1<<Al)-1;
.//JPEG/jdcoefct.cpp:630:	    pred = -pred;
.//JPEG/jdcoefct.cpp:636:	  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);
.//JPEG/jdcoefct.cpp:640:	      pred = (1<<Al)-1;
.//JPEG/jdcoefct.cpp:642:	    pred = (int) (((Q02<<7) - num) / (Q02<<8));
.//JPEG/jdcoefct.cpp:644:	      pred = (1<<Al)-1;
.//JPEG/jdcoefct.cpp:645:	    pred = -pred;
.//JPEG/jdcoefct.cpp:657:	output_col += compptr->DCT_scaled_size;
.//JPEG/jdcoefct.cpp:659:      output_ptr += compptr->DCT_scaled_size;
.//JPEG/jdcoefct.cpp:663:  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
.//JPEG/jdcoefct.cpp:681:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdcoefct.cpp:683:  cinfo->coef = (struct jpeg_d_coef_controller *) coef;
.//JPEG/jdcoefct.cpp:684:  coef->pub.start_input_pass = start_input_pass;
.//JPEG/jdcoefct.cpp:685:  coef->pub.start_output_pass = start_output_pass;
.//JPEG/jdcoefct.cpp:687:  coef->coef_bits_latch = NULL;
.//JPEG/jdcoefct.cpp:693:    /* Allocate a full-image virtual array for each component, */
.//JPEG/jdcoefct.cpp:695:    /* Note we ask for a pre-zeroed array. */
.//JPEG/jdcoefct.cpp:699:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdcoefct.cpp:701:      access_rows = compptr->v_samp_factor;
.//JPEG/jdcoefct.cpp:704:      if (cinfo->progressive_mode)
.//JPEG/jdcoefct.cpp:707:      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
.//JPEG/jdcoefct.cpp:709:	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
.//JPEG/jdcoefct.cpp:710:				(long) compptr->h_samp_factor),
.//JPEG/jdcoefct.cpp:711:	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
.//JPEG/jdcoefct.cpp:712:				(long) compptr->v_samp_factor),
.//JPEG/jdcoefct.cpp:715:    coef->pub.consume_data = consume_data;
.//JPEG/jdcoefct.cpp:716:    coef->pub.decompress_data = decompress_data;
.//JPEG/jdcoefct.cpp:717:    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
.//JPEG/jdcoefct.cpp:722:    /* We only need a single-MCU buffer. */
.//JPEG/jdcoefct.cpp:727:      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdcoefct.cpp:730:      coef->MCU_buffer[i] = buffer + i;
.//JPEG/jdcoefct.cpp:732:    coef->pub.consume_data = dummy_consume_data;
.//JPEG/jdcoefct.cpp:733:    coef->pub.decompress_data = decompress_onepass;
.//JPEG/jdcoefct.cpp:734:    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
.//JPEG/jdcolor.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jdcolor.cpp:21:  /* Private state for YCC->RGB conversion */
.//JPEG/jdcolor.cpp:31:/**************** YCbCr -> RGB conversion: most common case **************/
.//JPEG/jdcolor.cpp:34: * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
.//JPEG/jdcolor.cpp:35: * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
.//JPEG/jdcolor.cpp:38: *	G = Y - 0.34414 * Cb - 0.71414 * Cr
.//JPEG/jdcolor.cpp:41: * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
.//JPEG/jdcolor.cpp:43: * To avoid floating-point arithmetic, we represent the fractional constants
.//JPEG/jdcolor.cpp:51: * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
.//JPEG/jdcolor.cpp:52: * for 12-bit samples it is still acceptable.  It's not very reasonable for
.//JPEG/jdcolor.cpp:53: * 16-bit samples, but if you want lossless storage you shouldn't be changing
.//JPEG/jdcolor.cpp:60:#define SCALEBITS	16	/* speediest right-shift on some machines */
.//JPEG/jdcolor.cpp:61:#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
.//JPEG/jdcolor.cpp:66: * Initialize tables for YCC->RGB colorspace conversion.
.//JPEG/jdcolor.cpp:72:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//JPEG/jdcolor.cpp:77:  cconvert->Cr_r_tab = (int *)
.//JPEG/jdcolor.cpp:78:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdcolor.cpp:80:  cconvert->Cb_b_tab = (int *)
.//JPEG/jdcolor.cpp:81:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdcolor.cpp:83:  cconvert->Cr_g_tab = (INT32 *)
.//JPEG/jdcolor.cpp:84:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdcolor.cpp:86:  cconvert->Cb_g_tab = (INT32 *)
.//JPEG/jdcolor.cpp:87:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdcolor.cpp:90:  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
.//JPEG/jdcolor.cpp:92:    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
.//JPEG/jdcolor.cpp:94:    cconvert->Cr_r_tab[i] = (int)
.//JPEG/jdcolor.cpp:97:    cconvert->Cb_b_tab[i] = (int)
.//JPEG/jdcolor.cpp:99:    /* Cr=>G value is scaled-up -0.71414 * x */
.//JPEG/jdcolor.cpp:100:    cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;
.//JPEG/jdcolor.cpp:101:    /* Cb=>G value is scaled-up -0.34414 * x */
.//JPEG/jdcolor.cpp:103:    cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
.//JPEG/jdcolor.cpp:111: * Note that we change from noninterleaved, one-plane-per-component format
.//JPEG/jdcolor.cpp:112: * to interleaved-pixel format.  The output buffer is therefore three times
.//JPEG/jdcolor.cpp:124:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//JPEG/jdcolor.cpp:129:  JDIMENSION num_cols = cinfo->output_width;
.//JPEG/jdcolor.cpp:131:  register JSAMPLE * range_limit = cinfo->sample_range_limit;
.//JPEG/jdcolor.cpp:132:  register int * Crrtab = cconvert->Cr_r_tab;
.//JPEG/jdcolor.cpp:133:  register int * Cbbtab = cconvert->Cb_b_tab;
.//JPEG/jdcolor.cpp:134:  register INT32 * Crgtab = cconvert->Cr_g_tab;
.//JPEG/jdcolor.cpp:135:  register INT32 * Cbgtab = cconvert->Cb_g_tab;
.//JPEG/jdcolor.cpp:138:  while (--num_rows >= 0) {
.//JPEG/jdcolor.cpp:148:      /* Range-limiting is essential due to noise introduced by DCT losses. */
.//JPEG/jdcolor.cpp:160:/**************** Cases other than YCbCr -> RGB **************/
.//JPEG/jdcolor.cpp:165: * converting from separate-planes to interleaved representation.
.//JPEG/jdcolor.cpp:175:  register int num_components = cinfo->num_components;
.//JPEG/jdcolor.cpp:176:  JDIMENSION num_cols = cinfo->output_width;
.//JPEG/jdcolor.cpp:179:  while (--num_rows >= 0) {
.//JPEG/jdcolor.cpp:183:      for (count = num_cols; count > 0; count--) {
.//JPEG/jdcolor.cpp:196: * This also works for YCbCr -> grayscale conversion, in which
.//JPEG/jdcolor.cpp:206:		    num_rows, cinfo->output_width);
.//JPEG/jdcolor.cpp:223:  JDIMENSION num_cols = cinfo->output_width;
.//JPEG/jdcolor.cpp:225:  while (--num_rows >= 0) {
.//JPEG/jdcolor.cpp:238: * Adobe-style YCCK->CMYK conversion.
.//JPEG/jdcolor.cpp:239: * We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
.//JPEG/jdcolor.cpp:249:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//JPEG/jdcolor.cpp:254:  JDIMENSION num_cols = cinfo->output_width;
.//JPEG/jdcolor.cpp:256:  register JSAMPLE * range_limit = cinfo->sample_range_limit;
.//JPEG/jdcolor.cpp:257:  register int * Crrtab = cconvert->Cr_r_tab;
.//JPEG/jdcolor.cpp:258:  register int * Cbbtab = cconvert->Cb_b_tab;
.//JPEG/jdcolor.cpp:259:  register INT32 * Crgtab = cconvert->Cr_g_tab;
.//JPEG/jdcolor.cpp:260:  register INT32 * Cbgtab = cconvert->Cb_g_tab;
.//JPEG/jdcolor.cpp:263:  while (--num_rows >= 0) {
.//JPEG/jdcolor.cpp:274:      /* Range-limiting is essential due to noise introduced by DCT losses. */
.//JPEG/jdcolor.cpp:275:      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
.//JPEG/jdcolor.cpp:276:      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
.//JPEG/jdcolor.cpp:279:      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];	/* blue */
.//JPEG/jdcolor.cpp:310:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdcolor.cpp:312:  cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
.//JPEG/jdcolor.cpp:313:  cconvert->pub.start_pass = start_pass_dcolor;
.//JPEG/jdcolor.cpp:316:  switch (cinfo->jpeg_color_space) {
.//JPEG/jdcolor.cpp:318:    if (cinfo->num_components != 1)
.//JPEG/jdcolor.cpp:324:    if (cinfo->num_components != 3)
.//JPEG/jdcolor.cpp:330:    if (cinfo->num_components != 4)
.//JPEG/jdcolor.cpp:335:    if (cinfo->num_components < 1)
.//JPEG/jdcolor.cpp:345:  switch (cinfo->out_color_space) {
.//JPEG/jdcolor.cpp:347:    cinfo->out_color_components = 1;
.//JPEG/jdcolor.cpp:348:    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
.//JPEG/jdcolor.cpp:349:	cinfo->jpeg_color_space == JCS_YCbCr) {
.//JPEG/jdcolor.cpp:350:      cconvert->pub.color_convert = grayscale_convert;
.//JPEG/jdcolor.cpp:351:      /* For color->grayscale conversion, only the Y (0) component is needed */
.//JPEG/jdcolor.cpp:352:      for (ci = 1; ci < cinfo->num_components; ci++)
.//JPEG/jdcolor.cpp:353:	cinfo->comp_info[ci].component_needed = FALSE;
.//JPEG/jdcolor.cpp:359:    cinfo->out_color_components = RGB_PIXELSIZE;
.//JPEG/jdcolor.cpp:360:    if (cinfo->jpeg_color_space == JCS_YCbCr) {
.//JPEG/jdcolor.cpp:361:      cconvert->pub.color_convert = ycc_rgb_convert;
.//JPEG/jdcolor.cpp:363:    } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {
.//JPEG/jdcolor.cpp:364:      cconvert->pub.color_convert = gray_rgb_convert;
.//JPEG/jdcolor.cpp:365:    } else if (cinfo->jpeg_color_space == JCS_RGB && RGB_PIXELSIZE == 3) {
.//JPEG/jdcolor.cpp:366:      cconvert->pub.color_convert = null_convert;
.//JPEG/jdcolor.cpp:372:    cinfo->out_color_components = 4;
.//JPEG/jdcolor.cpp:373:    if (cinfo->jpeg_color_space == JCS_YCCK) {
.//JPEG/jdcolor.cpp:374:      cconvert->pub.color_convert = ycck_cmyk_convert;
.//JPEG/jdcolor.cpp:376:    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
.//JPEG/jdcolor.cpp:377:      cconvert->pub.color_convert = null_convert;
.//JPEG/jdcolor.cpp:384:    if (cinfo->out_color_space == cinfo->jpeg_color_space) {
.//JPEG/jdcolor.cpp:385:      cinfo->out_color_components = cinfo->num_components;
.//JPEG/jdcolor.cpp:386:      cconvert->pub.color_convert = null_convert;
.//JPEG/jdcolor.cpp:387:    } else			/* unsupported non-null conversion */
.//JPEG/jdcolor.cpp:392:  if (cinfo->quantize_colors)
.//JPEG/jdcolor.cpp:393:    cinfo->output_components = 1; /* single colormapped output component */
.//JPEG/jdcolor.cpp:395:    cinfo->output_components = cinfo->out_color_components;
.//JPEG/jdct.h:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jdct.h:12: * machine-dependent tuning (e.g., assembly coding).
.//JPEG/jdct.h:18: * the DCT is to be performed in-place in that buffer.  Type DCTELEM is int
.//JPEG/jdct.h:19: * for 8-bit samples, INT32 for 12-bit samples.  (NOTE: Floating-point DCT
.//JPEG/jdct.h:21: * The DCT inputs are expected to be signed (range +-CENTERJSAMPLE).
.//JPEG/jdct.h:23: * have a range of +-8K for 8-bit data, +-128K for 12-bit data.  This
.//JPEG/jdct.h:25: * work in floating-point ones.
.//JPEG/jdct.h:43: * pointed to by compptr->dct_table.  The output data is to be placed into the
.//JPEG/jdct.h:68: * Each IDCT routine is responsible for range-limiting its results and
.//JPEG/jdct.h:71: * range-limiting step is required.  We use a mask-and-table-lookup method
.//JPEG/jdct.h:76:#define IDCT_range_limit(cinfo)  ((cinfo)->sample_range_limit + CENTERJSAMPLE)
.//JPEG/jdct.h:81:/* Short forms of external names for systems with brain-damaged linkers. */
.//JPEG/jdct.h:122: * Macros for handling fixed-point arithmetic; these are used by many
.//JPEG/jdct.h:136: * thus causing a lot of useless floating-point operations at run time.
.//JPEG/jdct.h:146:#define DESCALE(x,n)  RIGHT_SHIFT((x) + (ONE << ((n)-1)), n)
.//JPEG/jdct.h:150: * 16 bits wide, so that a 16x16->32 bit multiply can be used instead of a
.//JPEG/jdct.h:152: * Unfortunately there is no way to specify a 16x16->32 multiply portably
.//JPEG/jddctmgr.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jddctmgr.cpp:8: * This file contains the inverse-DCT management logic.
.//JPEG/jddctmgr.cpp:28: * decode files that reuse Q-table slots.)
.//JPEG/jddctmgr.cpp:29: * When we are ready to make an output pass, the saved Q-table is converted
.//JPEG/jddctmgr.cpp:31: * The multiplier table contents are IDCT-method-dependent.  To support
.//JPEG/jddctmgr.cpp:34: * In buffered-image mode, the first output pass may occur before any data
.//JPEG/jddctmgr.cpp:35: * has been seen for some components, and thus before their Q-tables have
.//JPEG/jddctmgr.cpp:47:   * is currently set up for, or -1 if it's not yet set up.
.//JPEG/jddctmgr.cpp:49:   * per-component comp_info structures.
.//JPEG/jddctmgr.cpp:70:/* The current scaled-IDCT routines require ISLOW-style multiplier tables,
.//JPEG/jddctmgr.cpp:91:  my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
.//JPEG/jddctmgr.cpp:98:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jddctmgr.cpp:101:    switch (compptr->DCT_scaled_size) {
.//JPEG/jddctmgr.cpp:105:      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
.//JPEG/jddctmgr.cpp:109:      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
.//JPEG/jddctmgr.cpp:113:      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
.//JPEG/jddctmgr.cpp:117:      switch (cinfo->dct_method) {
.//JPEG/jddctmgr.cpp:142:      ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->DCT_scaled_size);
.//JPEG/jddctmgr.cpp:145:    idct->pub.inverse_DCT[ci] = method_ptr;
.//JPEG/jddctmgr.cpp:150:     * multiplier table all-zero; we'll be reading zeroes from the
.//JPEG/jddctmgr.cpp:153:    if (! compptr->component_needed || idct->cur_method[ci] == method)
.//JPEG/jddctmgr.cpp:155:    qtbl = compptr->quant_table;
.//JPEG/jddctmgr.cpp:158:    idct->cur_method[ci] = method;
.//JPEG/jddctmgr.cpp:166:	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
.//JPEG/jddctmgr.cpp:168:	  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];
.//JPEG/jddctmgr.cpp:183:	IFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;
.//JPEG/jddctmgr.cpp:200:	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
.//JPEG/jddctmgr.cpp:202:		    CONST_BITS-IFAST_SCALE_BITS);
.//JPEG/jddctmgr.cpp:215:	FLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;
.//JPEG/jddctmgr.cpp:226:	      ((double) qtbl->quantval[i] *
.//JPEG/jddctmgr.cpp:254:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jddctmgr.cpp:256:  cinfo->idct = (struct jpeg_inverse_dct *) idct;
.//JPEG/jddctmgr.cpp:257:  idct->pub.start_pass = start_pass;
.//JPEG/jddctmgr.cpp:259:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jddctmgr.cpp:261:    /* Allocate and pre-zero a multiplier table for each component */
.//JPEG/jddctmgr.cpp:262:    compptr->dct_table =
.//JPEG/jddctmgr.cpp:263:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jddctmgr.cpp:265:    MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
.//JPEG/jddctmgr.cpp:267:    idct->cur_method[ci] = -1;
.//JPEG/jdhuff.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jdhuff.cpp:82: * Initialize for a Huffman-compressed scan.
.//JPEG/jdhuff.cpp:88:  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//JPEG/jdhuff.cpp:96:  if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
.//JPEG/jdhuff.cpp:97:      cinfo->Ah != 0 || cinfo->Al != 0)
.//JPEG/jdhuff.cpp:100:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jdhuff.cpp:101:    compptr = cinfo->cur_comp_info[ci];
.//JPEG/jdhuff.cpp:102:    dctbl = compptr->dc_tbl_no;
.//JPEG/jdhuff.cpp:103:    actbl = compptr->ac_tbl_no;
.//JPEG/jdhuff.cpp:107:			    & entropy->dc_derived_tbls[dctbl]);
.//JPEG/jdhuff.cpp:109:			    & entropy->ac_derived_tbls[actbl]);
.//JPEG/jdhuff.cpp:111:    entropy->saved.last_dc_val[ci] = 0;
.//JPEG/jdhuff.cpp:115:  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//JPEG/jdhuff.cpp:116:    ci = cinfo->MCU_membership[blkn];
.//JPEG/jdhuff.cpp:117:    compptr = cinfo->cur_comp_info[ci];
.//JPEG/jdhuff.cpp:119:    entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
.//JPEG/jdhuff.cpp:120:    entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
.//JPEG/jdhuff.cpp:122:    if (compptr->component_needed) {
.//JPEG/jdhuff.cpp:123:      entropy->dc_needed[blkn] = TRUE;
.//JPEG/jdhuff.cpp:124:      /* we don't need the ACs if producing a 1/8th-size image */
.//JPEG/jdhuff.cpp:125:      entropy->ac_needed[blkn] = (compptr->DCT_scaled_size > 1);
.//JPEG/jdhuff.cpp:127:      entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
.//JPEG/jdhuff.cpp:132:  entropy->bitstate.bits_left = 0;
.//JPEG/jdhuff.cpp:133:  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
.//JPEG/jdhuff.cpp:134:  entropy->pub.insufficient_data = FALSE;
.//JPEG/jdhuff.cpp:137:  entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jdhuff.cpp:160:  /* Note that huffsize[] and huffcode[] are filled in code-length order,
.//JPEG/jdhuff.cpp:161:   * paralleling the order of the symbols themselves in htbl->huffval[].
.//JPEG/jdhuff.cpp:168:    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
.//JPEG/jdhuff.cpp:175:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdhuff.cpp:178:  dtbl->pub = htbl;		/* fill in back link */
.//JPEG/jdhuff.cpp:184:    i = (int) htbl->bits[l];
.//JPEG/jdhuff.cpp:187:    while (i--)
.//JPEG/jdhuff.cpp:213:  /* Figure F.15: generate decoding tables for bit-sequential decoding */
.//JPEG/jdhuff.cpp:217:    if (htbl->bits[l]) {
.//JPEG/jdhuff.cpp:221:      dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
.//JPEG/jdhuff.cpp:222:      p += htbl->bits[l];
.//JPEG/jdhuff.cpp:223:      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
.//JPEG/jdhuff.cpp:225:      dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
.//JPEG/jdhuff.cpp:228:  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
.//JPEG/jdhuff.cpp:237:  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
.//JPEG/jdhuff.cpp:241:    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
.//JPEG/jdhuff.cpp:243:      /* Generate left-justified code followed by all possible bit sequences */
.//JPEG/jdhuff.cpp:244:      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
.//JPEG/jdhuff.cpp:245:      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
.//JPEG/jdhuff.cpp:246:	dtbl->look_nbits[lookbits] = l;
.//JPEG/jdhuff.cpp:247:	dtbl->look_sym[lookbits] = htbl->huffval[p];
.//JPEG/jdhuff.cpp:261:      int sym = htbl->huffval[i];
.//JPEG/jdhuff.cpp:270: * Out-of-line code for bit fetching (shared with jdphuff.c).
.//JPEG/jdhuff.cpp:275: * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width
.//JPEG/jdhuff.cpp:277: * buffer could be used.)  However, on some machines 32-bit shifts are
.//JPEG/jdhuff.cpp:287:#define MIN_GET_BITS  (BIT_BUF_SIZE-7)
.//JPEG/jdhuff.cpp:298:  register const JOCTET * next_input_byte = state->next_input_byte;
.//JPEG/jdhuff.cpp:299:  register size_t bytes_in_buffer = state->bytes_in_buffer;
.//JPEG/jdhuff.cpp:300:  j_decompress_ptr cinfo = state->cinfo;
.//JPEG/jdhuff.cpp:306:  if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
.//JPEG/jdhuff.cpp:312:	if (! (*cinfo->src->fill_input_buffer) (cinfo))
.//JPEG/jdhuff.cpp:314:	next_input_byte = cinfo->src->next_input_byte;
.//JPEG/jdhuff.cpp:315:	bytes_in_buffer = cinfo->src->bytes_in_buffer;
.//JPEG/jdhuff.cpp:317:      bytes_in_buffer--;
.//JPEG/jdhuff.cpp:329:	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
.//JPEG/jdhuff.cpp:331:	    next_input_byte = cinfo->src->next_input_byte;
.//JPEG/jdhuff.cpp:332:	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
.//JPEG/jdhuff.cpp:334:	  bytes_in_buffer--;
.//JPEG/jdhuff.cpp:350:	  cinfo->unread_marker = c;
.//JPEG/jdhuff.cpp:367:      /* Uh-oh.  Report corrupted data to user and stuff zeroes into
.//JPEG/jdhuff.cpp:372:      if (! cinfo->entropy->insufficient_data) {
.//JPEG/jdhuff.cpp:374:	cinfo->entropy->insufficient_data = TRUE;
.//JPEG/jdhuff.cpp:377:      get_buffer <<= MIN_GET_BITS - bits_left;
.//JPEG/jdhuff.cpp:383:  state->next_input_byte = next_input_byte;
.//JPEG/jdhuff.cpp:384:  state->bytes_in_buffer = bytes_in_buffer;
.//JPEG/jdhuff.cpp:385:  state->get_buffer = get_buffer;
.//JPEG/jdhuff.cpp:386:  state->bits_left = bits_left;
.//JPEG/jdhuff.cpp:393: * Out-of-line code for Huffman code decoding.
.//JPEG/jdhuff.cpp:408:  CHECK_BIT_BUFFER(*state, l, return -1);
.//JPEG/jdhuff.cpp:414:  while (code > htbl->maxcode[l]) {
.//JPEG/jdhuff.cpp:416:    CHECK_BIT_BUFFER(*state, 1, return -1);
.//JPEG/jdhuff.cpp:422:  state->get_buffer = get_buffer;
.//JPEG/jdhuff.cpp:423:  state->bits_left = bits_left;
.//JPEG/jdhuff.cpp:428:    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
.//JPEG/jdhuff.cpp:432:  return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
.//JPEG/jdhuff.cpp:443:#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))
.//JPEG/jdhuff.cpp:449:static const int extend_test[16] =   /* entry n is 2**(n-1) */
.//JPEG/jdhuff.cpp:453:static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
.//JPEG/jdhuff.cpp:454:  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
.//JPEG/jdhuff.cpp:455:    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
.//JPEG/jdhuff.cpp:456:    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
.//JPEG/jdhuff.cpp:457:    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };
.//JPEG/jdhuff.cpp:470:  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//JPEG/jdhuff.cpp:475:  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
.//JPEG/jdhuff.cpp:476:  entropy->bitstate.bits_left = 0;
.//JPEG/jdhuff.cpp:479:  if (! (*cinfo->marker->read_restart_marker) (cinfo))
.//JPEG/jdhuff.cpp:482:  /* Re-initialize DC predictions to 0 */
.//JPEG/jdhuff.cpp:483:  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
.//JPEG/jdhuff.cpp:484:    entropy->saved.last_dc_val[ci] = 0;
.//JPEG/jdhuff.cpp:487:  entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jdhuff.cpp:489:  /* Reset out-of-data flag, unless read_restart_marker left us smack up
.//JPEG/jdhuff.cpp:494:  if (cinfo->unread_marker == 0)
.//JPEG/jdhuff.cpp:495:    entropy->pub.insufficient_data = FALSE;
.//JPEG/jdhuff.cpp:502: * Decode and return one MCU's worth of Huffman-compressed coefficients.
.//JPEG/jdhuff.cpp:513: * this module, since we'll just re-assign them on the next call.)
.//JPEG/jdhuff.cpp:519:  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//JPEG/jdhuff.cpp:525:  if (cinfo->restart_interval) {
.//JPEG/jdhuff.cpp:526:    if (entropy->restarts_to_go == 0)
.//JPEG/jdhuff.cpp:534:  if (! entropy->pub.insufficient_data) {
.//JPEG/jdhuff.cpp:537:    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
.//JPEG/jdhuff.cpp:538:    ASSIGN_STATE(state, entropy->saved);
.//JPEG/jdhuff.cpp:542:    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//JPEG/jdhuff.cpp:544:      d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
.//JPEG/jdhuff.cpp:545:      d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
.//JPEG/jdhuff.cpp:558:      if (entropy->dc_needed[blkn]) {
.//JPEG/jdhuff.cpp:560:	int ci = cinfo->MCU_membership[blkn];
.//JPEG/jdhuff.cpp:567:      if (entropy->ac_needed[blkn]) {
.//JPEG/jdhuff.cpp:619:    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
.//JPEG/jdhuff.cpp:620:    ASSIGN_STATE(entropy->saved, state);
.//JPEG/jdhuff.cpp:623:  /* Account for restart interval (no-op if not using restarts) */
.//JPEG/jdhuff.cpp:624:  entropy->restarts_to_go--;
.//JPEG/jdhuff.cpp:641:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdhuff.cpp:643:  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
.//JPEG/jdhuff.cpp:644:  entropy->pub.start_pass = start_pass_huff_decoder;
.//JPEG/jdhuff.cpp:645:  entropy->pub.decode_mcu = decode_mcu;
.//JPEG/jdhuff.cpp:649:    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
.//JPEG/jdhuff.h:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jdhuff.h:13:/* Short forms of external names for systems with brain-damaged linkers. */
.//JPEG/jdhuff.h:28:  INT32 maxcode[18];		/* largest code of length k (-1 if none) */
.//JPEG/jdhuff.h:55: * Fetching the next N bits from the input stream is a time-critical operation
.//JPEG/jdhuff.h:57: * macros and out-of-line subroutines.  Note that N (the number of bits
.//JPEG/jdhuff.h:61: * If get_buffer already contains enough bits, they are fetched in-line
.//JPEG/jdhuff.h:68: * at least the requested number of bits --- dummy zeroes are inserted if
.//JPEG/jdhuff.h:72:typedef INT32 bit_buf_type;	/* type of bit-extraction buffer */
.//JPEG/jdhuff.h:79: * because not all machines measure sizeof in 8-bit bytes.
.//JPEG/jdhuff.h:83:  bit_buf_type get_buffer;	/* current bit-extraction buffer */
.//JPEG/jdhuff.h:92:  /* Bit input buffer --- note these values are kept in register variables,
.//JPEG/jdhuff.h:95:  bit_buf_type get_buffer;	/* current bit-extraction buffer */
.//JPEG/jdhuff.h:109:	br_state.next_input_byte = cinfop->src->next_input_byte; \
.//JPEG/jdhuff.h:110:	br_state.bytes_in_buffer = cinfop->src->bytes_in_buffer; \
.//JPEG/jdhuff.h:115:	cinfop->src->next_input_byte = br_state.next_input_byte; \
.//JPEG/jdhuff.h:116:	cinfop->src->bytes_in_buffer = br_state.bytes_in_buffer; \
.//JPEG/jdhuff.h:121: * These macros provide the in-line portion of bit fetching.
.//JPEG/jdhuff.h:145:	(((int) (get_buffer >> (bits_left -= (nbits)))) & ((1<<(nbits))-1))
.//JPEG/jdhuff.h:148:	(((int) (get_buffer >> (bits_left -  (nbits)))) & ((1<<(nbits))-1))
.//JPEG/jdhuff.h:151:	(bits_left -= (nbits))
.//JPEG/jdhuff.h:160: * Code for extracting next Huffman-coded symbol from input bit stream.
.//JPEG/jdhuff.h:161: * Again, this is time-critical and we make the main paths be macros.
.//JPEG/jdhuff.h:173: * 3. jpeg_huff_decode returns -1 if forced to suspend.
.//JPEG/jdhuff.h:186:  if ((nb = htbl->look_nbits[look]) != 0) { \
.//JPEG/jdhuff.h:188:    result = htbl->look_sym[look]; \
.//JPEG/jdhuff.h:198:/* Out-of-line case for Huffman code fetching */
.//JPEG/jdinput.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jdinput.cpp:46:  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
.//JPEG/jdinput.cpp:47:      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
.//JPEG/jdinput.cpp:50:  /* For now, precision must match compiled-in value... */
.//JPEG/jdinput.cpp:51:  if (cinfo->data_precision != BITS_IN_JSAMPLE)
.//JPEG/jdinput.cpp:52:    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
.//JPEG/jdinput.cpp:55:  if (cinfo->num_components > MAX_COMPONENTS)
.//JPEG/jdinput.cpp:56:    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
.//JPEG/jdinput.cpp:60:  cinfo->max_h_samp_factor = 1;
.//JPEG/jdinput.cpp:61:  cinfo->max_v_samp_factor = 1;
.//JPEG/jdinput.cpp:62:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdinput.cpp:64:    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
.//JPEG/jdinput.cpp:65:	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
.//JPEG/jdinput.cpp:67:    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
.//JPEG/jdinput.cpp:68:				   compptr->h_samp_factor);
.//JPEG/jdinput.cpp:69:    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
.//JPEG/jdinput.cpp:70:				   compptr->v_samp_factor);
.//JPEG/jdinput.cpp:77:  cinfo->min_DCT_scaled_size = DCTSIZE;
.//JPEG/jdinput.cpp:80:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdinput.cpp:82:    compptr->DCT_scaled_size = DCTSIZE;
.//JPEG/jdinput.cpp:84:    compptr->width_in_blocks = (JDIMENSION)
.//JPEG/jdinput.cpp:85:      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
.//JPEG/jdinput.cpp:86:		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
.//JPEG/jdinput.cpp:87:    compptr->height_in_blocks = (JDIMENSION)
.//JPEG/jdinput.cpp:88:      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
.//JPEG/jdinput.cpp:89:		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
.//JPEG/jdinput.cpp:95:    compptr->downsampled_width = (JDIMENSION)
.//JPEG/jdinput.cpp:96:      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
.//JPEG/jdinput.cpp:97:		    (long) cinfo->max_h_samp_factor);
.//JPEG/jdinput.cpp:98:    compptr->downsampled_height = (JDIMENSION)
.//JPEG/jdinput.cpp:99:      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
.//JPEG/jdinput.cpp:100:		    (long) cinfo->max_v_samp_factor);
.//JPEG/jdinput.cpp:102:    compptr->component_needed = TRUE;
.//JPEG/jdinput.cpp:104:    compptr->quant_table = NULL;
.//JPEG/jdinput.cpp:108:  cinfo->total_iMCU_rows = (JDIMENSION)
.//JPEG/jdinput.cpp:109:    jdiv_round_up((long) cinfo->image_height,
.//JPEG/jdinput.cpp:110:		  (long) (cinfo->max_v_samp_factor*DCTSIZE));
.//JPEG/jdinput.cpp:113:  if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
.//JPEG/jdinput.cpp:114:    cinfo->inputctl->has_multiple_scans = TRUE;
.//JPEG/jdinput.cpp:116:    cinfo->inputctl->has_multiple_scans = FALSE;
.//JPEG/jdinput.cpp:123:/* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
.//JPEG/jdinput.cpp:128:  if (cinfo->comps_in_scan == 1) {
.//JPEG/jdinput.cpp:130:    /* Noninterleaved (single-component) scan */
.//JPEG/jdinput.cpp:131:    compptr = cinfo->cur_comp_info[0];
.//JPEG/jdinput.cpp:134:    cinfo->MCUs_per_row = compptr->width_in_blocks;
.//JPEG/jdinput.cpp:135:    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
.//JPEG/jdinput.cpp:138:    compptr->MCU_width = 1;
.//JPEG/jdinput.cpp:139:    compptr->MCU_height = 1;
.//JPEG/jdinput.cpp:140:    compptr->MCU_blocks = 1;
.//JPEG/jdinput.cpp:141:    compptr->MCU_sample_width = compptr->DCT_scaled_size;
.//JPEG/jdinput.cpp:142:    compptr->last_col_width = 1;
.//JPEG/jdinput.cpp:146:    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
.//JPEG/jdinput.cpp:147:    if (tmp == 0) tmp = compptr->v_samp_factor;
.//JPEG/jdinput.cpp:148:    compptr->last_row_height = tmp;
.//JPEG/jdinput.cpp:151:    cinfo->blocks_in_MCU = 1;
.//JPEG/jdinput.cpp:152:    cinfo->MCU_membership[0] = 0;
.//JPEG/jdinput.cpp:156:    /* Interleaved (multi-component) scan */
.//JPEG/jdinput.cpp:157:    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
.//JPEG/jdinput.cpp:158:      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
.//JPEG/jdinput.cpp:162:    cinfo->MCUs_per_row = (JDIMENSION)
.//JPEG/jdinput.cpp:163:      jdiv_round_up((long) cinfo->image_width,
.//JPEG/jdinput.cpp:164:		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
.//JPEG/jdinput.cpp:165:    cinfo->MCU_rows_in_scan = (JDIMENSION)
.//JPEG/jdinput.cpp:166:      jdiv_round_up((long) cinfo->image_height,
.//JPEG/jdinput.cpp:167:		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
.//JPEG/jdinput.cpp:169:    cinfo->blocks_in_MCU = 0;
.//JPEG/jdinput.cpp:171:    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jdinput.cpp:172:      compptr = cinfo->cur_comp_info[ci];
.//JPEG/jdinput.cpp:174:      compptr->MCU_width = compptr->h_samp_factor;
.//JPEG/jdinput.cpp:175:      compptr->MCU_height = compptr->v_samp_factor;
.//JPEG/jdinput.cpp:176:      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
.//JPEG/jdinput.cpp:177:      compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
.//JPEG/jdinput.cpp:178:      /* Figure number of non-dummy blocks in last MCU column & row */
.//JPEG/jdinput.cpp:179:      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
.//JPEG/jdinput.cpp:180:      if (tmp == 0) tmp = compptr->MCU_width;
.//JPEG/jdinput.cpp:181:      compptr->last_col_width = tmp;
.//JPEG/jdinput.cpp:182:      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
.//JPEG/jdinput.cpp:183:      if (tmp == 0) tmp = compptr->MCU_height;
.//JPEG/jdinput.cpp:184:      compptr->last_row_height = tmp;
.//JPEG/jdinput.cpp:186:      mcublks = compptr->MCU_blocks;
.//JPEG/jdinput.cpp:187:      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
.//JPEG/jdinput.cpp:189:      while (mcublks-- > 0) {
.//JPEG/jdinput.cpp:190:	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
.//JPEG/jdinput.cpp:199: * Save away a copy of the Q-table referenced by each component present
.//JPEG/jdinput.cpp:202: * In a multiple-scan JPEG file, the encoder could assign different components
.//JPEG/jdinput.cpp:203: * the same Q-table slot number, but change table definitions between scans
.//JPEG/jdinput.cpp:204: * so that each component uses a different Q-table.  (The IJG encoder is not
.//JPEG/jdinput.cpp:210: * The JPEG spec prohibits the encoder from changing the contents of a Q-table
.//JPEG/jdinput.cpp:212: * anyway, this decoder will simply use the Q-table values that were current
.//JPEG/jdinput.cpp:216: * not at the current Q-table slots.
.//JPEG/jdinput.cpp:226:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jdinput.cpp:227:    compptr = cinfo->cur_comp_info[ci];
.//JPEG/jdinput.cpp:228:    /* No work if we already saved Q-table for this component */
.//JPEG/jdinput.cpp:229:    if (compptr->quant_table != NULL)
.//JPEG/jdinput.cpp:232:    qtblno = compptr->quant_tbl_no;
.//JPEG/jdinput.cpp:234:	cinfo->quant_tbl_ptrs[qtblno] == NULL)
.//JPEG/jdinput.cpp:238:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdinput.cpp:240:    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
.//JPEG/jdinput.cpp:241:    compptr->quant_table = qtbl;
.//JPEG/jdinput.cpp:258:  (*cinfo->entropy->start_pass) (cinfo);
.//JPEG/jdinput.cpp:259:  (*cinfo->coef->start_input_pass) (cinfo);
.//JPEG/jdinput.cpp:260:  cinfo->inputctl->consume_input = cinfo->coef->consume_data;
.//JPEG/jdinput.cpp:265: * Finish up after inputting a compressed-data scan.
.//JPEG/jdinput.cpp:273:  cinfo->inputctl->consume_input = consume_markers;
.//JPEG/jdinput.cpp:278: * Read JPEG markers before, between, or after compressed-data scans.
.//JPEG/jdinput.cpp:284: * we are reading a compressed data segment or inter-segment markers.
.//JPEG/jdinput.cpp:290:  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
.//JPEG/jdinput.cpp:293:  if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
.//JPEG/jdinput.cpp:296:  val = (*cinfo->marker->read_markers) (cinfo);
.//JPEG/jdinput.cpp:300:    if (inputctl->inheaders) {	/* 1st SOS */
.//JPEG/jdinput.cpp:302:      inputctl->inheaders = FALSE;
.//JPEG/jdinput.cpp:308:      if (! inputctl->pub.has_multiple_scans)
.//JPEG/jdinput.cpp:314:    inputctl->pub.eoi_reached = TRUE;
.//JPEG/jdinput.cpp:315:    if (inputctl->inheaders) {	/* Tables-only datastream, apparently */
.//JPEG/jdinput.cpp:316:      if (cinfo->marker->saw_SOF)
.//JPEG/jdinput.cpp:322:      if (cinfo->output_scan_number > cinfo->input_scan_number)
.//JPEG/jdinput.cpp:323:	cinfo->output_scan_number = cinfo->input_scan_number;
.//JPEG/jdinput.cpp:341:  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
.//JPEG/jdinput.cpp:343:  inputctl->pub.consume_input = consume_markers;
.//JPEG/jdinput.cpp:344:  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
.//JPEG/jdinput.cpp:345:  inputctl->pub.eoi_reached = FALSE;
.//JPEG/jdinput.cpp:346:  inputctl->inheaders = TRUE;
.//JPEG/jdinput.cpp:348:  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
.//JPEG/jdinput.cpp:349:  (*cinfo->marker->reset_marker_reader) (cinfo);
.//JPEG/jdinput.cpp:350:  /* Reset progression state -- would be cleaner if entropy decoder did this */
.//JPEG/jdinput.cpp:351:  cinfo->coef_bits = NULL;
.//JPEG/jdinput.cpp:367:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//JPEG/jdinput.cpp:369:  cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
.//JPEG/jdinput.cpp:371:  inputctl->pub.consume_input = consume_markers;
.//JPEG/jdinput.cpp:372:  inputctl->pub.reset_input_controller = reset_input_controller;
.//JPEG/jdinput.cpp:373:  inputctl->pub.start_input_pass = start_input_pass;
.//JPEG/jdinput.cpp:374:  inputctl->pub.finish_input_pass = finish_input_pass;
.//JPEG/jdinput.cpp:378:  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
.//JPEG/jdinput.cpp:379:  inputctl->pub.eoi_reached = FALSE;
.//JPEG/jdinput.cpp:380:  inputctl->inheaders = TRUE;
.//JPEG/jdmainct.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jdmainct.cpp:10: * post-processor; it holds downsampled data in the JPEG colorspace.
.//JPEG/jdmainct.cpp:12: * Note that this code is bypassed in raw-data mode, since the application
.//JPEG/jdmainct.cpp:22: * In the current system design, the main buffer need never be a full-image
.//JPEG/jdmainct.cpp:23: * buffer; any full-height buffers will be found inside the coefficient or
.//JPEG/jdmainct.cpp:72: * can't be processed until we have another row group for its below-context,
.//JPEG/jdmainct.cpp:73: * and so we have to save the next-to-last group too for its above-context.)
.//JPEG/jdmainct.cpp:81: *                   M+1                          M-1
.//JPEG/jdmainct.cpp:82: * master pointer --> 0         master pointer --> 0
.//JPEG/jdmainct.cpp:85: *                   M-3                          M-3
.//JPEG/jdmainct.cpp:86: *                   M-2                           M
.//JPEG/jdmainct.cpp:87: *                   M-1                          M+1
.//JPEG/jdmainct.cpp:88: *                    M                           M-2
.//JPEG/jdmainct.cpp:89: *                   M+1                          M-1
.//JPEG/jdmainct.cpp:92: * row groups of the previous iMCU row remain un-overwritten in the workspace.
.//JPEG/jdmainct.cpp:107: * be worth providing --- if someone wants a 1/8th-size preview, they probably
.//JPEG/jdmainct.cpp:108: * want it quick and dirty, so a context-free upsampler is sufficient.
.//JPEG/jdmainct.cpp:125:  /* These are the master pointers to the funny-order pointer lists. */
.//JPEG/jdmainct.cpp:162:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//JPEG/jdmainct.cpp:164:  int M = cinfo->min_DCT_scaled_size;
.//JPEG/jdmainct.cpp:168:  /* Get top-level space for component array pointers.
.//JPEG/jdmainct.cpp:171:  main->xbuffer[0] = (JSAMPIMAGE)
.//JPEG/jdmainct.cpp:172:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmainct.cpp:173:				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
.//JPEG/jdmainct.cpp:174:  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;
.//JPEG/jdmainct.cpp:176:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdmainct.cpp:178:    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
.//JPEG/jdmainct.cpp:179:      cinfo->min_DCT_scaled_size; /* height of a row group of component */
.//JPEG/jdmainct.cpp:180:    /* Get space for pointer lists --- M+4 row groups in each list.
.//JPEG/jdmainct.cpp:184:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmainct.cpp:187:    main->xbuffer[0][ci] = xbuf;
.//JPEG/jdmainct.cpp:189:    main->xbuffer[1][ci] = xbuf;
.//JPEG/jdmainct.cpp:197: * The actual workspace is already allocated (in main->buffer),
.//JPEG/jdmainct.cpp:203:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//JPEG/jdmainct.cpp:205:  int M = cinfo->min_DCT_scaled_size;
.//JPEG/jdmainct.cpp:209:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdmainct.cpp:211:    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
.//JPEG/jdmainct.cpp:212:      cinfo->min_DCT_scaled_size; /* height of a row group of component */
.//JPEG/jdmainct.cpp:213:    xbuf0 = main->xbuffer[0][ci];
.//JPEG/jdmainct.cpp:214:    xbuf1 = main->xbuffer[1][ci];
.//JPEG/jdmainct.cpp:215:    /* First copy the workspace pointers as-is */
.//JPEG/jdmainct.cpp:216:    buf = main->buffer[ci];
.//JPEG/jdmainct.cpp:222:      xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
.//JPEG/jdmainct.cpp:223:      xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
.//JPEG/jdmainct.cpp:231:      xbuf0[i - rgroup] = xbuf0[0];
.//JPEG/jdmainct.cpp:240: * This changes the pointer list state from top-of-image to the normal state.
.//JPEG/jdmainct.cpp:243:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//JPEG/jdmainct.cpp:245:  int M = cinfo->min_DCT_scaled_size;
.//JPEG/jdmainct.cpp:249:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdmainct.cpp:251:    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
.//JPEG/jdmainct.cpp:252:      cinfo->min_DCT_scaled_size; /* height of a row group of component */
.//JPEG/jdmainct.cpp:253:    xbuf0 = main->xbuffer[0][ci];
.//JPEG/jdmainct.cpp:254:    xbuf1 = main->xbuffer[1][ci];
.//JPEG/jdmainct.cpp:256:      xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
.//JPEG/jdmainct.cpp:257:      xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
.//JPEG/jdmainct.cpp:272:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//JPEG/jdmainct.cpp:277:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdmainct.cpp:280:    iMCUheight = compptr->v_samp_factor * compptr->DCT_scaled_size;
.//JPEG/jdmainct.cpp:281:    rgroup = iMCUheight / cinfo->min_DCT_scaled_size;
.//JPEG/jdmainct.cpp:283:    rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
.//JPEG/jdmainct.cpp:289:      main->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
.//JPEG/jdmainct.cpp:294:    xbuf = main->xbuffer[main->whichptr][ci];
.//JPEG/jdmainct.cpp:296:      xbuf[rows_left + i] = xbuf[rows_left-1];
.//JPEG/jdmainct.cpp:309:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//JPEG/jdmainct.cpp:313:    if (cinfo->upsample->need_context_rows) {
.//JPEG/jdmainct.cpp:314:      main->pub.process_data = process_data_context_main;
.//JPEG/jdmainct.cpp:316:      main->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
.//JPEG/jdmainct.cpp:317:      main->context_state = CTX_PREPARE_FOR_IMCU;
.//JPEG/jdmainct.cpp:318:      main->iMCU_row_ctr = 0;
.//JPEG/jdmainct.cpp:321:      main->pub.process_data = process_data_simple_main;
.//JPEG/jdmainct.cpp:323:    main->buffer_full = FALSE;	/* Mark buffer empty */
.//JPEG/jdmainct.cpp:324:    main->rowgroup_ctr = 0;
.//JPEG/jdmainct.cpp:328:    /* For last pass of 2-pass quantization, just crank the postprocessor */
.//JPEG/jdmainct.cpp:329:    main->pub.process_data = process_data_crank_post;
.//JPEG/jdmainct.cpp:349:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//JPEG/jdmainct.cpp:353:  if (! main->buffer_full) {
.//JPEG/jdmainct.cpp:354:    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
.//JPEG/jdmainct.cpp:356:    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
.//JPEG/jdmainct.cpp:360:  rowgroups_avail = (JDIMENSION) cinfo->min_DCT_scaled_size;
.//JPEG/jdmainct.cpp:367:  (*cinfo->post->post_process_data) (cinfo, main->buffer,
.//JPEG/jdmainct.cpp:368:				     &main->rowgroup_ctr, rowgroups_avail,
.//JPEG/jdmainct.cpp:372:  if (main->rowgroup_ctr >= rowgroups_avail) {
.//JPEG/jdmainct.cpp:373:    main->buffer_full = FALSE;
.//JPEG/jdmainct.cpp:374:    main->rowgroup_ctr = 0;
.//JPEG/jdmainct.cpp:389:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//JPEG/jdmainct.cpp:392:  if (! main->buffer_full) {
.//JPEG/jdmainct.cpp:393:    if (! (*cinfo->coef->decompress_data) (cinfo,
.//JPEG/jdmainct.cpp:394:					   main->xbuffer[main->whichptr]))
.//JPEG/jdmainct.cpp:396:    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
.//JPEG/jdmainct.cpp:397:    main->iMCU_row_ctr++;	/* count rows received */
.//JPEG/jdmainct.cpp:405:  switch (main->context_state) {
.//JPEG/jdmainct.cpp:408:    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
.//JPEG/jdmainct.cpp:409:			&main->rowgroup_ctr, main->rowgroups_avail,
.//JPEG/jdmainct.cpp:411:    if (main->rowgroup_ctr < main->rowgroups_avail)
.//JPEG/jdmainct.cpp:413:    main->context_state = CTX_PREPARE_FOR_IMCU;
.//JPEG/jdmainct.cpp:418:    /* Prepare to process first M-1 row groups of this iMCU row */
.//JPEG/jdmainct.cpp:419:    main->rowgroup_ctr = 0;
.//JPEG/jdmainct.cpp:420:    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size - 1);
.//JPEG/jdmainct.cpp:424:    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
.//JPEG/jdmainct.cpp:426:    main->context_state = CTX_PROCESS_IMCU;
.//JPEG/jdmainct.cpp:430:    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
.//JPEG/jdmainct.cpp:431:			&main->rowgroup_ctr, main->rowgroups_avail,
.//JPEG/jdmainct.cpp:433:    if (main->rowgroup_ctr < main->rowgroups_avail)
.//JPEG/jdmainct.cpp:436:    if (main->iMCU_row_ctr == 1)
.//JPEG/jdmainct.cpp:439:    main->whichptr ^= 1;	/* 0=>1 or 1=>0 */
.//JPEG/jdmainct.cpp:440:    main->buffer_full = FALSE;
.//JPEG/jdmainct.cpp:443:    main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_scaled_size + 1);
.//JPEG/jdmainct.cpp:444:    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size + 2);
.//JPEG/jdmainct.cpp:445:    main->context_state = CTX_POSTPONED_ROW;
.//JPEG/jdmainct.cpp:452: * Final pass of two-pass quantization: just call the postprocessor.
.//JPEG/jdmainct.cpp:463:  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
.//JPEG/jdmainct.cpp:483:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmainct.cpp:485:  cinfo->main = (struct jpeg_d_main_controller *) main;
.//JPEG/jdmainct.cpp:486:  main->pub.start_pass = start_pass_main;
.//JPEG/jdmainct.cpp:494:  if (cinfo->upsample->need_context_rows) {
.//JPEG/jdmainct.cpp:495:    if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
.//JPEG/jdmainct.cpp:498:    ngroups = cinfo->min_DCT_scaled_size + 2;
.//JPEG/jdmainct.cpp:500:    ngroups = cinfo->min_DCT_scaled_size;
.//JPEG/jdmainct.cpp:503:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdmainct.cpp:505:    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
.//JPEG/jdmainct.cpp:506:      cinfo->min_DCT_scaled_size; /* height of a row group of component */
.//JPEG/jdmainct.cpp:507:    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
.//JPEG/jdmainct.cpp:509:			 compptr->width_in_blocks * compptr->DCT_scaled_size,
.//JPEG/jdmarker.cpp:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//JPEG/jdmarker.cpp:93:  /* Application-overridable marker processing methods */
.//JPEG/jdmarker.cpp:113: * At all times, cinfo->src->next_input_byte and ->bytes_in_buffer reflect
.//JPEG/jdmarker.cpp:120:	struct jpeg_source_mgr * datasrc = (cinfo)->src;  \
.//JPEG/jdmarker.cpp:121:	const JOCTET * next_input_byte = datasrc->next_input_byte;  \
.//JPEG/jdmarker.cpp:122:	size_t bytes_in_buffer = datasrc->bytes_in_buffer
.//JPEG/jdmarker.cpp:124:/* Unload the local copies --- do this only at a restart boundary */
.//JPEG/jdmarker.cpp:126:	( datasrc->next_input_byte = next_input_byte,  \
.//JPEG/jdmarker.cpp:127:	  datasrc->bytes_in_buffer = bytes_in_buffer )
.//JPEG/jdmarker.cpp:129:/* Reload the local copies --- used only in MAKE_BYTE_AVAIL */
.//JPEG/jdmarker.cpp:131:	( next_input_byte = datasrc->next_input_byte,  \
.//JPEG/jdmarker.cpp:132:	  bytes_in_buffer = datasrc->bytes_in_buffer )
.//JPEG/jdmarker.cpp:140:	  if (! (*datasrc->fill_input_buffer) (cinfo))  \
.//JPEG/jdmarker.cpp:150:		  bytes_in_buffer--; \
.//JPEG/jdmarker.cpp:153:/* As above, but read two bytes interpreted as an unsigned 16-bit integer.
.//JPEG/jdmarker.cpp:158:		  bytes_in_buffer--; \
.//JPEG/jdmarker.cpp:161:		  bytes_in_buffer--; \
.//JPEG/jdmarker.cpp:169: *   in cinfo->unread_marker; input restart point is just after the marker.
.//JPEG/jdmarker.cpp:186: * On resumption, cinfo->unread_marker still contains the marker code,
.//JPEG/jdmarker.cpp:204:  if (cinfo->marker->saw_SOI)
.//JPEG/jdmarker.cpp:210:    cinfo->arith_dc_L[i] = 0;
.//JPEG/jdmarker.cpp:211:    cinfo->arith_dc_U[i] = 1;
.//JPEG/jdmarker.cpp:212:    cinfo->arith_ac_K[i] = 5;
.//JPEG/jdmarker.cpp:214:  cinfo->restart_interval = 0;
.//JPEG/jdmarker.cpp:218:  cinfo->jpeg_color_space = JCS_UNKNOWN;
.//JPEG/jdmarker.cpp:219:  cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling??? */
.//JPEG/jdmarker.cpp:221:  cinfo->saw_JFIF_marker = FALSE;
.//JPEG/jdmarker.cpp:222:  cinfo->JFIF_major_version = 1; /* set default JFIF APP0 values */
.//JPEG/jdmarker.cpp:223:  cinfo->JFIF_minor_version = 1;
.//JPEG/jdmarker.cpp:224:  cinfo->density_unit = 0;
.//JPEG/jdmarker.cpp:225:  cinfo->X_density = 1;
.//JPEG/jdmarker.cpp:226:  cinfo->Y_density = 1;
.//JPEG/jdmarker.cpp:227:  cinfo->saw_Adobe_marker = FALSE;
.//JPEG/jdmarker.cpp:228:  cinfo->Adobe_transform = 0;
.//JPEG/jdmarker.cpp:230:  cinfo->marker->saw_SOI = TRUE;
.//JPEG/jdmarker.cpp:245:  cinfo->progressive_mode = is_prog;
.//JPEG/jdmarker.cpp:246:  cinfo->arith_code = is_arith;
.//JPEG/jdmarker.cpp:250:  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
.//JPEG/jdmarker.cpp:251:  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
.//JPEG/jdmarker.cpp:252:  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
.//JPEG/jdmarker.cpp:253:  INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);
.//JPEG/jdmarker.cpp:255:  length -= 8;
.//JPEG/jdmarker.cpp:257:  TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,
.//JPEG/jdmarker.cpp:258:	   (int) cinfo->image_width, (int) cinfo->image_height,
.//JPEG/jdmarker.cpp:259:	   cinfo->num_components);
.//JPEG/jdmarker.cpp:261:  if (cinfo->marker->saw_SOF)
.//JPEG/jdmarker.cpp:267:  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
.//JPEG/jdmarker.cpp:268:      || cinfo->num_components <= 0)
.//JPEG/jdmarker.cpp:271:  if (length != (cinfo->num_components * 3))
.//JPEG/jdmarker.cpp:274:  if (cinfo->comp_info == NULL)	/* do only once, even if suspend */
.//JPEG/jdmarker.cpp:275:    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
.//JPEG/jdmarker.cpp:277:			 cinfo->num_components * SIZEOF(jpeg_component_info));
.//JPEG/jdmarker.cpp:279:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdmarker.cpp:281:    compptr->component_index = ci;
.//JPEG/jdmarker.cpp:282:    INPUT_BYTE(cinfo, compptr->component_id, return FALSE);
.//JPEG/jdmarker.cpp:284:    compptr->h_samp_factor = (c >> 4) & 15;
.//JPEG/jdmarker.cpp:285:    compptr->v_samp_factor = (c     ) & 15;
.//JPEG/jdmarker.cpp:286:    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);
.//JPEG/jdmarker.cpp:289:	     compptr->component_id, compptr->h_samp_factor,
.//JPEG/jdmarker.cpp:290:	     compptr->v_samp_factor, compptr->quant_tbl_no);
.//JPEG/jdmarker.cpp:293:  cinfo->marker->saw_SOF = TRUE;
.//JPEG/jdmarker.cpp:309:  if (! cinfo->marker->saw_SOF)
.//JPEG/jdmarker.cpp:321:  cinfo->comps_in_scan = n;
.//JPEG/jdmarker.cpp:323:  /* Collect the component-spec parameters */
.//JPEG/jdmarker.cpp:329:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdmarker.cpp:331:      if (cc == compptr->component_id)
.//JPEG/jdmarker.cpp:339:    cinfo->cur_comp_info[i] = compptr;
.//JPEG/jdmarker.cpp:340:    compptr->dc_tbl_no = (c >> 4) & 15;
.//JPEG/jdmarker.cpp:341:    compptr->ac_tbl_no = (c     ) & 15;
.//JPEG/jdmarker.cpp:344:	     compptr->dc_tbl_no, compptr->ac_tbl_no);
.//JPEG/jdmarker.cpp:349:  cinfo->Ss = c;
.//JPEG/jdmarker.cpp:351:  cinfo->Se = c;
.//JPEG/jdmarker.cpp:353:  cinfo->Ah = (c >> 4) & 15;
.//JPEG/jdmarker.cpp:354:  cinfo->Al = (c     ) & 15;
.//JPEG/jdmarker.cpp:356:  TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se,
.//JPEG/jdmarker.cpp:357:	   cinfo->Ah, cinfo->Al);
.//JPEG/jdmarker.cpp:360:  cinfo->marker->next_restart_num = 0;
.//JPEG/jdmarker.cpp:363:  cinfo->input_scan_number++;
.//JPEG/jdmarker.cpp:381:  length -= 2;
.//JPEG/jdmarker.cpp:387:    length -= 2;
.//JPEG/jdmarker.cpp:395:      cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;
.//JPEG/jdmarker.cpp:397:      cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);
.//JPEG/jdmarker.cpp:398:      cinfo->arith_dc_U[index] = (UINT8) (val >> 4);
.//JPEG/jdmarker.cpp:399:      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
.//JPEG/jdmarker.cpp:430:  length -= 2;
.//JPEG/jdmarker.cpp:444:    length -= 1 + 16;
.//JPEG/jdmarker.cpp:462:    length -= count;
.//JPEG/jdmarker.cpp:465:      index -= 0x10;
.//JPEG/jdmarker.cpp:466:      htblptr = &cinfo->ac_huff_tbl_ptrs[index];
.//JPEG/jdmarker.cpp:468:      htblptr = &cinfo->dc_huff_tbl_ptrs[index];
.//JPEG/jdmarker.cpp:477:    MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
.//JPEG/jdmarker.cpp:478:    MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));
.//JPEG/jdmarker.cpp:500:  length -= 2;
.//JPEG/jdmarker.cpp:512:    if (cinfo->quant_tbl_ptrs[n] == NULL)
.//JPEG/jdmarker.cpp:513:      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
.//JPEG/jdmarker.cpp:514:    quant_ptr = cinfo->quant_tbl_ptrs[n];
.//JPEG/jdmarker.cpp:521:      /* We convert the zigzag-order table to natural array order. */
.//JPEG/jdmarker.cpp:522:      quant_ptr->quantval[jpeg_natural_order[i]] = (UINT16) tmp;
.//JPEG/jdmarker.cpp:525:    if (cinfo->err->trace_level >= 2) {
.//JPEG/jdmarker.cpp:528:		 quant_ptr->quantval[i],   quant_ptr->quantval[i+1],
.//JPEG/jdmarker.cpp:529:		 quant_ptr->quantval[i+2], quant_ptr->quantval[i+3],
.//JPEG/jdmarker.cpp:530:		 quant_ptr->quantval[i+4], quant_ptr->quantval[i+5],
.//JPEG/jdmarker.cpp:531:		 quant_ptr->quantval[i+6], quant_ptr->quantval[i+7]);
.//JPEG/jdmarker.cpp:535:    length -= DCTSIZE2+1;
.//JPEG/jdmarker.cpp:536:    if (prec) length -= DCTSIZE2;
.//JPEG/jdmarker.cpp:564:  cinfo->restart_interval = tmp;
.//JPEG/jdmarker.cpp:600:    cinfo->saw_JFIF_marker = TRUE;
.//JPEG/jdmarker.cpp:601:    cinfo->JFIF_major_version = GETJOCTET(data[5]);
.//JPEG/jdmarker.cpp:602:    cinfo->JFIF_minor_version = GETJOCTET(data[6]);
.//JPEG/jdmarker.cpp:603:    cinfo->density_unit = GETJOCTET(data[7]);
.//JPEG/jdmarker.cpp:604:    cinfo->X_density = (GETJOCTET(data[8]) << 8) + GETJOCTET(data[9]);
.//JPEG/jdmarker.cpp:605:    cinfo->Y_density = (GETJOCTET(data[10]) << 8) + GETJOCTET(data[11]);
.//JPEG/jdmarker.cpp:612:    if (cinfo->JFIF_major_version != 1)
.//JPEG/jdmarker.cpp:614:	      cinfo->JFIF_major_version, cinfo->JFIF_minor_version);
.//JPEG/jdmarker.cpp:617:	     cinfo->JFIF_major_version, cinfo->JFIF_minor_version,
.//JPEG/jdmarker.cpp:618:	     cinfo->X_density, cinfo->Y_density, cinfo->density_unit);
.//JPEG/jdmarker.cpp:623:    totallen -= APP0_DATA_LEN;
.//JPEG/jdmarker.cpp:681:    cinfo->saw_Adobe_marker = TRUE;
.//JPEG/jdmarker.cpp:682:    cinfo->Adobe_transform = (UINT8) transform;
.//JPEG/jdmarker.cpp:700:  length -= 2;
.//JPEG/jdmarker.cpp:711:  length -= numtoread;
.//JPEG/jdmarker.cpp:714:  switch (cinfo->unread_marker) {
.//JPEG/jdmarker.cpp:723:    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
.//JPEG/jdmarker.cpp:727:  /* skip any remaining data -- could be lots */
.//JPEG/jdmarker.cpp:730:    (*cinfo->src->skip_input_data) (cinfo, (long) length);
.//JPEG/jdmarker.cpp:742:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//JPEG/jdmarker.cpp:743:  jpeg_saved_marker_ptr cur_marker = marker->cur_marker;
.//JPEG/jdmarker.cpp:752:    length -= 2;
.//JPEG/jdmarker.cpp:756:      if (cinfo->unread_marker == (int) M_COM)
.//JPEG/jdmarker.cpp:757:	limit = marker->length_limit_COM;
.//JPEG/jdmarker.cpp:759:	limit = marker->length_limit_APPn[cinfo->unread_marker - (int) M_APP0];
.//JPEG/jdmarker.cpp:764:	(*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmarker.cpp:766:      cur_marker->next = NULL;
.//JPEG/jdmarker.cpp:767:      cur_marker->marker = (UINT8) cinfo->unread_marker;
.//JPEG/jdmarker.cpp:768:      cur_marker->original_length = (unsigned int) length;
.//JPEG/jdmarker.cpp:769:      cur_marker->data_length = limit;
.//JPEG/jdmarker.cpp:771:      data = cur_marker->data = (JOCTET FAR *) (cur_marker + 1);
.//JPEG/jdmarker.cpp:772:      marker->cur_marker = cur_marker;
.//JPEG/jdmarker.cpp:773:      marker->bytes_read = 0;
.//JPEG/jdmarker.cpp:783:    bytes_read = marker->bytes_read;
.//JPEG/jdmarker.cpp:784:    data_length = cur_marker->data_length;
.//JPEG/jdmarker.cpp:785:    data = cur_marker->data + bytes_read;
.//JPEG/jdmarker.cpp:790:    marker->bytes_read = bytes_read;
.//JPEG/jdmarker.cpp:796:      bytes_in_buffer--;
.//JPEG/jdmarker.cpp:804:    if (cinfo->marker_list == NULL) {
.//JPEG/jdmarker.cpp:805:      cinfo->marker_list = cur_marker;
.//JPEG/jdmarker.cpp:807:      jpeg_saved_marker_ptr prev = cinfo->marker_list;
.//JPEG/jdmarker.cpp:808:      while (prev->next != NULL)
.//JPEG/jdmarker.cpp:809:	prev = prev->next;
.//JPEG/jdmarker.cpp:810:      prev->next = cur_marker;
.//JPEG/jdmarker.cpp:813:    data = cur_marker->data;
.//JPEG/jdmarker.cpp:814:    length = cur_marker->original_length - data_length;
.//JPEG/jdmarker.cpp:817:  marker->cur_marker = NULL;
.//JPEG/jdmarker.cpp:820:  switch (cinfo->unread_marker) {
.//JPEG/jdmarker.cpp:828:    TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker,
.//JPEG/jdmarker.cpp:833:  /* skip any remaining data -- could be lots */
.//JPEG/jdmarker.cpp:836:    (*cinfo->src->skip_input_data) (cinfo, (long) length);
.//JPEG/jdmarker.cpp:846:/* Skip over an unknown or uninteresting variable-length marker */
.//JPEG/jdmarker.cpp:852:  length -= 2;
.//JPEG/jdmarker.cpp:854:  TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker, (int) length);
.//JPEG/jdmarker.cpp:858:    (*cinfo->src->skip_input_data) (cinfo, (long) length);
.//JPEG/jdmarker.cpp:865: * Find the next JPEG marker, save it in cinfo->unread_marker.
.//JPEG/jdmarker.cpp:867: * in that case cinfo->unread_marker is unchanged.
.//JPEG/jdmarker.cpp:881:    /* Skip any non-FF bytes.
.//JPEG/jdmarker.cpp:887:      cinfo->marker->discarded_bytes++;
.//JPEG/jdmarker.cpp:901:    /* Reach here if we found a stuffed-zero data sequence (FF/00).
.//JPEG/jdmarker.cpp:904:    cinfo->marker->discarded_bytes += 2;
.//JPEG/jdmarker.cpp:908:  if (cinfo->marker->discarded_bytes != 0) {
.//JPEG/jdmarker.cpp:909:    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);
.//JPEG/jdmarker.cpp:910:    cinfo->marker->discarded_bytes = 0;
.//JPEG/jdmarker.cpp:913:  cinfo->unread_marker = c;
.//JPEG/jdmarker.cpp:925: * If an application wants to process non-JFIF files, it must seek to the
.//JPEG/jdmarker.cpp:937:  cinfo->unread_marker = c2;
.//JPEG/jdmarker.cpp:958:    if (cinfo->unread_marker == 0) {
.//JPEG/jdmarker.cpp:959:      if (! cinfo->marker->saw_SOI) {
.//JPEG/jdmarker.cpp:967:    /* At this point cinfo->unread_marker contains the marker code and the
.//JPEG/jdmarker.cpp:971:    switch (cinfo->unread_marker) {
.//JPEG/jdmarker.cpp:1008:      ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);
.//JPEG/jdmarker.cpp:1014:      cinfo->unread_marker = 0;	/* processed the marker */
.//JPEG/jdmarker.cpp:1019:      cinfo->unread_marker = 0;	/* processed the marker */
.//JPEG/jdmarker.cpp:1058:      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[
.//JPEG/jdmarker.cpp:1059:		cinfo->unread_marker - (int) M_APP0]) (cinfo))
.//JPEG/jdmarker.cpp:1064:      if (! (*((my_marker_ptr) cinfo->marker)->process_COM) (cinfo))
.//JPEG/jdmarker.cpp:1077:      TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);
.//JPEG/jdmarker.cpp:1088:       * Once the JPEG 3 version-number marker is well defined, this code
.//JPEG/jdmarker.cpp:1091:      ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
.//JPEG/jdmarker.cpp:1095:    cinfo->unread_marker = 0;
.//JPEG/jdmarker.cpp:1106: * number of MCUs.  cinfo->unread_marker may be nonzero if the entropy decoder
.//JPEG/jdmarker.cpp:1108: * cinfo->unread_marker will be reset to 0 before returning; if not reset,
.//JPEG/jdmarker.cpp:1117:  if (cinfo->unread_marker == 0) {
.//JPEG/jdmarker.cpp:1122:  if (cinfo->unread_marker ==
.//JPEG/jdmarker.cpp:1123:      ((int) M_RST0 + cinfo->marker->next_restart_num)) {
.//JPEG/jdmarker.cpp:1124:    /* Normal case --- swallow the marker and let entropy decoder continue */
.//JPEG/jdmarker.cpp:1125:    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);
.//JPEG/jdmarker.cpp:1126:    cinfo->unread_marker = 0;
.//JPEG/jdmarker.cpp:1128:    /* Uh-oh, the restart markers have been messed up. */
.//JPEG/jdmarker.cpp:1130:    if (! (*cinfo->src->resync_to_restart) (cinfo,
.//JPEG/jdmarker.cpp:1131:					    cinfo->marker->next_restart_num))
.//JPEG/jdmarker.cpp:1135:  /* Update next-restart state */
.//JPEG/jdmarker.cpp:1136:  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;
.//JPEG/jdmarker.cpp:1151: * a nonzero restart interval has been declared.)  cinfo->unread_marker is
.//JPEG/jdmarker.cpp:1156: * Note that cinfo->unread_marker is treated as a marker appearing before
.//JPEG/jdmarker.cpp:1157: * the current data-source input point; usually it should be reset to zero
.//JPEG/jdmarker.cpp:1170: *      dependent on buffer size and chance buffer-boundary positions.)
.//JPEG/jdmarker.cpp:1171: *   3. Leave the marker unread (by failing to zero cinfo->unread_marker).
.//JPEG/jdmarker.cpp:1185: * For any valid non-restart JPEG marker, we apply #3.  This keeps us from
.//JPEG/jdmarker.cpp:1186: * overrunning the end of a scan.  An implementation limited to single-scan
.//JPEG/jdmarker.cpp:1194:  int marker = cinfo->unread_marker;
.//JPEG/jdmarker.cpp:1205:      action = 3;		/* valid non-restart marker */
.//JPEG/jdmarker.cpp:1210:      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
.//JPEG/jdmarker.cpp:1211:	       marker == ((int) M_RST0 + ((desired-2) & 7)))
.//JPEG/jdmarker.cpp:1220:      cinfo->unread_marker = 0;
.//JPEG/jdmarker.cpp:1226:      marker = cinfo->unread_marker;
.//JPEG/jdmarker.cpp:1244:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//JPEG/jdmarker.cpp:1246:  cinfo->comp_info = NULL;		/* until allocated by get_sof */
.//JPEG/jdmarker.cpp:1247:  cinfo->input_scan_number = 0;		/* no SOS seen yet */
.//JPEG/jdmarker.cpp:1248:  cinfo->unread_marker = 0;		/* no pending marker */
.//JPEG/jdmarker.cpp:1249:  marker->pub.saw_SOI = FALSE;		/* set internal state too */
.//JPEG/jdmarker.cpp:1250:  marker->pub.saw_SOF = FALSE;
.//JPEG/jdmarker.cpp:1251:  marker->pub.discarded_bytes = 0;
.//JPEG/jdmarker.cpp:1252:  marker->cur_marker = NULL;
.//JPEG/jdmarker.cpp:1269:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//JPEG/jdmarker.cpp:1271:  cinfo->marker = (struct jpeg_marker_reader *) marker;
.//JPEG/jdmarker.cpp:1273:  marker->pub.reset_marker_reader = reset_marker_reader;
.//JPEG/jdmarker.cpp:1274:  marker->pub.read_markers = read_markers;
.//JPEG/jdmarker.cpp:1275:  marker->pub.read_restart_marker = read_restart_marker;
.//JPEG/jdmarker.cpp:1280:  marker->process_COM = skip_variable;
.//JPEG/jdmarker.cpp:1281:  marker->length_limit_COM = 0;
.//JPEG/jdmarker.cpp:1283:    marker->process_APPn[i] = skip_variable;
.//JPEG/jdmarker.cpp:1284:    marker->length_limit_APPn[i] = 0;
.//JPEG/jdmarker.cpp:1286:  marker->process_APPn[0] = get_interesting_appn;
.//JPEG/jdmarker.cpp:1287:  marker->process_APPn[14] = get_interesting_appn;
.//JPEG/jdmarker.cpp:1303:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//JPEG/jdmarker.cpp:1308:   * (should only be a concern in a 16-bit environment).
.//JPEG/jdmarker.cpp:1310:  maxlength = cinfo->mem->max_alloc_chunk - SIZEOF(struct jpeg_marker_struct);
.//JPEG/jdmarker.cpp:1326:    /* If discarding APP0/APP14, use our regular on-the-fly processor. */
.//JPEG/jdmarker.cpp:1332:    marker->process_COM = processor;
.//JPEG/jdmarker.cpp:1333:    marker->length_limit_COM = length_limit;
.//JPEG/jdmarker.cpp:1335:    marker->process_APPn[marker_code - (int) M_APP0] = processor;
.//JPEG/jdmarker.cpp:1336:    marker->length_limit_APPn[marker_code - (int) M_APP0] = length_limit;
.//JPEG/jdmarker.cpp:1352:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//JPEG/jdmarker.cpp:1355:    marker->process_COM = routine;
.//JPEG/jdmarker.cpp:1357:    marker->process_APPn[marker_code - (int) M_APP0] = routine;
.//JPEG/jdmaster.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jdmaster.cpp:47:  /* Merging is the equivalent of plain box-filter upsampling */
.//JPEG/jdmaster.cpp:48:  if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
.//JPEG/jdmaster.cpp:51:  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
.//JPEG/jdmaster.cpp:52:      cinfo->out_color_space != JCS_RGB ||
.//JPEG/jdmaster.cpp:53:      cinfo->out_color_components != RGB_PIXELSIZE)
.//JPEG/jdmaster.cpp:56:  if (cinfo->comp_info[0].h_samp_factor != 2 ||
.//JPEG/jdmaster.cpp:57:      cinfo->comp_info[1].h_samp_factor != 1 ||
.//JPEG/jdmaster.cpp:58:      cinfo->comp_info[2].h_samp_factor != 1 ||
.//JPEG/jdmaster.cpp:59:      cinfo->comp_info[0].v_samp_factor >  2 ||
.//JPEG/jdmaster.cpp:60:      cinfo->comp_info[1].v_samp_factor != 1 ||
.//JPEG/jdmaster.cpp:61:      cinfo->comp_info[2].v_samp_factor != 1)
.//JPEG/jdmaster.cpp:64:  if (cinfo->comp_info[0].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
.//JPEG/jdmaster.cpp:65:      cinfo->comp_info[1].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
.//JPEG/jdmaster.cpp:66:      cinfo->comp_info[2].DCT_scaled_size != cinfo->min_DCT_scaled_size)
.//JPEG/jdmaster.cpp:68:  /* ??? also need to test for upsample-time rescaling, when & if supported */
.//JPEG/jdmaster.cpp:93:  if (cinfo->global_state != DSTATE_READY)
.//JPEG/jdmaster.cpp:94:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdmaster.cpp:99:  if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
.//JPEG/jdmaster.cpp:101:    cinfo->output_width = (JDIMENSION)
.//JPEG/jdmaster.cpp:102:      jdiv_round_up((long) cinfo->image_width, 8L);
.//JPEG/jdmaster.cpp:103:    cinfo->output_height = (JDIMENSION)
.//JPEG/jdmaster.cpp:104:      jdiv_round_up((long) cinfo->image_height, 8L);
.//JPEG/jdmaster.cpp:105:    cinfo->min_DCT_scaled_size = 1;
.//JPEG/jdmaster.cpp:106:  } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
.//JPEG/jdmaster.cpp:108:    cinfo->output_width = (JDIMENSION)
.//JPEG/jdmaster.cpp:109:      jdiv_round_up((long) cinfo->image_width, 4L);
.//JPEG/jdmaster.cpp:110:    cinfo->output_height = (JDIMENSION)
.//JPEG/jdmaster.cpp:111:      jdiv_round_up((long) cinfo->image_height, 4L);
.//JPEG/jdmaster.cpp:112:    cinfo->min_DCT_scaled_size = 2;
.//JPEG/jdmaster.cpp:113:  } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
.//JPEG/jdmaster.cpp:115:    cinfo->output_width = (JDIMENSION)
.//JPEG/jdmaster.cpp:116:      jdiv_round_up((long) cinfo->image_width, 2L);
.//JPEG/jdmaster.cpp:117:    cinfo->output_height = (JDIMENSION)
.//JPEG/jdmaster.cpp:118:      jdiv_round_up((long) cinfo->image_height, 2L);
.//JPEG/jdmaster.cpp:119:    cinfo->min_DCT_scaled_size = 4;
.//JPEG/jdmaster.cpp:122:    cinfo->output_width = cinfo->image_width;
.//JPEG/jdmaster.cpp:123:    cinfo->output_height = cinfo->image_height;
.//JPEG/jdmaster.cpp:124:    cinfo->min_DCT_scaled_size = DCTSIZE;
.//JPEG/jdmaster.cpp:131:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdmaster.cpp:133:    int ssize = cinfo->min_DCT_scaled_size;
.//JPEG/jdmaster.cpp:135:	   (compptr->h_samp_factor * ssize * 2 <=
.//JPEG/jdmaster.cpp:136:	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
.//JPEG/jdmaster.cpp:137:	   (compptr->v_samp_factor * ssize * 2 <=
.//JPEG/jdmaster.cpp:138:	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
.//JPEG/jdmaster.cpp:141:    compptr->DCT_scaled_size = ssize;
.//JPEG/jdmaster.cpp:147:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdmaster.cpp:150:    compptr->downsampled_width = (JDIMENSION)
.//JPEG/jdmaster.cpp:151:      jdiv_round_up((long) cinfo->image_width *
.//JPEG/jdmaster.cpp:152:		    (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
.//JPEG/jdmaster.cpp:153:		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
.//JPEG/jdmaster.cpp:154:    compptr->downsampled_height = (JDIMENSION)
.//JPEG/jdmaster.cpp:155:      jdiv_round_up((long) cinfo->image_height *
.//JPEG/jdmaster.cpp:156:		    (long) (compptr->v_samp_factor * compptr->DCT_scaled_size),
.//JPEG/jdmaster.cpp:157:		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
.//JPEG/jdmaster.cpp:163:  cinfo->output_width = cinfo->image_width;
.//JPEG/jdmaster.cpp:164:  cinfo->output_height = cinfo->image_height;
.//JPEG/jdmaster.cpp:173:  switch (cinfo->out_color_space) {
.//JPEG/jdmaster.cpp:175:    cinfo->out_color_components = 1;
.//JPEG/jdmaster.cpp:179:    cinfo->out_color_components = RGB_PIXELSIZE;
.//JPEG/jdmaster.cpp:183:    cinfo->out_color_components = 3;
.//JPEG/jdmaster.cpp:187:    cinfo->out_color_components = 4;
.//JPEG/jdmaster.cpp:190:    cinfo->out_color_components = cinfo->num_components;
.//JPEG/jdmaster.cpp:193:  cinfo->output_components = (cinfo->quantize_colors ? 1 :
.//JPEG/jdmaster.cpp:194:			      cinfo->out_color_components);
.//JPEG/jdmaster.cpp:198:    cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
.//JPEG/jdmaster.cpp:200:    cinfo->rec_outbuf_height = 1;
.//JPEG/jdmaster.cpp:205: * Several decompression processes need to range-limit values to the range
.//JPEG/jdmaster.cpp:210: * a (subscript-check-less) C table lookup
.//JPEG/jdmaster.cpp:219: * -(MAXJSAMPLE+1) to 2*MAXJSAMPLE+1 is sufficient.  But for the initial
.//JPEG/jdmaster.cpp:220: * limiting step (just after the IDCT), a wildly out-of-range value is 
.//JPEG/jdmaster.cpp:222: * off the end of memory and getting a bad-pointer trap, we perform the
.//JPEG/jdmaster.cpp:223: * post-IDCT limiting thus:
.//JPEG/jdmaster.cpp:225: * where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit
.//JPEG/jdmaster.cpp:228: * cause wraparound, and we will safely generate a bogus-but-in-range output.
.//JPEG/jdmaster.cpp:229: * For the post-IDCT step, we want to convert the data from signed to unsigned
.//JPEG/jdmaster.cpp:231: * So the post-IDCT limiting table ends up looking like this:
.//JPEG/jdmaster.cpp:233: *   MAXJSAMPLE (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),
.//JPEG/jdmaster.cpp:234: *   0          (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),
.//JPEG/jdmaster.cpp:235: *   0,1,...,CENTERJSAMPLE-1
.//JPEG/jdmaster.cpp:239: * We can save some space by overlapping the start of the post-IDCT table
.//JPEG/jdmaster.cpp:240: * with the simpler range limiting table.  The post-IDCT table begins at
.//JPEG/jdmaster.cpp:255:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmaster.cpp:258:  cinfo->sample_range_limit = table;
.//JPEG/jdmaster.cpp:260:  MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
.//JPEG/jdmaster.cpp:264:  table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
.//JPEG/jdmaster.cpp:265:  /* End of simple table, rest of first half of post-IDCT table */
.//JPEG/jdmaster.cpp:268:  /* Second half of post-IDCT table */
.//JPEG/jdmaster.cpp:270:	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
.//JPEG/jdmaster.cpp:271:  MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
.//JPEG/jdmaster.cpp:272:	  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));
.//JPEG/jdmaster.cpp:290:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//JPEG/jdmaster.cpp:300:  samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
.//JPEG/jdmaster.cpp:306:  master->pass_number = 0;
.//JPEG/jdmaster.cpp:307:  master->using_merged_upsample = use_merged_upsample(cinfo);
.//JPEG/jdmaster.cpp:310:  master->quantizer_1pass = NULL;
.//JPEG/jdmaster.cpp:311:  master->quantizer_2pass = NULL;
.//JPEG/jdmaster.cpp:312:  /* No mode changes if not using buffered-image mode. */
.//JPEG/jdmaster.cpp:313:  if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
.//JPEG/jdmaster.cpp:314:    cinfo->enable_1pass_quant = FALSE;
.//JPEG/jdmaster.cpp:315:    cinfo->enable_external_quant = FALSE;
.//JPEG/jdmaster.cpp:316:    cinfo->enable_2pass_quant = FALSE;
.//JPEG/jdmaster.cpp:318:  if (cinfo->quantize_colors) {
.//JPEG/jdmaster.cpp:319:    if (cinfo->raw_data_out)
.//JPEG/jdmaster.cpp:321:    /* 2-pass quantizer only works in 3-component color space. */
.//JPEG/jdmaster.cpp:322:    if (cinfo->out_color_components != 3) {
.//JPEG/jdmaster.cpp:323:      cinfo->enable_1pass_quant = TRUE;
.//JPEG/jdmaster.cpp:324:      cinfo->enable_external_quant = FALSE;
.//JPEG/jdmaster.cpp:325:      cinfo->enable_2pass_quant = FALSE;
.//JPEG/jdmaster.cpp:326:      cinfo->colormap = NULL;
.//JPEG/jdmaster.cpp:327:    } else if (cinfo->colormap != NULL) {
.//JPEG/jdmaster.cpp:328:      cinfo->enable_external_quant = TRUE;
.//JPEG/jdmaster.cpp:329:    } else if (cinfo->two_pass_quantize) {
.//JPEG/jdmaster.cpp:330:      cinfo->enable_2pass_quant = TRUE;
.//JPEG/jdmaster.cpp:332:      cinfo->enable_1pass_quant = TRUE;
.//JPEG/jdmaster.cpp:335:    if (cinfo->enable_1pass_quant) {
.//JPEG/jdmaster.cpp:338:      master->quantizer_1pass = cinfo->cquantize;
.//JPEG/jdmaster.cpp:344:    /* We use the 2-pass code to map to external colormaps. */
.//JPEG/jdmaster.cpp:345:    if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
.//JPEG/jdmaster.cpp:348:      master->quantizer_2pass = cinfo->cquantize;
.//JPEG/jdmaster.cpp:353:    /* If both quantizers are initialized, the 2-pass one is left active;
.//JPEG/jdmaster.cpp:358:  /* Post-processing: in particular, color conversion first */
.//JPEG/jdmaster.cpp:359:  if (! cinfo->raw_data_out) {
.//JPEG/jdmaster.cpp:360:    if (master->using_merged_upsample) {
.//JPEG/jdmaster.cpp:370:    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
.//JPEG/jdmaster.cpp:375:  if (cinfo->arith_code) {
.//JPEG/jdmaster.cpp:378:    if (cinfo->progressive_mode) {
.//JPEG/jdmaster.cpp:389:  use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
.//JPEG/jdmaster.cpp:392:  if (! cinfo->raw_data_out)
.//JPEG/jdmaster.cpp:396:  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
.//JPEG/jdmaster.cpp:399:  (*cinfo->inputctl->start_input_pass) (cinfo);
.//JPEG/jdmaster.cpp:406:  if (cinfo->progress != NULL && ! cinfo->buffered_image &&
.//JPEG/jdmaster.cpp:407:      cinfo->inputctl->has_multiple_scans) {
.//JPEG/jdmaster.cpp:410:    if (cinfo->progressive_mode) {
.//JPEG/jdmaster.cpp:412:      nscans = 2 + 3 * cinfo->num_components;
.//JPEG/jdmaster.cpp:415:      nscans = cinfo->num_components;
.//JPEG/jdmaster.cpp:417:    cinfo->progress->pass_counter = 0L;
.//JPEG/jdmaster.cpp:418:    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
.//JPEG/jdmaster.cpp:419:    cinfo->progress->completed_passes = 0;
.//JPEG/jdmaster.cpp:420:    cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
.//JPEG/jdmaster.cpp:422:    master->pass_number++;
.//JPEG/jdmaster.cpp:429: * Per-pass setup.
.//JPEG/jdmaster.cpp:440:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//JPEG/jdmaster.cpp:442:  if (master->pub.is_dummy_pass) {
.//JPEG/jdmaster.cpp:444:    /* Final pass of 2-pass quantization */
.//JPEG/jdmaster.cpp:445:    master->pub.is_dummy_pass = FALSE;
.//JPEG/jdmaster.cpp:446:    (*cinfo->cquantize->start_pass) (cinfo, FALSE);
.//JPEG/jdmaster.cpp:447:    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
.//JPEG/jdmaster.cpp:448:    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
.//JPEG/jdmaster.cpp:453:    if (cinfo->quantize_colors && cinfo->colormap == NULL) {
.//JPEG/jdmaster.cpp:455:      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
.//JPEG/jdmaster.cpp:456:	cinfo->cquantize = master->quantizer_2pass;
.//JPEG/jdmaster.cpp:457:	master->pub.is_dummy_pass = TRUE;
.//JPEG/jdmaster.cpp:458:      } else if (cinfo->enable_1pass_quant) {
.//JPEG/jdmaster.cpp:459:	cinfo->cquantize = master->quantizer_1pass;
.//JPEG/jdmaster.cpp:464:    (*cinfo->idct->start_pass) (cinfo);
.//JPEG/jdmaster.cpp:465:    (*cinfo->coef->start_output_pass) (cinfo);
.//JPEG/jdmaster.cpp:466:    if (! cinfo->raw_data_out) {
.//JPEG/jdmaster.cpp:467:      if (! master->using_merged_upsample)
.//JPEG/jdmaster.cpp:468:	(*cinfo->cconvert->start_pass) (cinfo);
.//JPEG/jdmaster.cpp:469:      (*cinfo->upsample->start_pass) (cinfo);
.//JPEG/jdmaster.cpp:470:      if (cinfo->quantize_colors)
.//JPEG/jdmaster.cpp:471:	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
.//JPEG/jdmaster.cpp:472:      (*cinfo->post->start_pass) (cinfo,
.//JPEG/jdmaster.cpp:473:	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
.//JPEG/jdmaster.cpp:474:      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
.//JPEG/jdmaster.cpp:479:  if (cinfo->progress != NULL) {
.//JPEG/jdmaster.cpp:480:    cinfo->progress->completed_passes = master->pass_number;
.//JPEG/jdmaster.cpp:481:    cinfo->progress->total_passes = master->pass_number +
.//JPEG/jdmaster.cpp:482:				    (master->pub.is_dummy_pass ? 2 : 1);
.//JPEG/jdmaster.cpp:483:    /* In buffered-image mode, we assume one more output pass if EOI not
.//JPEG/jdmaster.cpp:486:    if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
.//JPEG/jdmaster.cpp:487:      cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
.//JPEG/jdmaster.cpp:500:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//JPEG/jdmaster.cpp:502:  if (cinfo->quantize_colors)
.//JPEG/jdmaster.cpp:503:    (*cinfo->cquantize->finish_pass) (cinfo);
.//JPEG/jdmaster.cpp:504:  master->pass_number++;
.//JPEG/jdmaster.cpp:517:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//JPEG/jdmaster.cpp:520:  if (cinfo->global_state != DSTATE_BUFIMAGE)
.//JPEG/jdmaster.cpp:521:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdmaster.cpp:523:  if (cinfo->quantize_colors && cinfo->enable_external_quant &&
.//JPEG/jdmaster.cpp:524:      cinfo->colormap != NULL) {
.//JPEG/jdmaster.cpp:525:    /* Select 2-pass quantizer for external colormap use */
.//JPEG/jdmaster.cpp:526:    cinfo->cquantize = master->quantizer_2pass;
.//JPEG/jdmaster.cpp:528:    (*cinfo->cquantize->new_color_map) (cinfo);
.//JPEG/jdmaster.cpp:529:    master->pub.is_dummy_pass = FALSE; /* just in case */
.//JPEG/jdmaster.cpp:548:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmaster.cpp:550:  cinfo->master = (struct jpeg_decomp_master *) master;
.//JPEG/jdmaster.cpp:551:  master->pub.prepare_for_output_pass = prepare_for_output_pass;
.//JPEG/jdmaster.cpp:552:  master->pub.finish_output_pass = finish_output_pass;
.//JPEG/jdmaster.cpp:554:  master->pub.is_dummy_pass = FALSE;
.//JPEG/jdmerge.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jdmerge.cpp:22: * At typical sampling ratios, this eliminates half or three-quarters of the
.//JPEG/jdmerge.cpp:29: *	Corner-aligned (non-CCIR601) sampling alignment.
.//JPEG/jdmerge.cpp:52:  /* Private state for YCC->RGB conversion */
.//JPEG/jdmerge.cpp:60:   * application provides just a one-row buffer; we also use the spare
.//JPEG/jdmerge.cpp:72:#define SCALEBITS	16	/* speediest right-shift on some machines */
.//JPEG/jdmerge.cpp:73:#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
.//JPEG/jdmerge.cpp:78: * Initialize tables for YCC->RGB colorspace conversion.
.//JPEG/jdmerge.cpp:85:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//JPEG/jdmerge.cpp:90:  upsample->Cr_r_tab = (int *)
.//JPEG/jdmerge.cpp:91:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmerge.cpp:93:  upsample->Cb_b_tab = (int *)
.//JPEG/jdmerge.cpp:94:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmerge.cpp:96:  upsample->Cr_g_tab = (INT32 *)
.//JPEG/jdmerge.cpp:97:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmerge.cpp:99:  upsample->Cb_g_tab = (INT32 *)
.//JPEG/jdmerge.cpp:100:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmerge.cpp:103:  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
.//JPEG/jdmerge.cpp:105:    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
.//JPEG/jdmerge.cpp:107:    upsample->Cr_r_tab[i] = (int)
.//JPEG/jdmerge.cpp:110:    upsample->Cb_b_tab[i] = (int)
.//JPEG/jdmerge.cpp:112:    /* Cr=>G value is scaled-up -0.71414 * x */
.//JPEG/jdmerge.cpp:113:    upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;
.//JPEG/jdmerge.cpp:114:    /* Cb=>G value is scaled-up -0.34414 * x */
.//JPEG/jdmerge.cpp:116:    upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
.//JPEG/jdmerge.cpp:128:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//JPEG/jdmerge.cpp:131:  upsample->spare_full = FALSE;
.//JPEG/jdmerge.cpp:132:  /* Initialize total-height counter for detecting bottom of image */
.//JPEG/jdmerge.cpp:133:  upsample->rows_to_go = cinfo->output_height;
.//JPEG/jdmerge.cpp:151:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//JPEG/jdmerge.cpp:155:  if (upsample->spare_full) {
.//JPEG/jdmerge.cpp:157:    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
.//JPEG/jdmerge.cpp:158:		      1, upsample->out_row_width);
.//JPEG/jdmerge.cpp:160:    upsample->spare_full = FALSE;
.//JPEG/jdmerge.cpp:165:    if (num_rows > upsample->rows_to_go)
.//JPEG/jdmerge.cpp:166:      num_rows = upsample->rows_to_go;
.//JPEG/jdmerge.cpp:168:    out_rows_avail -= *out_row_ctr;
.//JPEG/jdmerge.cpp:176:      work_ptrs[1] = upsample->spare_row;
.//JPEG/jdmerge.cpp:177:      upsample->spare_full = TRUE;
.//JPEG/jdmerge.cpp:180:    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
.//JPEG/jdmerge.cpp:185:  upsample->rows_to_go -= num_rows;
.//JPEG/jdmerge.cpp:187:  if (! upsample->spare_full)
.//JPEG/jdmerge.cpp:200:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//JPEG/jdmerge.cpp:203:  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
.//JPEG/jdmerge.cpp:215: * Note: since we may be writing directly into application-supplied buffers,
.//JPEG/jdmerge.cpp:230:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//JPEG/jdmerge.cpp:237:  register JSAMPLE * range_limit = cinfo->sample_range_limit;
.//JPEG/jdmerge.cpp:238:  int * Crrtab = upsample->Cr_r_tab;
.//JPEG/jdmerge.cpp:239:  int * Cbbtab = upsample->Cb_b_tab;
.//JPEG/jdmerge.cpp:240:  INT32 * Crgtab = upsample->Cr_g_tab;
.//JPEG/jdmerge.cpp:241:  INT32 * Cbgtab = upsample->Cb_g_tab;
.//JPEG/jdmerge.cpp:249:  for (col = cinfo->output_width >> 1; col > 0; col--) {
.//JPEG/jdmerge.cpp:269:  if (cinfo->output_width & 1) {
.//JPEG/jdmerge.cpp:292:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//JPEG/jdmerge.cpp:299:  register JSAMPLE * range_limit = cinfo->sample_range_limit;
.//JPEG/jdmerge.cpp:300:  int * Crrtab = upsample->Cr_r_tab;
.//JPEG/jdmerge.cpp:301:  int * Cbbtab = upsample->Cb_b_tab;
.//JPEG/jdmerge.cpp:302:  INT32 * Crgtab = upsample->Cr_g_tab;
.//JPEG/jdmerge.cpp:303:  INT32 * Cbgtab = upsample->Cb_g_tab;
.//JPEG/jdmerge.cpp:313:  for (col = cinfo->output_width >> 1; col > 0; col--) {
.//JPEG/jdmerge.cpp:343:  if (cinfo->output_width & 1) {
.//JPEG/jdmerge.cpp:375:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmerge.cpp:377:  cinfo->upsample = (struct jpeg_upsampler *) upsample;
.//JPEG/jdmerge.cpp:378:  upsample->pub.start_pass = start_pass_merged_upsample;
.//JPEG/jdmerge.cpp:379:  upsample->pub.need_context_rows = FALSE;
.//JPEG/jdmerge.cpp:381:  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
.//JPEG/jdmerge.cpp:383:  if (cinfo->max_v_samp_factor == 2) {
.//JPEG/jdmerge.cpp:384:    upsample->pub.upsample = merged_2v_upsample;
.//JPEG/jdmerge.cpp:385:    upsample->upmethod = h2v2_merged_upsample;
.//JPEG/jdmerge.cpp:387:    upsample->spare_row = (JSAMPROW)
.//JPEG/jdmerge.cpp:388:      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdmerge.cpp:389:		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
.//JPEG/jdmerge.cpp:391:    upsample->pub.upsample = merged_1v_upsample;
.//JPEG/jdmerge.cpp:392:    upsample->upmethod = h2v1_merged_upsample;
.//JPEG/jdmerge.cpp:394:    upsample->spare_row = NULL;
.//JPEG/jdphuff.cpp:4: * Copyright (C) 1995-1997, Thomas G. Lane.
.//JPEG/jdphuff.cpp:88: * Initialize for a Huffman-compressed scan.
.//JPEG/jdphuff.cpp:94:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jdphuff.cpp:100:  is_DC_band = (cinfo->Ss == 0);
.//JPEG/jdphuff.cpp:105:    if (cinfo->Se != 0)
.//JPEG/jdphuff.cpp:109:    if (cinfo->Ss > cinfo->Se || cinfo->Se >= DCTSIZE2)
.//JPEG/jdphuff.cpp:112:    if (cinfo->comps_in_scan != 1)
.//JPEG/jdphuff.cpp:115:  if (cinfo->Ah != 0) {
.//JPEG/jdphuff.cpp:116:    /* Successive approximation refinement scan: must have Al = Ah-1. */
.//JPEG/jdphuff.cpp:117:    if (cinfo->Al != cinfo->Ah-1)
.//JPEG/jdphuff.cpp:120:  if (cinfo->Al > 13)		/* need not check for < 0 */
.//JPEG/jdphuff.cpp:122:  /* Arguably the maximum Al value should be less than 13 for 8-bit precision,
.//JPEG/jdphuff.cpp:124:   * accept.  Note: large Al values could result in out-of-range DC
.//JPEG/jdphuff.cpp:130:	     cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
.//JPEG/jdphuff.cpp:132:   * Note that inter-scan inconsistencies are treated as warnings
.//JPEG/jdphuff.cpp:135:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jdphuff.cpp:136:    int cindex = cinfo->cur_comp_info[ci]->component_index;
.//JPEG/jdphuff.cpp:137:    coef_bit_ptr = & cinfo->coef_bits[cindex][0];
.//JPEG/jdphuff.cpp:140:    for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
.//JPEG/jdphuff.cpp:142:      if (cinfo->Ah != expected)
.//JPEG/jdphuff.cpp:144:      coef_bit_ptr[coefi] = cinfo->Al;
.//JPEG/jdphuff.cpp:149:  if (cinfo->Ah == 0) {
.//JPEG/jdphuff.cpp:151:      entropy->pub.decode_mcu = decode_mcu_DC_first;
.//JPEG/jdphuff.cpp:153:      entropy->pub.decode_mcu = decode_mcu_AC_first;
.//JPEG/jdphuff.cpp:156:      entropy->pub.decode_mcu = decode_mcu_DC_refine;
.//JPEG/jdphuff.cpp:158:      entropy->pub.decode_mcu = decode_mcu_AC_refine;
.//JPEG/jdphuff.cpp:161:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//JPEG/jdphuff.cpp:162:    compptr = cinfo->cur_comp_info[ci];
.//JPEG/jdphuff.cpp:167:      if (cinfo->Ah == 0) {	/* DC refinement needs no table */
.//JPEG/jdphuff.cpp:168:	tbl = compptr->dc_tbl_no;
.//JPEG/jdphuff.cpp:170:				& entropy->derived_tbls[tbl]);
.//JPEG/jdphuff.cpp:173:      tbl = compptr->ac_tbl_no;
.//JPEG/jdphuff.cpp:175:			      & entropy->derived_tbls[tbl]);
.//JPEG/jdphuff.cpp:177:      entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
.//JPEG/jdphuff.cpp:180:    entropy->saved.last_dc_val[ci] = 0;
.//JPEG/jdphuff.cpp:184:  entropy->bitstate.bits_left = 0;
.//JPEG/jdphuff.cpp:185:  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
.//JPEG/jdphuff.cpp:186:  entropy->pub.insufficient_data = FALSE;
.//JPEG/jdphuff.cpp:189:  entropy->saved.EOBRUN = 0;
.//JPEG/jdphuff.cpp:192:  entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jdphuff.cpp:203:#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))
.//JPEG/jdphuff.cpp:209:static const int extend_test[16] =   /* entry n is 2**(n-1) */
.//JPEG/jdphuff.cpp:213:static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
.//JPEG/jdphuff.cpp:214:  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
.//JPEG/jdphuff.cpp:215:    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
.//JPEG/jdphuff.cpp:216:    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
.//JPEG/jdphuff.cpp:217:    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };
.//JPEG/jdphuff.cpp:230:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jdphuff.cpp:235:  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
.//JPEG/jdphuff.cpp:236:  entropy->bitstate.bits_left = 0;
.//JPEG/jdphuff.cpp:239:  if (! (*cinfo->marker->read_restart_marker) (cinfo))
.//JPEG/jdphuff.cpp:242:  /* Re-initialize DC predictions to 0 */
.//JPEG/jdphuff.cpp:243:  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
.//JPEG/jdphuff.cpp:244:    entropy->saved.last_dc_val[ci] = 0;
.//JPEG/jdphuff.cpp:245:  /* Re-init EOB run count, too */
.//JPEG/jdphuff.cpp:246:  entropy->saved.EOBRUN = 0;
.//JPEG/jdphuff.cpp:249:  entropy->restarts_to_go = cinfo->restart_interval;
.//JPEG/jdphuff.cpp:251:  /* Reset out-of-data flag, unless read_restart_marker left us smack up
.//JPEG/jdphuff.cpp:256:  if (cinfo->unread_marker == 0)
.//JPEG/jdphuff.cpp:257:    entropy->pub.insufficient_data = FALSE;
.//JPEG/jdphuff.cpp:266: * Huffman-compressed coefficients. 
.//JPEG/jdphuff.cpp:276: * spectral selection, since we'll just re-assign them on the next call.
.//JPEG/jdphuff.cpp:288:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jdphuff.cpp:289:  int Al = cinfo->Al;
.//JPEG/jdphuff.cpp:299:  if (cinfo->restart_interval) {
.//JPEG/jdphuff.cpp:300:    if (entropy->restarts_to_go == 0)
.//JPEG/jdphuff.cpp:308:  if (! entropy->pub.insufficient_data) {
.//JPEG/jdphuff.cpp:311:    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
.//JPEG/jdphuff.cpp:312:    ASSIGN_STATE(state, entropy->saved);
.//JPEG/jdphuff.cpp:316:    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//JPEG/jdphuff.cpp:318:      ci = cinfo->MCU_membership[blkn];
.//JPEG/jdphuff.cpp:319:      compptr = cinfo->cur_comp_info[ci];
.//JPEG/jdphuff.cpp:320:      tbl = entropy->derived_tbls[compptr->dc_tbl_no];
.//JPEG/jdphuff.cpp:340:    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
.//JPEG/jdphuff.cpp:341:    ASSIGN_STATE(entropy->saved, state);
.//JPEG/jdphuff.cpp:344:  /* Account for restart interval (no-op if not using restarts) */
.//JPEG/jdphuff.cpp:345:  entropy->restarts_to_go--;
.//JPEG/jdphuff.cpp:359:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jdphuff.cpp:360:  int Se = cinfo->Se;
.//JPEG/jdphuff.cpp:361:  int Al = cinfo->Al;
.//JPEG/jdphuff.cpp:369:  if (cinfo->restart_interval) {
.//JPEG/jdphuff.cpp:370:    if (entropy->restarts_to_go == 0)
.//JPEG/jdphuff.cpp:378:  if (! entropy->pub.insufficient_data) {
.//JPEG/jdphuff.cpp:383:    EOBRUN = entropy->saved.EOBRUN;	/* only part of saved state we need */
.//JPEG/jdphuff.cpp:388:      EOBRUN--;			/* ...process it now (we do nothing) */
.//JPEG/jdphuff.cpp:390:      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
.//JPEG/jdphuff.cpp:392:      tbl = entropy->ac_derived_tbl;
.//JPEG/jdphuff.cpp:394:      for (k = cinfo->Ss; k <= Se; k++) {
.//JPEG/jdphuff.cpp:415:	    EOBRUN--;		/* this band is processed at this moment */
.//JPEG/jdphuff.cpp:416:	    break;		/* force end-of-band */
.//JPEG/jdphuff.cpp:421:      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
.//JPEG/jdphuff.cpp:425:    entropy->saved.EOBRUN = EOBRUN;	/* only part of saved state we need */
.//JPEG/jdphuff.cpp:428:  /* Account for restart interval (no-op if not using restarts) */
.//JPEG/jdphuff.cpp:429:  entropy->restarts_to_go--;
.//JPEG/jdphuff.cpp:437: * Note: we assume such scans can be multi-component, although the spec
.//JPEG/jdphuff.cpp:444:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jdphuff.cpp:445:  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
.//JPEG/jdphuff.cpp:451:  if (cinfo->restart_interval) {
.//JPEG/jdphuff.cpp:452:    if (entropy->restarts_to_go == 0)
.//JPEG/jdphuff.cpp:462:  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
.//JPEG/jdphuff.cpp:466:  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//JPEG/jdphuff.cpp:469:    /* Encoded data is simply the next bit of the two's-complement DC value */
.//JPEG/jdphuff.cpp:477:  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
.//JPEG/jdphuff.cpp:479:  /* Account for restart interval (no-op if not using restarts) */
.//JPEG/jdphuff.cpp:480:  entropy->restarts_to_go--;
.//JPEG/jdphuff.cpp:493:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//JPEG/jdphuff.cpp:494:  int Se = cinfo->Se;
.//JPEG/jdphuff.cpp:495:  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
.//JPEG/jdphuff.cpp:496:  int m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
.//JPEG/jdphuff.cpp:507:  if (cinfo->restart_interval) {
.//JPEG/jdphuff.cpp:508:    if (entropy->restarts_to_go == 0)
.//JPEG/jdphuff.cpp:515:  if (! entropy->pub.insufficient_data) {
.//JPEG/jdphuff.cpp:518:    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
.//JPEG/jdphuff.cpp:519:    EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */
.//JPEG/jdphuff.cpp:523:    tbl = entropy->ac_derived_tbl;
.//JPEG/jdphuff.cpp:528:     * But we need not undo addition of bits to already-nonzero coefficients;
.//JPEG/jdphuff.cpp:534:    k = cinfo->Ss;
.//JPEG/jdphuff.cpp:561:	/* Advance over already-nonzero coefs and r still-zero coefs,
.//JPEG/jdphuff.cpp:578:	    if (--r < 0)
.//JPEG/jdphuff.cpp:594:      /* Scan any remaining coefficient positions after the end-of-band
.//JPEG/jdphuff.cpp:596:       * bit to each already-nonzero coefficient.  A correction bit is 1
.//JPEG/jdphuff.cpp:614:      EOBRUN--;
.//JPEG/jdphuff.cpp:618:    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
.//JPEG/jdphuff.cpp:619:    entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */
.//JPEG/jdphuff.cpp:622:  /* Account for restart interval (no-op if not using restarts) */
.//JPEG/jdphuff.cpp:623:  entropy->restarts_to_go--;
.//JPEG/jdphuff.cpp:628:  /* Re-zero any output coefficients that we made newly nonzero */
.//JPEG/jdphuff.cpp:630:    (*block)[newnz_pos[--num_newnz]] = 0;
.//JPEG/jdphuff.cpp:648:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdphuff.cpp:650:  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
.//JPEG/jdphuff.cpp:651:  entropy->pub.start_pass = start_pass_phuff_decoder;
.//JPEG/jdphuff.cpp:655:    entropy->derived_tbls[i] = NULL;
.//JPEG/jdphuff.cpp:659:  cinfo->coef_bits = (int (*)[DCTSIZE2])
.//JPEG/jdphuff.cpp:660:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdphuff.cpp:661:				cinfo->num_components*DCTSIZE2*SIZEOF(int));
.//JPEG/jdphuff.cpp:662:  coef_bit_ptr = & cinfo->coef_bits[0][0];
.//JPEG/jdphuff.cpp:663:  for (ci = 0; ci < cinfo->num_components; ci++) 
.//JPEG/jdphuff.cpp:665:      *coef_bit_ptr++ = -1;
.//JPEG/jdpostct.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jdpostct.cpp:31:   * For two-pass color quantization, we need a full-image buffer;
.//JPEG/jdpostct.cpp:32:   * for one-pass operation, a strip buffer is sufficient.
.//JPEG/jdpostct.cpp:34:  jvirt_sarray_ptr whole_image;	/* virtual array, or NULL if one-pass */
.//JPEG/jdpostct.cpp:37:  /* for two-pass mode only: */
.//JPEG/jdpostct.cpp:75:  my_post_ptr post = (my_post_ptr) cinfo->post;
.//JPEG/jdpostct.cpp:79:    if (cinfo->quantize_colors) {
.//JPEG/jdpostct.cpp:80:      /* Single-pass processing with color quantization. */
.//JPEG/jdpostct.cpp:81:      post->pub.post_process_data = post_process_1pass;
.//JPEG/jdpostct.cpp:82:      /* We could be doing buffered-image output before starting a 2-pass
.//JPEG/jdpostct.cpp:84:       * allocate a strip buffer.  Use the virtual-array buffer as workspace.
.//JPEG/jdpostct.cpp:86:      if (post->buffer == NULL) {
.//JPEG/jdpostct.cpp:87:	post->buffer = (*cinfo->mem->access_virt_sarray)
.//JPEG/jdpostct.cpp:88:	  ((j_common_ptr) cinfo, post->whole_image,
.//JPEG/jdpostct.cpp:89:	   (JDIMENSION) 0, post->strip_height, TRUE);
.//JPEG/jdpostct.cpp:92:      /* For single-pass processing without color quantization,
.//JPEG/jdpostct.cpp:95:      post->pub.post_process_data = cinfo->upsample->upsample;
.//JPEG/jdpostct.cpp:100:    /* First pass of 2-pass quantization */
.//JPEG/jdpostct.cpp:101:    if (post->whole_image == NULL)
.//JPEG/jdpostct.cpp:103:    post->pub.post_process_data = post_process_prepass;
.//JPEG/jdpostct.cpp:106:    /* Second pass of 2-pass quantization */
.//JPEG/jdpostct.cpp:107:    if (post->whole_image == NULL)
.//JPEG/jdpostct.cpp:109:    post->pub.post_process_data = post_process_2pass;
.//JPEG/jdpostct.cpp:116:  post->starting_row = post->next_row = 0;
.//JPEG/jdpostct.cpp:121: * Process some data in the one-pass (strip buffer) case.
.//JPEG/jdpostct.cpp:122: * This is used for color precision reduction as well as one-pass quantization.
.//JPEG/jdpostct.cpp:132:  my_post_ptr post = (my_post_ptr) cinfo->post;
.//JPEG/jdpostct.cpp:137:  max_rows = out_rows_avail - *out_row_ctr;
.//JPEG/jdpostct.cpp:138:  if (max_rows > post->strip_height)
.//JPEG/jdpostct.cpp:139:    max_rows = post->strip_height;
.//JPEG/jdpostct.cpp:141:  (*cinfo->upsample->upsample) (cinfo,
.//JPEG/jdpostct.cpp:143:		post->buffer, &num_rows, max_rows);
.//JPEG/jdpostct.cpp:145:  (*cinfo->cquantize->color_quantize) (cinfo,
.//JPEG/jdpostct.cpp:146:		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
.//JPEG/jdpostct.cpp:154: * Process some data in the first pass of 2-pass quantization.
.//JPEG/jdpostct.cpp:164:  my_post_ptr post = (my_post_ptr) cinfo->post;
.//JPEG/jdpostct.cpp:168:  if (post->next_row == 0) {
.//JPEG/jdpostct.cpp:169:    post->buffer = (*cinfo->mem->access_virt_sarray)
.//JPEG/jdpostct.cpp:170:	((j_common_ptr) cinfo, post->whole_image,
.//JPEG/jdpostct.cpp:171:	 post->starting_row, post->strip_height, TRUE);
.//JPEG/jdpostct.cpp:175:  old_next_row = post->next_row;
.//JPEG/jdpostct.cpp:176:  (*cinfo->upsample->upsample) (cinfo,
.//JPEG/jdpostct.cpp:178:		post->buffer, &post->next_row, post->strip_height);
.//JPEG/jdpostct.cpp:182:  if (post->next_row > old_next_row) {
.//JPEG/jdpostct.cpp:183:    num_rows = post->next_row - old_next_row;
.//JPEG/jdpostct.cpp:184:    (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
.//JPEG/jdpostct.cpp:190:  if (post->next_row >= post->strip_height) {
.//JPEG/jdpostct.cpp:191:    post->starting_row += post->strip_height;
.//JPEG/jdpostct.cpp:192:    post->next_row = 0;
.//JPEG/jdpostct.cpp:198: * Process some data in the second pass of 2-pass quantization.
.//JPEG/jdpostct.cpp:208:  my_post_ptr post = (my_post_ptr) cinfo->post;
.//JPEG/jdpostct.cpp:212:  if (post->next_row == 0) {
.//JPEG/jdpostct.cpp:213:    post->buffer = (*cinfo->mem->access_virt_sarray)
.//JPEG/jdpostct.cpp:214:	((j_common_ptr) cinfo, post->whole_image,
.//JPEG/jdpostct.cpp:215:	 post->starting_row, post->strip_height, FALSE);
.//JPEG/jdpostct.cpp:219:  num_rows = post->strip_height - post->next_row; /* available in strip */
.//JPEG/jdpostct.cpp:220:  max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
.//JPEG/jdpostct.cpp:224:  max_rows = cinfo->output_height - post->starting_row;
.//JPEG/jdpostct.cpp:229:  (*cinfo->cquantize->color_quantize) (cinfo,
.//JPEG/jdpostct.cpp:230:		post->buffer + post->next_row, output_buf + *out_row_ctr,
.//JPEG/jdpostct.cpp:235:  post->next_row += num_rows;
.//JPEG/jdpostct.cpp:236:  if (post->next_row >= post->strip_height) {
.//JPEG/jdpostct.cpp:237:    post->starting_row += post->strip_height;
.//JPEG/jdpostct.cpp:238:    post->next_row = 0;
.//JPEG/jdpostct.cpp:255:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdpostct.cpp:257:  cinfo->post = (struct jpeg_d_post_controller *) post;
.//JPEG/jdpostct.cpp:258:  post->pub.start_pass = start_pass_dpost;
.//JPEG/jdpostct.cpp:259:  post->whole_image = NULL;	/* flag for no virtual arrays */
.//JPEG/jdpostct.cpp:260:  post->buffer = NULL;		/* flag for no strip buffer */
.//JPEG/jdpostct.cpp:263:  if (cinfo->quantize_colors) {
.//JPEG/jdpostct.cpp:268:    post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
.//JPEG/jdpostct.cpp:270:      /* Two-pass color quantization: need full-image storage. */
.//JPEG/jdpostct.cpp:273:      post->whole_image = (*cinfo->mem->request_virt_sarray)
.//JPEG/jdpostct.cpp:275:	 cinfo->output_width * cinfo->out_color_components,
.//JPEG/jdpostct.cpp:276:	 (JDIMENSION) jround_up((long) cinfo->output_height,
.//JPEG/jdpostct.cpp:277:				(long) post->strip_height),
.//JPEG/jdpostct.cpp:278:	 post->strip_height);
.//JPEG/jdpostct.cpp:283:      /* One-pass color quantization: just make a strip buffer. */
.//JPEG/jdpostct.cpp:284:      post->buffer = (*cinfo->mem->alloc_sarray)
.//JPEG/jdpostct.cpp:286:	 cinfo->output_width * cinfo->out_color_components,
.//JPEG/jdpostct.cpp:287:	 post->strip_height);
.//JPEG/jdsample.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//JPEG/jdsample.cpp:18: *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.
.//JPEG/jdsample.cpp:39:   * Note: we do not allocate any storage for component(s) which are full-size,
.//JPEG/jdsample.cpp:45:  /* Per-component upsampling method pointers */
.//JPEG/jdsample.cpp:71:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//JPEG/jdsample.cpp:74:  upsample->next_row_out = cinfo->max_v_samp_factor;
.//JPEG/jdsample.cpp:75:  /* Initialize total-height counter for detecting bottom of image */
.//JPEG/jdsample.cpp:76:  upsample->rows_to_go = cinfo->output_height;
.//JPEG/jdsample.cpp:95:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//JPEG/jdsample.cpp:101:  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
.//JPEG/jdsample.cpp:102:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdsample.cpp:104:      /* Invoke per-component upsample method.  Notice we pass a POINTER
.//JPEG/jdsample.cpp:107:      (*upsample->methods[ci]) (cinfo, compptr,
.//JPEG/jdsample.cpp:108:	input_buf[ci] + (*in_row_group_ctr * upsample->rowgroup_height[ci]),
.//JPEG/jdsample.cpp:109:	upsample->color_buf + ci);
.//JPEG/jdsample.cpp:111:    upsample->next_row_out = 0;
.//JPEG/jdsample.cpp:114:  /* Color-convert and emit rows */
.//JPEG/jdsample.cpp:117:  num_rows = (JDIMENSION) (cinfo->max_v_samp_factor - upsample->next_row_out);
.//JPEG/jdsample.cpp:121:  if (num_rows > upsample->rows_to_go) 
.//JPEG/jdsample.cpp:122:    num_rows = upsample->rows_to_go;
.//JPEG/jdsample.cpp:124:  out_rows_avail -= *out_row_ctr;
.//JPEG/jdsample.cpp:128:  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
.//JPEG/jdsample.cpp:129:				     (JDIMENSION) upsample->next_row_out,
.//JPEG/jdsample.cpp:135:  upsample->rows_to_go -= num_rows;
.//JPEG/jdsample.cpp:136:  upsample->next_row_out += num_rows;
.//JPEG/jdsample.cpp:138:  if (upsample->next_row_out >= cinfo->max_v_samp_factor)
.//JPEG/jdsample.cpp:150: * For full-size components, we just make color_buf[ci] point at the
.//JPEG/jdsample.cpp:165: * This is a no-op version used for "uninteresting" components.
.//JPEG/jdsample.cpp:182: * pixels.  The hi-falutin sampling literature refers to this as a
.//JPEG/jdsample.cpp:192:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//JPEG/jdsample.cpp:201:  h_expand = upsample->h_expand[compptr->component_index];
.//JPEG/jdsample.cpp:202:  v_expand = upsample->v_expand[compptr->component_index];
.//JPEG/jdsample.cpp:205:  while (outrow < cinfo->max_v_samp_factor) {
.//JPEG/jdsample.cpp:209:    outend = outptr + cinfo->output_width;
.//JPEG/jdsample.cpp:212:      for (h = h_expand; h > 0; h--) {
.//JPEG/jdsample.cpp:219:			v_expand-1, cinfo->output_width);
.//JPEG/jdsample.cpp:242:  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
.//JPEG/jdsample.cpp:245:    outend = outptr + cinfo->output_width;
.//JPEG/jdsample.cpp:271:  while (outrow < cinfo->max_v_samp_factor) {
.//JPEG/jdsample.cpp:274:    outend = outptr + cinfo->output_width;
.//JPEG/jdsample.cpp:281:		      1, cinfo->output_width);
.//JPEG/jdsample.cpp:313:  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
.//JPEG/jdsample.cpp:321:    for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
.//JPEG/jdsample.cpp:324:      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(inptr[-2]) + 1) >> 2);
.//JPEG/jdsample.cpp:330:    *outptr++ = (JSAMPLE) ((invalue * 3 + GETJSAMPLE(inptr[-1]) + 1) >> 2);
.//JPEG/jdsample.cpp:359:  while (outrow < cinfo->max_v_samp_factor) {
.//JPEG/jdsample.cpp:364:	inptr1 = input_data[inrow-1];
.//JPEG/jdsample.cpp:376:      for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
.//JPEG/jdsample.cpp:408:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jdsample.cpp:410:  cinfo->upsample = (struct jpeg_upsampler *) upsample;
.//JPEG/jdsample.cpp:411:  upsample->pub.start_pass = start_pass_upsample;
.//JPEG/jdsample.cpp:412:  upsample->pub.upsample = sep_upsample;
.//JPEG/jdsample.cpp:413:  upsample->pub.need_context_rows = FALSE; /* until we find out differently */
.//JPEG/jdsample.cpp:415:  if (cinfo->CCIR601_sampling)	/* this isn't supported */
.//JPEG/jdsample.cpp:421:  do_fancy = cinfo->do_fancy_upsampling && cinfo->min_DCT_scaled_size > 1;
.//JPEG/jdsample.cpp:423:  /* Verify we can handle the sampling factors, select per-component methods,
.//JPEG/jdsample.cpp:426:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//JPEG/jdsample.cpp:431:    h_in_group = (compptr->h_samp_factor * compptr->DCT_scaled_size) /
.//JPEG/jdsample.cpp:432:		 cinfo->min_DCT_scaled_size;
.//JPEG/jdsample.cpp:433:    v_in_group = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
.//JPEG/jdsample.cpp:434:		 cinfo->min_DCT_scaled_size;
.//JPEG/jdsample.cpp:435:    h_out_group = cinfo->max_h_samp_factor;
.//JPEG/jdsample.cpp:436:    v_out_group = cinfo->max_v_samp_factor;
.//JPEG/jdsample.cpp:437:    upsample->rowgroup_height[ci] = v_in_group; /* save for use later */
.//JPEG/jdsample.cpp:439:    if (! compptr->component_needed) {
.//JPEG/jdsample.cpp:441:      upsample->methods[ci] = noop_upsample;
.//JPEG/jdsample.cpp:445:      upsample->methods[ci] = fullsize_upsample;
.//JPEG/jdsample.cpp:450:      if (do_fancy && compptr->downsampled_width > 2)
.//JPEG/jdsample.cpp:451:	upsample->methods[ci] = h2v1_fancy_upsample;
.//JPEG/jdsample.cpp:453:	upsample->methods[ci] = h2v1_upsample;
.//JPEG/jdsample.cpp:457:      if (do_fancy && compptr->downsampled_width > 2) {
.//JPEG/jdsample.cpp:458:	upsample->methods[ci] = h2v2_fancy_upsample;
.//JPEG/jdsample.cpp:459:	upsample->pub.need_context_rows = TRUE;
.//JPEG/jdsample.cpp:461:	upsample->methods[ci] = h2v2_upsample;
.//JPEG/jdsample.cpp:464:      /* Generic integral-factors upsampling method */
.//JPEG/jdsample.cpp:465:      upsample->methods[ci] = int_upsample;
.//JPEG/jdsample.cpp:466:      upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);
.//JPEG/jdsample.cpp:467:      upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);
.//JPEG/jdsample.cpp:471:      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
.//JPEG/jdsample.cpp:473:	 (JDIMENSION) jround_up((long) cinfo->output_width,
.//JPEG/jdsample.cpp:474:				(long) cinfo->max_h_samp_factor),
.//JPEG/jdsample.cpp:475:	 (JDIMENSION) cinfo->max_v_samp_factor);
.//JPEG/jdtrans.cpp:4: * Copyright (C) 1995-1997, Thomas G. Lane.
.//JPEG/jdtrans.cpp:26: * The entire image is read into a set of virtual coefficient-block arrays,
.//JPEG/jdtrans.cpp:28: * virtual-array descriptors.  These can be manipulated directly via the
.//JPEG/jdtrans.cpp:34: * during a buffered-image-mode decompression operation.  This is allowed
.//JPEG/jdtrans.cpp:47:  if (cinfo->global_state == DSTATE_READY) {
.//JPEG/jdtrans.cpp:50:    cinfo->global_state = DSTATE_RDCOEFS;
.//JPEG/jdtrans.cpp:52:  if (cinfo->global_state == DSTATE_RDCOEFS) {
.//JPEG/jdtrans.cpp:57:      if (cinfo->progress != NULL)
.//JPEG/jdtrans.cpp:58:	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//JPEG/jdtrans.cpp:60:      retcode = (*cinfo->inputctl->consume_input) (cinfo);
.//JPEG/jdtrans.cpp:66:      if (cinfo->progress != NULL &&
.//JPEG/jdtrans.cpp:68:	if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
.//JPEG/jdtrans.cpp:70:	  cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
.//JPEG/jdtrans.cpp:75:    cinfo->global_state = DSTATE_STOPPING;
.//JPEG/jdtrans.cpp:79:   * to the coefficients during a full buffered-image-mode decompression.
.//JPEG/jdtrans.cpp:81:  if ((cinfo->global_state == DSTATE_STOPPING ||
.//JPEG/jdtrans.cpp:82:       cinfo->global_state == DSTATE_BUFIMAGE) && cinfo->buffered_image) {
.//JPEG/jdtrans.cpp:83:    return cinfo->coef->coef_arrays;
.//JPEG/jdtrans.cpp:86:  ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//JPEG/jdtrans.cpp:99:  /* This is effectively a buffered-image operation. */
.//JPEG/jdtrans.cpp:100:  cinfo->buffered_image = TRUE;
.//JPEG/jdtrans.cpp:103:  if (cinfo->arith_code) {
.//JPEG/jdtrans.cpp:106:    if (cinfo->progressive_mode) {
.//JPEG/jdtrans.cpp:116:  /* Always get a full-image coefficient buffer. */
.//JPEG/jdtrans.cpp:120:  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
.//JPEG/jdtrans.cpp:123:  (*cinfo->inputctl->start_input_pass) (cinfo);
.//JPEG/jdtrans.cpp:126:  if (cinfo->progress != NULL) {
.//JPEG/jdtrans.cpp:129:    if (cinfo->progressive_mode) {
.//JPEG/jdtrans.cpp:131:      nscans = 2 + 3 * cinfo->num_components;
.//JPEG/jdtrans.cpp:132:    } else if (cinfo->inputctl->has_multiple_scans) {
.//JPEG/jdtrans.cpp:134:      nscans = cinfo->num_components;
.//JPEG/jdtrans.cpp:138:    cinfo->progress->pass_counter = 0L;
.//JPEG/jdtrans.cpp:139:    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
.//JPEG/jdtrans.cpp:140:    cinfo->progress->completed_passes = 0;
.//JPEG/jdtrans.cpp:141:    cinfo->progress->total_passes = 1;
.//JPEG/jerror.cpp:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//JPEG/jerror.cpp:8: * This file contains simple error-reporting and trace-message routines.
.//JPEG/jerror.cpp:9: * These are suitable for Unix-like systems and others where writing to
.//JPEG/jerror.cpp:14: * you get a Windows-specific hack to display error messages in a dialog box.
.//JPEG/jerror.cpp:38: * We do this from the master message list in jerror.h by re-reading
.//JPEG/jerror.cpp:73:  (*cinfo->err->output_message) (cinfo);
.//JPEG/jerror.cpp:88: * so we provide optional code to produce an error-dialog popup.
.//JPEG/jerror.cpp:103:  (*cinfo->err->format_message) (cinfo, buffer);
.//JPEG/jerror.cpp:119: *   -1: recoverable corrupt-data warning, may want to abort.
.//JPEG/jerror.cpp:130:  struct jpeg_error_mgr * err = cinfo->err;
.//JPEG/jerror.cpp:137:    if (err->num_warnings == 0 || err->trace_level >= 3)
.//JPEG/jerror.cpp:138:      (*err->output_message) (cinfo);
.//JPEG/jerror.cpp:140:    err->num_warnings++;
.//JPEG/jerror.cpp:143:    if (err->trace_level >= msg_level)
.//JPEG/jerror.cpp:144:      (*err->output_message) (cinfo);
.//JPEG/jerror.cpp:159:  struct jpeg_error_mgr * err = cinfo->err;
.//JPEG/jerror.cpp:160:  int msg_code = err->msg_code;
.//JPEG/jerror.cpp:167:  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
.//JPEG/jerror.cpp:168:    msgtext = err->jpeg_message_table[msg_code];
.//JPEG/jerror.cpp:169:  } else if (err->addon_message_table != NULL &&
.//JPEG/jerror.cpp:170:	     msg_code >= err->first_addon_message &&
.//JPEG/jerror.cpp:171:	     msg_code <= err->last_addon_message) {
.//JPEG/jerror.cpp:172:    msgtext = err->addon_message_table[msg_code - err->first_addon_message];
.//JPEG/jerror.cpp:177:    err->msg_parm.i[0] = msg_code;
.//JPEG/jerror.cpp:178:    msgtext = err->jpeg_message_table[0];
.//JPEG/jerror.cpp:193:    sprintf(buffer, msgtext, err->msg_parm.s);
.//JPEG/jerror.cpp:196:	    err->msg_parm.i[0], err->msg_parm.i[1],
.//JPEG/jerror.cpp:197:	    err->msg_parm.i[2], err->msg_parm.i[3],
.//JPEG/jerror.cpp:198:	    err->msg_parm.i[4], err->msg_parm.i[5],
.//JPEG/jerror.cpp:199:	    err->msg_parm.i[6], err->msg_parm.i[7]);
.//JPEG/jerror.cpp:206: * processing to default state, without losing any application-specific
.//JPEG/jerror.cpp:214:  cinfo->err->num_warnings = 0;
.//JPEG/jerror.cpp:215:  /* trace_level is not reset since it is an application-supplied parameter */
.//JPEG/jerror.cpp:216:  cinfo->err->msg_code = 0;	/* may be useful as a flag for "no error" */
.//JPEG/jerror.cpp:221: * Fill in the standard error-handling methods in a jpeg_error_mgr object.
.//JPEG/jerror.cpp:233:  err->error_exit = error_exit;
.//JPEG/jerror.cpp:234:  err->emit_message = emit_message;
.//JPEG/jerror.cpp:235:  err->output_message = output_message;
.//JPEG/jerror.cpp:236:  err->format_message = format_message;
.//JPEG/jerror.cpp:237:  err->reset_error_mgr = reset_error_mgr;
.//JPEG/jerror.cpp:239:  err->trace_level = 0;		/* default = no tracing */
.//JPEG/jerror.cpp:240:  err->num_warnings = 0;	/* no warnings emitted yet */
.//JPEG/jerror.cpp:241:  err->msg_code = 0;		/* may be useful as a flag for "no error" */
.//JPEG/jerror.cpp:244:  err->jpeg_message_table = jpeg_std_message_table;
.//JPEG/jerror.cpp:245:  err->last_jpeg_message = (int) JMSG_LASTMSGCODE - 1;
.//JPEG/jerror.cpp:247:  err->addon_message_table = NULL;
.//JPEG/jerror.cpp:248:  err->first_addon_message = 0;	/* for safety */
.//JPEG/jerror.cpp:249:  err->last_addon_message = 0;
.//JPEG/jerror.h:4: * Copyright (C) 1994-1997, Thomas G. Lane.
.//JPEG/jerror.h:11: * A set of error-reporting macros are defined too.  Some applications using
.//JPEG/jerror.h:26:/* Repeated inclusions of this file are no-ops unless JMESSAGE is defined */
.//JPEG/jerror.h:83:JMESSAGE(JERR_FILE_WRITE, "Output file write error --- out of disk space?")
.//JPEG/jerror.h:115:	 "Write failed on temporary file --- out of disk space?")
.//JPEG/jerror.h:163:	 "JFIF extension marker: JPEG-compressed thumbnail image, length %u")
.//JPEG/jerror.h:194:/* Zap JMESSAGE macro so that future re-inclusions do nothing by default */
.//JPEG/jerror.h:206:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:207:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//JPEG/jerror.h:209:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:210:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//JPEG/jerror.h:211:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//JPEG/jerror.h:213:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:214:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//JPEG/jerror.h:215:   (cinfo)->err->msg_parm.i[1] = (p2), \
.//JPEG/jerror.h:216:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//JPEG/jerror.h:218:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:219:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//JPEG/jerror.h:220:   (cinfo)->err->msg_parm.i[1] = (p2), \
.//JPEG/jerror.h:221:   (cinfo)->err->msg_parm.i[2] = (p3), \
.//JPEG/jerror.h:222:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//JPEG/jerror.h:224:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:225:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//JPEG/jerror.h:226:   (cinfo)->err->msg_parm.i[1] = (p2), \
.//JPEG/jerror.h:227:   (cinfo)->err->msg_parm.i[2] = (p3), \
.//JPEG/jerror.h:228:   (cinfo)->err->msg_parm.i[3] = (p4), \
.//JPEG/jerror.h:229:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//JPEG/jerror.h:231:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:232:   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
.//JPEG/jerror.h:233:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//JPEG/jerror.h:239:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:240:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
.//JPEG/jerror.h:242:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:243:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//JPEG/jerror.h:244:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
.//JPEG/jerror.h:246:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:247:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//JPEG/jerror.h:248:   (cinfo)->err->msg_parm.i[1] = (p2), \
.//JPEG/jerror.h:249:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
.//JPEG/jerror.h:253:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:254:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
.//JPEG/jerror.h:256:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:257:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//JPEG/jerror.h:258:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
.//JPEG/jerror.h:260:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:261:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//JPEG/jerror.h:262:   (cinfo)->err->msg_parm.i[1] = (p2), \
.//JPEG/jerror.h:263:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
.//JPEG/jerror.h:265:  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
.//JPEG/jerror.h:267:	   (cinfo)->err->msg_code = (code); \
.//JPEG/jerror.h:268:	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
.//JPEG/jerror.h:270:  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
.//JPEG/jerror.h:272:	   (cinfo)->err->msg_code = (code); \
.//JPEG/jerror.h:273:	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
.//JPEG/jerror.h:275:  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
.//JPEG/jerror.h:278:	   (cinfo)->err->msg_code = (code); \
.//JPEG/jerror.h:279:	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
.//JPEG/jerror.h:281:  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
.//JPEG/jerror.h:284:	   (cinfo)->err->msg_code = (code); \
.//JPEG/jerror.h:285:	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
.//JPEG/jerror.h:287:  ((cinfo)->err->msg_code = (code), \
.//JPEG/jerror.h:288:   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
.//JPEG/jerror.h:289:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
.//JPEG/jfdctflt.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jfdctflt.cpp:8: * This file contains a floating-point implementation of the
.//JPEG/jfdctflt.cpp:16: * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
.//JPEG/jfdctflt.cpp:21: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
.//JPEG/jfdctflt.cpp:24: * is based directly on figure 4-8 in P&M.
.//JPEG/jfdctflt.cpp:25: * While an 8-point DCT cannot be done in less than 11 multiplies, it is
.//JPEG/jfdctflt.cpp:31: * The primary disadvantage of this method is that with a fixed-point
.//JPEG/jfdctflt.cpp:70:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//JPEG/jfdctflt.cpp:72:    tmp7 = dataptr[0] - dataptr[7];
.//JPEG/jfdctflt.cpp:74:    tmp6 = dataptr[1] - dataptr[6];
.//JPEG/jfdctflt.cpp:76:    tmp5 = dataptr[2] - dataptr[5];
.//JPEG/jfdctflt.cpp:78:    tmp4 = dataptr[3] - dataptr[4];
.//JPEG/jfdctflt.cpp:83:    tmp13 = tmp0 - tmp3;
.//JPEG/jfdctflt.cpp:85:    tmp12 = tmp1 - tmp2;
.//JPEG/jfdctflt.cpp:88:    dataptr[4] = tmp10 - tmp11;
.//JPEG/jfdctflt.cpp:92:    dataptr[6] = tmp13 - z1;
.//JPEG/jfdctflt.cpp:100:    /* The rotator is modified from fig 4-8 to avoid extra negations. */
.//JPEG/jfdctflt.cpp:101:    z5 = (tmp10 - tmp12) * ((FAST_FLOAT) 0.382683433); /* c6 */
.//JPEG/jfdctflt.cpp:102:    z2 = ((FAST_FLOAT) 0.541196100) * tmp10 + z5; /* c2-c6 */
.//JPEG/jfdctflt.cpp:107:    z13 = tmp7 - z3;
.//JPEG/jfdctflt.cpp:110:    dataptr[3] = z13 - z2;
.//JPEG/jfdctflt.cpp:112:    dataptr[7] = z11 - z4;
.//JPEG/jfdctflt.cpp:120:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//JPEG/jfdctflt.cpp:122:    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];
.//JPEG/jfdctflt.cpp:124:    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];
.//JPEG/jfdctflt.cpp:126:    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];
.//JPEG/jfdctflt.cpp:128:    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];
.//JPEG/jfdctflt.cpp:133:    tmp13 = tmp0 - tmp3;
.//JPEG/jfdctflt.cpp:135:    tmp12 = tmp1 - tmp2;
.//JPEG/jfdctflt.cpp:138:    dataptr[DCTSIZE*4] = tmp10 - tmp11;
.//JPEG/jfdctflt.cpp:142:    dataptr[DCTSIZE*6] = tmp13 - z1;
.//JPEG/jfdctflt.cpp:150:    /* The rotator is modified from fig 4-8 to avoid extra negations. */
.//JPEG/jfdctflt.cpp:151:    z5 = (tmp10 - tmp12) * ((FAST_FLOAT) 0.382683433); /* c6 */
.//JPEG/jfdctflt.cpp:152:    z2 = ((FAST_FLOAT) 0.541196100) * tmp10 + z5; /* c2-c6 */
.//JPEG/jfdctflt.cpp:157:    z13 = tmp7 - z3;
.//JPEG/jfdctflt.cpp:160:    dataptr[DCTSIZE*3] = z13 - z2;
.//JPEG/jfdctflt.cpp:162:    dataptr[DCTSIZE*7] = z11 - z4;
.//JPEG/jfdctfst.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//JPEG/jfdctfst.cpp:11: * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
.//JPEG/jfdctfst.cpp:16: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
.//JPEG/jfdctfst.cpp:19: * is based directly on figure 4-8 in P&M.
.//JPEG/jfdctfst.cpp:20: * While an 8-point DCT cannot be done in less than 11 multiplies, it is
.//JPEG/jfdctfst.cpp:26: * The primary disadvantage of this method is that with fixed-point math,
.//JPEG/jfdctfst.cpp:29: * precise the scaled value, so this implementation does worse with high-
.//JPEG/jfdctfst.cpp:30: * quality-setting files than with low-quality ones.
.//JPEG/jfdctfst.cpp:55: * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
.//JPEG/jfdctfst.cpp:57: * of work on 16-bit-int machines.
.//JPEG/jfdctfst.cpp:65: * are fewer one-bits in the constants).
.//JPEG/jfdctfst.cpp:72: * causing a lot of useless floating-point operations at run time.
.//JPEG/jfdctfst.cpp:73: * To get around this we use the following pre-calculated constants.
.//JPEG/jfdctfst.cpp:126:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//JPEG/jfdctfst.cpp:128:    tmp7 = dataptr[0] - dataptr[7];
.//JPEG/jfdctfst.cpp:130:    tmp6 = dataptr[1] - dataptr[6];
.//JPEG/jfdctfst.cpp:132:    tmp5 = dataptr[2] - dataptr[5];
.//JPEG/jfdctfst.cpp:134:    tmp4 = dataptr[3] - dataptr[4];
.//JPEG/jfdctfst.cpp:139:    tmp13 = tmp0 - tmp3;
.//JPEG/jfdctfst.cpp:141:    tmp12 = tmp1 - tmp2;
.//JPEG/jfdctfst.cpp:144:    dataptr[4] = tmp10 - tmp11;
.//JPEG/jfdctfst.cpp:148:    dataptr[6] = tmp13 - z1;
.//JPEG/jfdctfst.cpp:156:    /* The rotator is modified from fig 4-8 to avoid extra negations. */
.//JPEG/jfdctfst.cpp:157:    z5 = MULTIPLY(tmp10 - tmp12, FIX_0_382683433); /* c6 */
.//JPEG/jfdctfst.cpp:158:    z2 = MULTIPLY(tmp10, FIX_0_541196100) + z5; /* c2-c6 */
.//JPEG/jfdctfst.cpp:163:    z13 = tmp7 - z3;
.//JPEG/jfdctfst.cpp:166:    dataptr[3] = z13 - z2;
.//JPEG/jfdctfst.cpp:168:    dataptr[7] = z11 - z4;
.//JPEG/jfdctfst.cpp:176:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//JPEG/jfdctfst.cpp:178:    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];
.//JPEG/jfdctfst.cpp:180:    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];
.//JPEG/jfdctfst.cpp:182:    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];
.//JPEG/jfdctfst.cpp:184:    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];
.//JPEG/jfdctfst.cpp:189:    tmp13 = tmp0 - tmp3;
.//JPEG/jfdctfst.cpp:191:    tmp12 = tmp1 - tmp2;
.//JPEG/jfdctfst.cpp:194:    dataptr[DCTSIZE*4] = tmp10 - tmp11;
.//JPEG/jfdctfst.cpp:198:    dataptr[DCTSIZE*6] = tmp13 - z1;
.//JPEG/jfdctfst.cpp:206:    /* The rotator is modified from fig 4-8 to avoid extra negations. */
.//JPEG/jfdctfst.cpp:207:    z5 = MULTIPLY(tmp10 - tmp12, FIX_0_382683433); /* c6 */
.//JPEG/jfdctfst.cpp:208:    z2 = MULTIPLY(tmp10, FIX_0_541196100) + z5; /* c2-c6 */
.//JPEG/jfdctfst.cpp:213:    z13 = tmp7 - z3;
.//JPEG/jfdctfst.cpp:216:    dataptr[DCTSIZE*3] = z13 - z2;
.//JPEG/jfdctfst.cpp:218:    dataptr[DCTSIZE*7] = z11 - z4;
.//JPEG/jfdctint.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//JPEG/jfdctint.cpp:8: * This file contains a slow-but-accurate integer implementation of the
.//JPEG/jfdctint.cpp:11: * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
.//JPEG/jfdctint.cpp:16: *   C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
.//JPEG/jfdctint.cpp:18: *   Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
.//JPEG/jfdctint.cpp:23: * scaled fixed-point arithmetic, with a minimal number of shifts.
.//JPEG/jfdctint.cpp:46: * Each 1-D DCT step produces outputs which are a factor of sqrt(N)
.//JPEG/jfdctint.cpp:50: * this arrangement is that we save two multiplications per 1-D DCT,
.//JPEG/jfdctint.cpp:67: * they are represented to better-than-integral precision.  These outputs
.//JPEG/jfdctint.cpp:68: * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word
.//JPEG/jfdctint.cpp:69: * with the recommended scaling.  (For 12-bit sample data, the intermediate
.//JPEG/jfdctint.cpp:72: * To avoid overflow of the 32-bit intermediate results in pass 2, we must
.//JPEG/jfdctint.cpp:86: * causing a lot of useless floating-point operations at run time.
.//JPEG/jfdctint.cpp:87: * To get around this we use the following pre-calculated constants.
.//JPEG/jfdctint.cpp:122: * For 8-bit samples with the recommended scaling, all the variable
.//JPEG/jfdctint.cpp:124: * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.
.//JPEG/jfdctint.cpp:125: * For 12-bit samples, a full 32-bit multiplication will be needed.
.//JPEG/jfdctint.cpp:154:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//JPEG/jfdctint.cpp:156:    tmp7 = dataptr[0] - dataptr[7];
.//JPEG/jfdctint.cpp:158:    tmp6 = dataptr[1] - dataptr[6];
.//JPEG/jfdctint.cpp:160:    tmp5 = dataptr[2] - dataptr[5];
.//JPEG/jfdctint.cpp:162:    tmp4 = dataptr[3] - dataptr[4];
.//JPEG/jfdctint.cpp:164:    /* Even part per LL&M figure 1 --- note that published figure is faulty;
.//JPEG/jfdctint.cpp:169:    tmp13 = tmp0 - tmp3;
.//JPEG/jfdctint.cpp:171:    tmp12 = tmp1 - tmp2;
.//JPEG/jfdctint.cpp:174:    dataptr[4] = (DCTELEM) ((tmp10 - tmp11) << PASS1_BITS);
.//JPEG/jfdctint.cpp:178:				   CONST_BITS-PASS1_BITS);
.//JPEG/jfdctint.cpp:179:    dataptr[6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),
.//JPEG/jfdctint.cpp:180:				   CONST_BITS-PASS1_BITS);
.//JPEG/jfdctint.cpp:182:    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).
.//JPEG/jfdctint.cpp:193:    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
.//JPEG/jfdctint.cpp:194:    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
.//JPEG/jfdctint.cpp:195:    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
.//JPEG/jfdctint.cpp:196:    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
.//JPEG/jfdctint.cpp:197:    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
.//JPEG/jfdctint.cpp:198:    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
.//JPEG/jfdctint.cpp:199:    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
.//JPEG/jfdctint.cpp:200:    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
.//JPEG/jfdctint.cpp:205:    dataptr[7] = (DCTELEM) DESCALE(tmp4 + z1 + z3, CONST_BITS-PASS1_BITS);
.//JPEG/jfdctint.cpp:206:    dataptr[5] = (DCTELEM) DESCALE(tmp5 + z2 + z4, CONST_BITS-PASS1_BITS);
.//JPEG/jfdctint.cpp:207:    dataptr[3] = (DCTELEM) DESCALE(tmp6 + z2 + z3, CONST_BITS-PASS1_BITS);
.//JPEG/jfdctint.cpp:208:    dataptr[1] = (DCTELEM) DESCALE(tmp7 + z1 + z4, CONST_BITS-PASS1_BITS);
.//JPEG/jfdctint.cpp:219:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//JPEG/jfdctint.cpp:221:    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];
.//JPEG/jfdctint.cpp:223:    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];
.//JPEG/jfdctint.cpp:225:    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];
.//JPEG/jfdctint.cpp:227:    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];
.//JPEG/jfdctint.cpp:229:    /* Even part per LL&M figure 1 --- note that published figure is faulty;
.//JPEG/jfdctint.cpp:234:    tmp13 = tmp0 - tmp3;
.//JPEG/jfdctint.cpp:236:    tmp12 = tmp1 - tmp2;
.//JPEG/jfdctint.cpp:239:    dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS);
.//JPEG/jfdctint.cpp:244:    dataptr[DCTSIZE*6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),
.//JPEG/jfdctint.cpp:247:    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).
.//JPEG/jfdctint.cpp:258:    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
.//JPEG/jfdctint.cpp:259:    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
.//JPEG/jfdctint.cpp:260:    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
.//JPEG/jfdctint.cpp:261:    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
.//JPEG/jfdctint.cpp:262:    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
.//JPEG/jfdctint.cpp:263:    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
.//JPEG/jfdctint.cpp:264:    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
.//JPEG/jfdctint.cpp:265:    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
.//JPEG/jidctflt.cpp:4: * Copyright (C) 1994-1998, Thomas G. Lane.
.//JPEG/jidctflt.cpp:8: * This file contains a floating-point implementation of the
.//JPEG/jidctflt.cpp:17: * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
.//JPEG/jidctflt.cpp:23: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
.//JPEG/jidctflt.cpp:26: * is based directly on figure 4-8 in P&M.
.//JPEG/jidctflt.cpp:27: * While an 8-point DCT cannot be done in less than 11 multiplies, it is
.//JPEG/jidctflt.cpp:33: * The primary disadvantage of this method is that with a fixed-point
.//JPEG/jidctflt.cpp:56:/* Dequantize a coefficient by multiplying it by the multiplier-table
.//JPEG/jidctflt.cpp:87:  quantptr = (FLOAT_MULT_TYPE *) compptr->dct_table;
.//JPEG/jidctflt.cpp:89:  for (ctr = DCTSIZE; ctr > 0; ctr--) {
.//JPEG/jidctflt.cpp:92:     * by short-circuiting the IDCT calculation for any column in which all
.//JPEG/jidctflt.cpp:129:    tmp11 = tmp0 - tmp2;
.//JPEG/jidctflt.cpp:131:    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
.//JPEG/jidctflt.cpp:132:    tmp12 = (tmp1 - tmp3) * ((FAST_FLOAT) 1.414213562) - tmp13; /* 2*c4 */
.//JPEG/jidctflt.cpp:135:    tmp3 = tmp10 - tmp13;
.//JPEG/jidctflt.cpp:137:    tmp2 = tmp11 - tmp12;
.//JPEG/jidctflt.cpp:147:    z10 = tmp6 - tmp5;
.//JPEG/jidctflt.cpp:149:    z12 = tmp4 - tmp7;
.//JPEG/jidctflt.cpp:152:    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562); /* 2*c4 */
.//JPEG/jidctflt.cpp:155:    tmp10 = ((FAST_FLOAT) 1.082392200) * z12 - z5; /* 2*(c2-c6) */
.//JPEG/jidctflt.cpp:156:    tmp12 = ((FAST_FLOAT) -2.613125930) * z10 + z5; /* -2*(c2+c6) */
.//JPEG/jidctflt.cpp:158:    tmp6 = tmp12 - tmp7;	/* phase 2 */
.//JPEG/jidctflt.cpp:159:    tmp5 = tmp11 - tmp6;
.//JPEG/jidctflt.cpp:163:    wsptr[DCTSIZE*7] = tmp0 - tmp7;
.//JPEG/jidctflt.cpp:165:    wsptr[DCTSIZE*6] = tmp1 - tmp6;
.//JPEG/jidctflt.cpp:167:    wsptr[DCTSIZE*5] = tmp2 - tmp5;
.//JPEG/jidctflt.cpp:169:    wsptr[DCTSIZE*3] = tmp3 - tmp4;
.//JPEG/jidctflt.cpp:191:    tmp11 = wsptr[0] - wsptr[4];
.//JPEG/jidctflt.cpp:194:    tmp12 = (wsptr[2] - wsptr[6]) * ((FAST_FLOAT) 1.414213562) - tmp13;
.//JPEG/jidctflt.cpp:197:    tmp3 = tmp10 - tmp13;
.//JPEG/jidctflt.cpp:199:    tmp2 = tmp11 - tmp12;
.//JPEG/jidctflt.cpp:204:    z10 = wsptr[5] - wsptr[3];
.//JPEG/jidctflt.cpp:206:    z12 = wsptr[1] - wsptr[7];
.//JPEG/jidctflt.cpp:209:    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562);
.//JPEG/jidctflt.cpp:212:    tmp10 = ((FAST_FLOAT) 1.082392200) * z12 - z5; /* 2*(c2-c6) */
.//JPEG/jidctflt.cpp:213:    tmp12 = ((FAST_FLOAT) -2.613125930) * z10 + z5; /* -2*(c2+c6) */
.//JPEG/jidctflt.cpp:215:    tmp6 = tmp12 - tmp7;
.//JPEG/jidctflt.cpp:216:    tmp5 = tmp11 - tmp6;
.//JPEG/jidctflt.cpp:219:    /* Final output stage: scale down by a factor of 8 and range-limit */
.//JPEG/jidctflt.cpp:223:    outptr[7] = range_limit[(int) DESCALE((INT32) (tmp0 - tmp7), 3)
.//JPEG/jidctflt.cpp:227:    outptr[6] = range_limit[(int) DESCALE((INT32) (tmp1 - tmp6), 3)
.//JPEG/jidctflt.cpp:231:    outptr[5] = range_limit[(int) DESCALE((INT32) (tmp2 - tmp5), 3)
.//JPEG/jidctflt.cpp:235:    outptr[3] = range_limit[(int) DESCALE((INT32) (tmp3 - tmp4), 3)
.//JPEG/jidctfst.cpp:4: * Copyright (C) 1994-1998, Thomas G. Lane.
.//JPEG/jidctfst.cpp:12: * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
.//JPEG/jidctfst.cpp:18: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
.//JPEG/jidctfst.cpp:21: * is based directly on figure 4-8 in P&M.
.//JPEG/jidctfst.cpp:22: * While an 8-point DCT cannot be done in less than 11 multiplies, it is
.//JPEG/jidctfst.cpp:28: * The primary disadvantage of this method is that with fixed-point math,
.//JPEG/jidctfst.cpp:31: * precise the scaled value, so this implementation does worse with high-
.//JPEG/jidctfst.cpp:32: * quality-setting files than with low-quality ones.
.//JPEG/jidctfst.cpp:57: * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
.//JPEG/jidctfst.cpp:59: * of work on 16-bit-int machines.
.//JPEG/jidctfst.cpp:64: * For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = PASS1_BITS so as to
.//JPEG/jidctfst.cpp:67: * For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,
.//JPEG/jidctfst.cpp:73: * are fewer one-bits in the constants).
.//JPEG/jidctfst.cpp:85: * causing a lot of useless floating-point operations at run time.
.//JPEG/jidctfst.cpp:86: * To get around this we use the following pre-calculated constants.
.//JPEG/jidctfst.cpp:122:/* Dequantize a coefficient by multiplying it by the multiplier-table
.//JPEG/jidctfst.cpp:123: * entry; produce a DCTELEM result.  For 8-bit data a 16x16->16
.//JPEG/jidctfst.cpp:124: * multiplication will do.  For 12-bit data, the multiplier table is
.//JPEG/jidctfst.cpp:125: * declared INT32, so a 32-bit multiply will be used.
.//JPEG/jidctfst.cpp:132:	DESCALE((coef)*(quantval), IFAST_SCALE_BITS-PASS1_BITS)
.//JPEG/jidctfst.cpp:149:     (ishift_temp >> (shft)) | ((~((DCTELEM) 0)) << (DCTELEMBITS-(shft))) : \
.//JPEG/jidctfst.cpp:157:#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT((x) + (1 << ((n)-1)), n))
.//JPEG/jidctfst.cpp:188:  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;
.//JPEG/jidctfst.cpp:190:  for (ctr = DCTSIZE; ctr > 0; ctr--) {
.//JPEG/jidctfst.cpp:193:     * by short-circuiting the IDCT calculation for any column in which all
.//JPEG/jidctfst.cpp:230:    tmp11 = tmp0 - tmp2;
.//JPEG/jidctfst.cpp:232:    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
.//JPEG/jidctfst.cpp:233:    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */
.//JPEG/jidctfst.cpp:236:    tmp3 = tmp10 - tmp13;
.//JPEG/jidctfst.cpp:238:    tmp2 = tmp11 - tmp12;
.//JPEG/jidctfst.cpp:248:    z10 = tmp6 - tmp5;
.//JPEG/jidctfst.cpp:250:    z12 = tmp4 - tmp7;
.//JPEG/jidctfst.cpp:253:    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */
.//JPEG/jidctfst.cpp:256:    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
.//JPEG/jidctfst.cpp:257:    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */
.//JPEG/jidctfst.cpp:259:    tmp6 = tmp12 - tmp7;	/* phase 2 */
.//JPEG/jidctfst.cpp:260:    tmp5 = tmp11 - tmp6;
.//JPEG/jidctfst.cpp:264:    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);
.//JPEG/jidctfst.cpp:266:    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);
.//JPEG/jidctfst.cpp:268:    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);
.//JPEG/jidctfst.cpp:270:    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);
.//JPEG/jidctfst.cpp:316:    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);
.//JPEG/jidctfst.cpp:319:    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)
.//JPEG/jidctfst.cpp:320:	    - tmp13;
.//JPEG/jidctfst.cpp:323:    tmp3 = tmp10 - tmp13;
.//JPEG/jidctfst.cpp:325:    tmp2 = tmp11 - tmp12;
.//JPEG/jidctfst.cpp:330:    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];
.//JPEG/jidctfst.cpp:332:    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];
.//JPEG/jidctfst.cpp:335:    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */
.//JPEG/jidctfst.cpp:338:    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
.//JPEG/jidctfst.cpp:339:    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */
.//JPEG/jidctfst.cpp:341:    tmp6 = tmp12 - tmp7;	/* phase 2 */
.//JPEG/jidctfst.cpp:342:    tmp5 = tmp11 - tmp6;
.//JPEG/jidctfst.cpp:345:    /* Final output stage: scale down by a factor of 8 and range-limit */
.//JPEG/jidctfst.cpp:349:    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)
.//JPEG/jidctfst.cpp:353:    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)
.//JPEG/jidctfst.cpp:357:    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)
.//JPEG/jidctfst.cpp:361:    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
.//JPEG/jidctint.cpp:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//JPEG/jidctint.cpp:8: * This file contains a slow-but-accurate integer implementation of the
.//JPEG/jidctint.cpp:12: * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
.//JPEG/jidctint.cpp:18: *   C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
.//JPEG/jidctint.cpp:20: *   Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
.//JPEG/jidctint.cpp:25: * scaled fixed-point arithmetic, with a minimal number of shifts.
.//JPEG/jidctint.cpp:48: * Each 1-D IDCT step produces outputs which are a factor of sqrt(N)
.//JPEG/jidctint.cpp:52: * this arrangement is that we save two multiplications per 1-D IDCT,
.//JPEG/jidctint.cpp:67: * they are represented to better-than-integral precision.  These outputs
.//JPEG/jidctint.cpp:68: * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word
.//JPEG/jidctint.cpp:69: * with the recommended scaling.  (To scale up 12-bit sample data further, an
.//JPEG/jidctint.cpp:72: * To avoid overflow of the 32-bit intermediate results in pass 2, we must
.//JPEG/jidctint.cpp:86: * causing a lot of useless floating-point operations at run time.
.//JPEG/jidctint.cpp:87: * To get around this we use the following pre-calculated constants.
.//JPEG/jidctint.cpp:122: * For 8-bit samples with the recommended scaling, all the variable
.//JPEG/jidctint.cpp:124: * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.
.//JPEG/jidctint.cpp:125: * For 12-bit samples, a full 32-bit multiplication will be needed.
.//JPEG/jidctint.cpp:135:/* Dequantize a coefficient by multiplying it by the multiplier-table
.//JPEG/jidctint.cpp:169:  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
.//JPEG/jidctint.cpp:171:  for (ctr = DCTSIZE; ctr > 0; ctr--) {
.//JPEG/jidctint.cpp:174:     * by short-circuiting the IDCT calculation for any column in which all
.//JPEG/jidctint.cpp:204:    /* The rotator is sqrt(2)*c(-6). */
.//JPEG/jidctint.cpp:210:    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
.//JPEG/jidctint.cpp:217:    tmp1 = (z2 - z3) << CONST_BITS;
.//JPEG/jidctint.cpp:220:    tmp13 = tmp0 - tmp3;
.//JPEG/jidctint.cpp:222:    tmp12 = tmp1 - tmp2;
.//JPEG/jidctint.cpp:239:    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
.//JPEG/jidctint.cpp:240:    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
.//JPEG/jidctint.cpp:241:    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
.//JPEG/jidctint.cpp:242:    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
.//JPEG/jidctint.cpp:243:    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
.//JPEG/jidctint.cpp:244:    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
.//JPEG/jidctint.cpp:245:    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
.//JPEG/jidctint.cpp:246:    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
.//JPEG/jidctint.cpp:258:    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
.//JPEG/jidctint.cpp:259:    wsptr[DCTSIZE*7] = (int) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
.//JPEG/jidctint.cpp:260:    wsptr[DCTSIZE*1] = (int) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
.//JPEG/jidctint.cpp:261:    wsptr[DCTSIZE*6] = (int) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
.//JPEG/jidctint.cpp:262:    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
.//JPEG/jidctint.cpp:263:    wsptr[DCTSIZE*5] = (int) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
.//JPEG/jidctint.cpp:264:    wsptr[DCTSIZE*3] = (int) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
.//JPEG/jidctint.cpp:265:    wsptr[DCTSIZE*4] = (int) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
.//JPEG/jidctint.cpp:309:    /* The rotator is sqrt(2)*c(-6). */
.//JPEG/jidctint.cpp:315:    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
.//JPEG/jidctint.cpp:319:    tmp1 = ((INT32) wsptr[0] - (INT32) wsptr[4]) << CONST_BITS;
.//JPEG/jidctint.cpp:322:    tmp13 = tmp0 - tmp3;
.//JPEG/jidctint.cpp:324:    tmp12 = tmp1 - tmp2;
.//JPEG/jidctint.cpp:341:    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
.//JPEG/jidctint.cpp:342:    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
.//JPEG/jidctint.cpp:343:    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
.//JPEG/jidctint.cpp:344:    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
.//JPEG/jidctint.cpp:345:    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
.//JPEG/jidctint.cpp:346:    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
.//JPEG/jidctint.cpp:347:    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
.//JPEG/jidctint.cpp:348:    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
.//JPEG/jidctint.cpp:363:    outptr[7] = range_limit[(int) DESCALE(tmp10 - tmp3,
.//JPEG/jidctint.cpp:369:    outptr[6] = range_limit[(int) DESCALE(tmp11 - tmp2,
.//JPEG/jidctint.cpp:375:    outptr[5] = range_limit[(int) DESCALE(tmp12 - tmp1,
.//JPEG/jidctint.cpp:381:    outptr[4] = range_limit[(int) DESCALE(tmp13 - tmp0,
.//JPEG/jidctred.cpp:4: * Copyright (C) 1994-1998, Thomas G. Lane.
.//JPEG/jidctred.cpp:8: * This file contains inverse-DCT routines that produce reduced-size output:
.//JPEG/jidctred.cpp:12: * algorithm used in jidctint.c.  We simply replace each 8-to-8 1-D IDCT step
.//JPEG/jidctred.cpp:13: * with an 8-to-4 step that produces the four averages of two adjacent outputs
.//JPEG/jidctred.cpp:14: * (or an 8-to-2 step producing two averages of four outputs, for 2x2 output).
.//JPEG/jidctred.cpp:51: * causing a lot of useless floating-point operations at run time.
.//JPEG/jidctred.cpp:52: * To get around this we use the following pre-calculated constants.
.//JPEG/jidctred.cpp:91: * For 8-bit samples with the recommended scaling, all the variable
.//JPEG/jidctred.cpp:93: * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.
.//JPEG/jidctred.cpp:94: * For 12-bit samples, a full 32-bit multiplication will be needed.
.//JPEG/jidctred.cpp:104:/* Dequantize a coefficient by multiplying it by the multiplier-table
.//JPEG/jidctred.cpp:114: * producing a reduced-size 4x4 output block.
.//JPEG/jidctred.cpp:136:  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
.//JPEG/jidctred.cpp:138:  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
.//JPEG/jidctred.cpp:140:    if (ctr == DCTSIZE-4)
.//JPEG/jidctred.cpp:164:    tmp2 = MULTIPLY(z2, FIX_1_847759065) + MULTIPLY(z3, - FIX_0_765366865);
.//JPEG/jidctred.cpp:167:    tmp12 = tmp0 - tmp2;
.//JPEG/jidctred.cpp:176:    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
.//JPEG/jidctred.cpp:178:	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
.//JPEG/jidctred.cpp:181:    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
.//JPEG/jidctred.cpp:182:	 + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */
.//JPEG/jidctred.cpp:183:	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
.//JPEG/jidctred.cpp:188:    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp2, CONST_BITS-PASS1_BITS+1);
.//JPEG/jidctred.cpp:189:    wsptr[DCTSIZE*3] = (int) DESCALE(tmp10 - tmp2, CONST_BITS-PASS1_BITS+1);
.//JPEG/jidctred.cpp:190:    wsptr[DCTSIZE*1] = (int) DESCALE(tmp12 + tmp0, CONST_BITS-PASS1_BITS+1);
.//JPEG/jidctred.cpp:191:    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 - tmp0, CONST_BITS-PASS1_BITS+1);
.//JPEG/jidctred.cpp:223:	 + MULTIPLY((INT32) wsptr[6], - FIX_0_765366865);
.//JPEG/jidctred.cpp:226:    tmp12 = tmp0 - tmp2;
.//JPEG/jidctred.cpp:235:    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
.//JPEG/jidctred.cpp:237:	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
.//JPEG/jidctred.cpp:240:    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
.//JPEG/jidctred.cpp:241:	 + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */
.//JPEG/jidctred.cpp:242:	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
.//JPEG/jidctred.cpp:250:    outptr[3] = range_limit[(int) DESCALE(tmp10 - tmp2,
.//JPEG/jidctred.cpp:256:    outptr[2] = range_limit[(int) DESCALE(tmp12 - tmp0,
.//JPEG/jidctred.cpp:267: * producing a reduced-size 2x2 output block.
.//JPEG/jidctred.cpp:288:  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
.//JPEG/jidctred.cpp:290:  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
.//JPEG/jidctred.cpp:292:    if (ctr == DCTSIZE-2 || ctr == DCTSIZE-4 || ctr == DCTSIZE-6)
.//JPEG/jidctred.cpp:313:    tmp0 = MULTIPLY(z1, - FIX_0_720959822); /* sqrt(2) * (c7-c5+c3-c1) */
.//JPEG/jidctred.cpp:315:    tmp0 += MULTIPLY(z1, FIX_0_850430095); /* sqrt(2) * (-c1+c3+c5+c7) */
.//JPEG/jidctred.cpp:317:    tmp0 += MULTIPLY(z1, - FIX_1_272758580); /* sqrt(2) * (-c1+c3-c5-c7) */
.//JPEG/jidctred.cpp:323:    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp0, CONST_BITS-PASS1_BITS+2);
.//JPEG/jidctred.cpp:324:    wsptr[DCTSIZE*1] = (int) DESCALE(tmp10 - tmp0, CONST_BITS-PASS1_BITS+2);
.//JPEG/jidctred.cpp:354:    tmp0 = MULTIPLY((INT32) wsptr[7], - FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */
.//JPEG/jidctred.cpp:355:	 + MULTIPLY((INT32) wsptr[5], FIX_0_850430095) /* sqrt(2) * (-c1+c3+c5+c7) */
.//JPEG/jidctred.cpp:356:	 + MULTIPLY((INT32) wsptr[3], - FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */
.//JPEG/jidctred.cpp:364:    outptr[1] = range_limit[(int) DESCALE(tmp10 - tmp0,
.//JPEG/jidctred.cpp:375: * producing a reduced-size 1x1 output block.
.//JPEG/jidctred.cpp:389:   * average pixel value, which is one-eighth of the DC coefficient.
.//JPEG/jidctred.cpp:391:  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
.//JPEG/jinclude.h:4: * Copyright (C) 1991-1994, Thomas G. Lane.
.//JPEG/jinclude.h:18:/* Include auto-config file to find out which system include files we need. */
.//JPEG/jinclude.h:25: * On an ANSI-conforming system it is sufficient to include <stddef.h>.
.//JPEG/jmemmgr.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jmemmgr.cpp:8: * This file contains the JPEG system-independent memory management
.//JPEG/jmemmgr.cpp:12: *   * pool-based allocation and freeing of memory;
.//JPEG/jmemmgr.cpp:17: * The separate system-dependent file provides the actual backing-storage
.//JPEG/jmemmgr.cpp:20: * This file is system-dependent in the sense that some of its functions
.//JPEG/jmemmgr.cpp:31:#include "jmemsys.h"		/* import the system-dependent declarations */
.//JPEG/jmemmgr.cpp:54: * Many machines require storage alignment: longs must start on 4-byte
.//JPEG/jmemmgr.cpp:55: * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()
.//JPEG/jmemmgr.cpp:56: * always returns pointers that are multiples of the worst-case alignment
.//JPEG/jmemmgr.cpp:58: * There isn't any really portable way to determine the worst-case alignment
.//JPEG/jmemmgr.cpp:62: * workstations (where doubles really do need 8-byte alignment) and will work
.//JPEG/jmemmgr.cpp:66: * 680x0 compilers that define double as a 10-byte IEEE extended float.
.//JPEG/jmemmgr.cpp:67: * Doing 10-byte alignment is counterproductive because longwords won't be
.//JPEG/jmemmgr.cpp:79: * request to jpeg_get_small() or jpeg_get_large().  There is no per-object
.//JPEG/jmemmgr.cpp:126:   * in the small-pool list.
.//JPEG/jmemmgr.cpp:146: * System-dependent info for the associated backing store (if any) is hidden
.//JPEG/jmemmgr.cpp:151:  JSAMPARRAY mem_buffer;	/* => the in-memory buffer */
.//JPEG/jmemmgr.cpp:159:  boolean pre_zero;		/* pre-zero mode requested? */
.//JPEG/jmemmgr.cpp:161:  boolean b_s_open;		/* is backing-store data valid? */
.//JPEG/jmemmgr.cpp:163:  backing_store_info b_s_info;	/* System-dependent control info */
.//JPEG/jmemmgr.cpp:167:  JBLOCKARRAY mem_buffer;	/* => the in-memory buffer */
.//JPEG/jmemmgr.cpp:175:  boolean pre_zero;		/* pre-zero mode requested? */
.//JPEG/jmemmgr.cpp:177:  boolean b_s_open;		/* is backing-store data valid? */
.//JPEG/jmemmgr.cpp:179:  backing_store_info b_s_info;	/* System-dependent control info */
.//JPEG/jmemmgr.cpp:188:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//JPEG/jmemmgr.cpp:197:	  pool_id, mem->total_space_allocated);
.//JPEG/jmemmgr.cpp:199:  for (lhdr_ptr = mem->large_list[pool_id]; lhdr_ptr != NULL;
.//JPEG/jmemmgr.cpp:200:       lhdr_ptr = lhdr_ptr->hdr.next) {
.//JPEG/jmemmgr.cpp:202:	    (long) lhdr_ptr->hdr.bytes_used);
.//JPEG/jmemmgr.cpp:205:  for (shdr_ptr = mem->small_list[pool_id]; shdr_ptr != NULL;
.//JPEG/jmemmgr.cpp:206:       shdr_ptr = shdr_ptr->hdr.next) {
.//JPEG/jmemmgr.cpp:208:	    (long) shdr_ptr->hdr.bytes_used,
.//JPEG/jmemmgr.cpp:209:	    (long) shdr_ptr->hdr.bytes_left);
.//JPEG/jmemmgr.cpp:218:/* Report an out-of-memory error and stop execution */
.//JPEG/jmemmgr.cpp:222:  cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
.//JPEG/jmemmgr.cpp:237: * NOTE: the values given work fairly well on both 16- and 32-bit-int
.//JPEG/jmemmgr.cpp:260:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//JPEG/jmemmgr.cpp:266:  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
.//JPEG/jmemmgr.cpp:272:    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
.//JPEG/jmemmgr.cpp:278:  hdr_ptr = mem->small_list[pool_id];
.//JPEG/jmemmgr.cpp:280:    if (hdr_ptr->hdr.bytes_left >= sizeofobject)
.//JPEG/jmemmgr.cpp:283:    hdr_ptr = hdr_ptr->hdr.next;
.//JPEG/jmemmgr.cpp:295:    if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
.//JPEG/jmemmgr.cpp:296:      slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
.//JPEG/jmemmgr.cpp:306:    mem->total_space_allocated += min_request + slop;
.//JPEG/jmemmgr.cpp:308:    hdr_ptr->hdr.next = NULL;
.//JPEG/jmemmgr.cpp:309:    hdr_ptr->hdr.bytes_used = 0;
.//JPEG/jmemmgr.cpp:310:    hdr_ptr->hdr.bytes_left = sizeofobject + slop;
.//JPEG/jmemmgr.cpp:312:      mem->small_list[pool_id] = hdr_ptr;
.//JPEG/jmemmgr.cpp:314:      prev_hdr_ptr->hdr.next = hdr_ptr;
.//JPEG/jmemmgr.cpp:319:  data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
.//JPEG/jmemmgr.cpp:320:  hdr_ptr->hdr.bytes_used += sizeofobject;
.//JPEG/jmemmgr.cpp:321:  hdr_ptr->hdr.bytes_left -= sizeofobject;
.//JPEG/jmemmgr.cpp:345:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//JPEG/jmemmgr.cpp:350:  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
.//JPEG/jmemmgr.cpp:356:    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
.//JPEG/jmemmgr.cpp:366:  mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
.//JPEG/jmemmgr.cpp:369:  hdr_ptr->hdr.next = mem->large_list[pool_id];
.//JPEG/jmemmgr.cpp:373:  hdr_ptr->hdr.bytes_used = sizeofobject;
.//JPEG/jmemmgr.cpp:374:  hdr_ptr->hdr.bytes_left = 0;
.//JPEG/jmemmgr.cpp:375:  mem->large_list[pool_id] = hdr_ptr;
.//JPEG/jmemmgr.cpp:382: * Creation of 2-D sample arrays.
.//JPEG/jmemmgr.cpp:397:/* Allocate a 2-D sample array */
.//JPEG/jmemmgr.cpp:399:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//JPEG/jmemmgr.cpp:406:  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
.//JPEG/jmemmgr.cpp:414:  mem->last_rowsperchunk = rowsperchunk;
.//JPEG/jmemmgr.cpp:423:    rowsperchunk = MIN(rowsperchunk, numrows - currow);
.//JPEG/jmemmgr.cpp:427:    for (i = rowsperchunk; i > 0; i--) {
.//JPEG/jmemmgr.cpp:438: * Creation of 2-D coefficient-block arrays.
.//JPEG/jmemmgr.cpp:445:/* Allocate a 2-D coefficient-block array */
.//JPEG/jmemmgr.cpp:447:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//JPEG/jmemmgr.cpp:454:  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
.//JPEG/jmemmgr.cpp:462:  mem->last_rowsperchunk = rowsperchunk;
.//JPEG/jmemmgr.cpp:471:    rowsperchunk = MIN(rowsperchunk, numrows - currow);
.//JPEG/jmemmgr.cpp:475:    for (i = rowsperchunk; i > 0; i--) {
.//JPEG/jmemmgr.cpp:489: * (as wide as the image, but just a few rows high).  Full-image-sized buffers
.//JPEG/jmemmgr.cpp:497: * the maximum number of rows that will be accessed at once.  The in-memory
.//JPEG/jmemmgr.cpp:500: * The request routines create control blocks but not the in-memory buffers.
.//JPEG/jmemmgr.cpp:508: * the accessed strip; during a read-only pass this saves having to rewrite
.//JPEG/jmemmgr.cpp:509: * data to disk.  The access routines are also responsible for pre-zeroing
.//JPEG/jmemmgr.cpp:510: * any newly accessed rows, if pre-zeroing was requested.
.//JPEG/jmemmgr.cpp:515: * buffer dump/reload logic, by making the in-memory buffer be a multiple
.//JPEG/jmemmgr.cpp:526:/* Request a virtual 2-D sample array */
.//JPEG/jmemmgr.cpp:528:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//JPEG/jmemmgr.cpp:531:  /* Only IMAGE-lifetime virtual arrays are currently supported */
.//JPEG/jmemmgr.cpp:539:  result->mem_buffer = NULL;	/* marks array not yet realized */
.//JPEG/jmemmgr.cpp:540:  result->rows_in_array = numrows;
.//JPEG/jmemmgr.cpp:541:  result->samplesperrow = samplesperrow;
.//JPEG/jmemmgr.cpp:542:  result->maxaccess = maxaccess;
.//JPEG/jmemmgr.cpp:543:  result->pre_zero = pre_zero;
.//JPEG/jmemmgr.cpp:544:  result->b_s_open = FALSE;	/* no associated backing-store object */
.//JPEG/jmemmgr.cpp:545:  result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
.//JPEG/jmemmgr.cpp:546:  mem->virt_sarray_list = result;
.//JPEG/jmemmgr.cpp:556:/* Request a virtual 2-D coefficient-block array */
.//JPEG/jmemmgr.cpp:558:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//JPEG/jmemmgr.cpp:561:  /* Only IMAGE-lifetime virtual arrays are currently supported */
.//JPEG/jmemmgr.cpp:569:  result->mem_buffer = NULL;	/* marks array not yet realized */
.//JPEG/jmemmgr.cpp:570:  result->rows_in_array = numrows;
.//JPEG/jmemmgr.cpp:571:  result->blocksperrow = blocksperrow;
.//JPEG/jmemmgr.cpp:572:  result->maxaccess = maxaccess;
.//JPEG/jmemmgr.cpp:573:  result->pre_zero = pre_zero;
.//JPEG/jmemmgr.cpp:574:  result->b_s_open = FALSE;	/* no associated backing-store object */
.//JPEG/jmemmgr.cpp:575:  result->next = mem->virt_barray_list; /* add to list of virtual arrays */
.//JPEG/jmemmgr.cpp:576:  mem->virt_barray_list = result;
.//JPEG/jmemmgr.cpp:584:/* Allocate the in-memory buffers for any unrealized virtual arrays */
.//JPEG/jmemmgr.cpp:586:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//JPEG/jmemmgr.cpp:594:   * These may be of use to the system-dependent jpeg_mem_available routine.
.//JPEG/jmemmgr.cpp:598:  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
.//JPEG/jmemmgr.cpp:599:    if (sptr->mem_buffer == NULL) { /* if not realized yet */
.//JPEG/jmemmgr.cpp:600:      space_per_minheight += (long) sptr->maxaccess *
.//JPEG/jmemmgr.cpp:601:			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
.//JPEG/jmemmgr.cpp:602:      maximum_space += (long) sptr->rows_in_array *
.//JPEG/jmemmgr.cpp:603:		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
.//JPEG/jmemmgr.cpp:606:  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
.//JPEG/jmemmgr.cpp:607:    if (bptr->mem_buffer == NULL) { /* if not realized yet */
.//JPEG/jmemmgr.cpp:608:      space_per_minheight += (long) bptr->maxaccess *
.//JPEG/jmemmgr.cpp:609:			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
.//JPEG/jmemmgr.cpp:610:      maximum_space += (long) bptr->rows_in_array *
.//JPEG/jmemmgr.cpp:611:		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
.//JPEG/jmemmgr.cpp:618:  /* Determine amount of memory to actually use; this is system-dependent. */
.//JPEG/jmemmgr.cpp:620:				 mem->total_space_allocated);
.//JPEG/jmemmgr.cpp:637:  /* Allocate the in-memory buffers and initialize backing store as needed. */
.//JPEG/jmemmgr.cpp:639:  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
.//JPEG/jmemmgr.cpp:640:    if (sptr->mem_buffer == NULL) { /* if not realized yet */
.//JPEG/jmemmgr.cpp:641:      minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
.//JPEG/jmemmgr.cpp:644:	sptr->rows_in_mem = sptr->rows_in_array;
.//JPEG/jmemmgr.cpp:647:	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
.//JPEG/jmemmgr.cpp:648:	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
.//JPEG/jmemmgr.cpp:649:				(long) sptr->rows_in_array *
.//JPEG/jmemmgr.cpp:650:				(long) sptr->samplesperrow *
.//JPEG/jmemmgr.cpp:652:	sptr->b_s_open = TRUE;
.//JPEG/jmemmgr.cpp:654:      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
.//JPEG/jmemmgr.cpp:655:				      sptr->samplesperrow, sptr->rows_in_mem);
.//JPEG/jmemmgr.cpp:656:      sptr->rowsperchunk = mem->last_rowsperchunk;
.//JPEG/jmemmgr.cpp:657:      sptr->cur_start_row = 0;
.//JPEG/jmemmgr.cpp:658:      sptr->first_undef_row = 0;
.//JPEG/jmemmgr.cpp:659:      sptr->dirty = FALSE;
.//JPEG/jmemmgr.cpp:663:  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
.//JPEG/jmemmgr.cpp:664:    if (bptr->mem_buffer == NULL) { /* if not realized yet */
.//JPEG/jmemmgr.cpp:665:      minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
.//JPEG/jmemmgr.cpp:668:	bptr->rows_in_mem = bptr->rows_in_array;
.//JPEG/jmemmgr.cpp:671:	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
.//JPEG/jmemmgr.cpp:672:	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
.//JPEG/jmemmgr.cpp:673:				(long) bptr->rows_in_array *
.//JPEG/jmemmgr.cpp:674:				(long) bptr->blocksperrow *
.//JPEG/jmemmgr.cpp:676:	bptr->b_s_open = TRUE;
.//JPEG/jmemmgr.cpp:678:      bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
.//JPEG/jmemmgr.cpp:679:				      bptr->blocksperrow, bptr->rows_in_mem);
.//JPEG/jmemmgr.cpp:680:      bptr->rowsperchunk = mem->last_rowsperchunk;
.//JPEG/jmemmgr.cpp:681:      bptr->cur_start_row = 0;
.//JPEG/jmemmgr.cpp:682:      bptr->first_undef_row = 0;
.//JPEG/jmemmgr.cpp:683:      bptr->dirty = FALSE;
.//JPEG/jmemmgr.cpp:695:  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
.//JPEG/jmemmgr.cpp:696:  file_offset = ptr->cur_start_row * bytesperrow;
.//JPEG/jmemmgr.cpp:698:  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
.//JPEG/jmemmgr.cpp:700:    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
.//JPEG/jmemmgr.cpp:702:    thisrow = (long) ptr->cur_start_row + i;
.//JPEG/jmemmgr.cpp:703:    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
.//JPEG/jmemmgr.cpp:705:    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
.//JPEG/jmemmgr.cpp:710:      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
.//JPEG/jmemmgr.cpp:711:					    (void FAR *) ptr->mem_buffer[i],
.//JPEG/jmemmgr.cpp:714:      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
.//JPEG/jmemmgr.cpp:715:					   (void FAR *) ptr->mem_buffer[i],
.//JPEG/jmemmgr.cpp:724:/* Do backing store read or write of a virtual coefficient-block array */
.//JPEG/jmemmgr.cpp:728:  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
.//JPEG/jmemmgr.cpp:729:  file_offset = ptr->cur_start_row * bytesperrow;
.//JPEG/jmemmgr.cpp:731:  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
.//JPEG/jmemmgr.cpp:733:    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
.//JPEG/jmemmgr.cpp:735:    thisrow = (long) ptr->cur_start_row + i;
.//JPEG/jmemmgr.cpp:736:    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
.//JPEG/jmemmgr.cpp:738:    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
.//JPEG/jmemmgr.cpp:743:      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
.//JPEG/jmemmgr.cpp:744:					    (void FAR *) ptr->mem_buffer[i],
.//JPEG/jmemmgr.cpp:747:      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
.//JPEG/jmemmgr.cpp:748:					   (void FAR *) ptr->mem_buffer[i],
.//JPEG/jmemmgr.cpp:767:  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
.//JPEG/jmemmgr.cpp:768:      ptr->mem_buffer == NULL)
.//JPEG/jmemmgr.cpp:772:  if (start_row < ptr->cur_start_row ||
.//JPEG/jmemmgr.cpp:773:      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
.//JPEG/jmemmgr.cpp:774:    if (! ptr->b_s_open)
.//JPEG/jmemmgr.cpp:777:    if (ptr->dirty) {
.//JPEG/jmemmgr.cpp:779:      ptr->dirty = FALSE;
.//JPEG/jmemmgr.cpp:788:    if (start_row > ptr->cur_start_row) {
.//JPEG/jmemmgr.cpp:789:      ptr->cur_start_row = start_row;
.//JPEG/jmemmgr.cpp:794:      ltemp = (long) end_row - (long) ptr->rows_in_mem;
.//JPEG/jmemmgr.cpp:797:      ptr->cur_start_row = (JDIMENSION) ltemp;
.//JPEG/jmemmgr.cpp:807:   * that the caller is about to access, not the entire in-memory array.
.//JPEG/jmemmgr.cpp:809:  if (ptr->first_undef_row < end_row) {
.//JPEG/jmemmgr.cpp:810:    if (ptr->first_undef_row < start_row) {
.//JPEG/jmemmgr.cpp:815:      undef_row = ptr->first_undef_row;
.//JPEG/jmemmgr.cpp:818:      ptr->first_undef_row = end_row;
.//JPEG/jmemmgr.cpp:819:    if (ptr->pre_zero) {
.//JPEG/jmemmgr.cpp:820:      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
.//JPEG/jmemmgr.cpp:821:      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
.//JPEG/jmemmgr.cpp:822:      end_row -= ptr->cur_start_row;
.//JPEG/jmemmgr.cpp:824:	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
.//JPEG/jmemmgr.cpp:834:    ptr->dirty = TRUE;
.//JPEG/jmemmgr.cpp:836:  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
.//JPEG/jmemmgr.cpp:852:  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
.//JPEG/jmemmgr.cpp:853:      ptr->mem_buffer == NULL)
.//JPEG/jmemmgr.cpp:857:  if (start_row < ptr->cur_start_row ||
.//JPEG/jmemmgr.cpp:858:      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
.//JPEG/jmemmgr.cpp:859:    if (! ptr->b_s_open)
.//JPEG/jmemmgr.cpp:862:    if (ptr->dirty) {
.//JPEG/jmemmgr.cpp:864:      ptr->dirty = FALSE;
.//JPEG/jmemmgr.cpp:873:    if (start_row > ptr->cur_start_row) {
.//JPEG/jmemmgr.cpp:874:      ptr->cur_start_row = start_row;
.//JPEG/jmemmgr.cpp:879:      ltemp = (long) end_row - (long) ptr->rows_in_mem;
.//JPEG/jmemmgr.cpp:882:      ptr->cur_start_row = (JDIMENSION) ltemp;
.//JPEG/jmemmgr.cpp:892:   * that the caller is about to access, not the entire in-memory array.
.//JPEG/jmemmgr.cpp:894:  if (ptr->first_undef_row < end_row) {
.//JPEG/jmemmgr.cpp:895:    if (ptr->first_undef_row < start_row) {
.//JPEG/jmemmgr.cpp:900:      undef_row = ptr->first_undef_row;
.//JPEG/jmemmgr.cpp:903:      ptr->first_undef_row = end_row;
.//JPEG/jmemmgr.cpp:904:    if (ptr->pre_zero) {
.//JPEG/jmemmgr.cpp:905:      size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
.//JPEG/jmemmgr.cpp:906:      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
.//JPEG/jmemmgr.cpp:907:      end_row -= ptr->cur_start_row;
.//JPEG/jmemmgr.cpp:909:	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
.//JPEG/jmemmgr.cpp:919:    ptr->dirty = TRUE;
.//JPEG/jmemmgr.cpp:921:  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
.//JPEG/jmemmgr.cpp:932:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//JPEG/jmemmgr.cpp:941:  if (cinfo->err->trace_level > 1)
.//JPEG/jmemmgr.cpp:950:    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
.//JPEG/jmemmgr.cpp:951:      if (sptr->b_s_open) {	/* there may be no backing store */
.//JPEG/jmemmgr.cpp:952:	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
.//JPEG/jmemmgr.cpp:953:	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
.//JPEG/jmemmgr.cpp:956:    mem->virt_sarray_list = NULL;
.//JPEG/jmemmgr.cpp:957:    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
.//JPEG/jmemmgr.cpp:958:      if (bptr->b_s_open) {	/* there may be no backing store */
.//JPEG/jmemmgr.cpp:959:	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
.//JPEG/jmemmgr.cpp:960:	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
.//JPEG/jmemmgr.cpp:963:    mem->virt_barray_list = NULL;
.//JPEG/jmemmgr.cpp:967:  lhdr_ptr = mem->large_list[pool_id];
.//JPEG/jmemmgr.cpp:968:  mem->large_list[pool_id] = NULL;
.//JPEG/jmemmgr.cpp:971:    large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
.//JPEG/jmemmgr.cpp:972:    space_freed = lhdr_ptr->hdr.bytes_used +
.//JPEG/jmemmgr.cpp:973:		  lhdr_ptr->hdr.bytes_left +
.//JPEG/jmemmgr.cpp:976:    mem->total_space_allocated -= space_freed;
.//JPEG/jmemmgr.cpp:981:  shdr_ptr = mem->small_list[pool_id];
.//JPEG/jmemmgr.cpp:982:  mem->small_list[pool_id] = NULL;
.//JPEG/jmemmgr.cpp:985:    small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
.//JPEG/jmemmgr.cpp:986:    space_freed = shdr_ptr->hdr.bytes_used +
.//JPEG/jmemmgr.cpp:987:		  shdr_ptr->hdr.bytes_left +
.//JPEG/jmemmgr.cpp:990:    mem->total_space_allocated -= space_freed;
.//JPEG/jmemmgr.cpp:998: * Note that this cannot be called unless cinfo->mem is non-NULL.
.//JPEG/jmemmgr.cpp:1008:   * with some (brain-damaged) malloc libraries.
.//JPEG/jmemmgr.cpp:1010:  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
.//JPEG/jmemmgr.cpp:1015:  jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
.//JPEG/jmemmgr.cpp:1016:  cinfo->mem = NULL;		/* ensures I will be called only once */
.//JPEG/jmemmgr.cpp:1018:  jpeg_mem_term(cinfo);		/* system-dependent cleanup */
.//JPEG/jmemmgr.cpp:1035:  cinfo->mem = NULL;		/* for safety if init fails */
.//JPEG/jmemmgr.cpp:1040:   * The test is a little tricky: for X>0, X and X-1 have no one-bits
.//JPEG/jmemmgr.cpp:1041:   * in common if and only if X is a power of 2, ie has only one one-bit.
.//JPEG/jmemmgr.cpp:1044:  if ((SIZEOF(ALIGN_TYPE) & (SIZEOF(ALIGN_TYPE)-1)) != 0)
.//JPEG/jmemmgr.cpp:1056:  max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
.//JPEG/jmemmgr.cpp:1062:    jpeg_mem_term(cinfo);	/* system-dependent cleanup */
.//JPEG/jmemmgr.cpp:1067:  mem->pub.alloc_small = alloc_small;
.//JPEG/jmemmgr.cpp:1068:  mem->pub.alloc_large = alloc_large;
.//JPEG/jmemmgr.cpp:1069:  mem->pub.alloc_sarray = alloc_sarray;
.//JPEG/jmemmgr.cpp:1070:  mem->pub.alloc_barray = alloc_barray;
.//JPEG/jmemmgr.cpp:1071:  mem->pub.request_virt_sarray = request_virt_sarray;
.//JPEG/jmemmgr.cpp:1072:  mem->pub.request_virt_barray = request_virt_barray;
.//JPEG/jmemmgr.cpp:1073:  mem->pub.realize_virt_arrays = realize_virt_arrays;
.//JPEG/jmemmgr.cpp:1074:  mem->pub.access_virt_sarray = access_virt_sarray;
.//JPEG/jmemmgr.cpp:1075:  mem->pub.access_virt_barray = access_virt_barray;
.//JPEG/jmemmgr.cpp:1076:  mem->pub.free_pool = free_pool;
.//JPEG/jmemmgr.cpp:1077:  mem->pub.self_destruct = self_destruct;
.//JPEG/jmemmgr.cpp:1080:  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
.//JPEG/jmemmgr.cpp:1083:  mem->pub.max_memory_to_use = max_to_use;
.//JPEG/jmemmgr.cpp:1085:  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
.//JPEG/jmemmgr.cpp:1086:    mem->small_list[pool] = NULL;
.//JPEG/jmemmgr.cpp:1087:    mem->large_list[pool] = NULL;
.//JPEG/jmemmgr.cpp:1089:  mem->virt_sarray_list = NULL;
.//JPEG/jmemmgr.cpp:1090:  mem->virt_barray_list = NULL;
.//JPEG/jmemmgr.cpp:1092:  mem->total_space_allocated = SIZEOF(my_memory_mgr);
.//JPEG/jmemmgr.cpp:1095:  cinfo->mem = & mem->pub;
.//JPEG/jmemmgr.cpp:1112:	mem->pub.max_memory_to_use = max_to_use * 1000L;
.//JPEG/jmemnobs.cpp:4: * Copyright (C) 1992-1996, Thomas G. Lane.
.//JPEG/jmemnobs.cpp:8: * This file provides a really simple implementation of the system-
.//JPEG/jmemnobs.cpp:10: * assumes that no backing-store files are needed: all required space
.//JPEG/jmemnobs.cpp:21:#include "jmemsys.h"		/* import the system-dependent declarations */
.//JPEG/jmemnobs.cpp:51: * you probably won't be able to process useful-size images in only 64KB.
.//JPEG/jmemnobs.cpp:95: * These routines take care of any system-dependent initialization and
.//JPEG/jmemsys.h:4: * Copyright (C) 1992-1997, Thomas G. Lane.
.//JPEG/jmemsys.h:8: * This include file defines the interface between the system-independent
.//JPEG/jmemsys.h:9: * and system-dependent portions of the JPEG memory manager.  No other
.//JPEG/jmemsys.h:10: * modules need include it.  (The system-independent portion is jmemmgr.c;
.//JPEG/jmemsys.h:11: * there are several different versions of the system-dependent portion.)
.//JPEG/jmemsys.h:13: * This file works as-is for the system-dependent memory managers supplied
.//JPEG/jmemsys.h:15: * custom memory manager.  If system-dependent changes are needed in
.//JPEG/jmemsys.h:22:/* Short forms of external names for systems with brain-damaged linkers. */
.//JPEG/jmemsys.h:44: * On an 80x86 machine using small-data memory model, these manage near heap.
.//JPEG/jmemsys.h:69: * to model the 64Kb-segment-size limit of far addressing on 80x86 machines.
.//JPEG/jmemsys.h:71: * On machines with 32-bit flat address spaces, any large constant may be used.
.//JPEG/jmemsys.h:91: * method is available, cinfo->mem->max_memory_to_use - already_allocated
.//JPEG/jmemsys.h:95: * (that'll just lead to more backing-store access than is really necessary).
.//JPEG/jmemsys.h:111: * backing-store object.  The read/write/close method pointers are called
.//JPEG/jmemsys.h:112: * by jmemmgr.c to manipulate the backing-store object; all other fields
.//JPEG/jmemsys.h:113: * are private to the system-dependent backing store routines.
.//JPEG/jmemsys.h:119:#ifdef USE_MSDOS_MEMMGR		/* DOS-specific junk */
.//JPEG/jmemsys.h:121:typedef unsigned short XMSH;	/* type of extended-memory handles */
.//JPEG/jmemsys.h:122:typedef unsigned short EMSH;	/* type of expanded-memory handles */
.//JPEG/jmemsys.h:132:#ifdef USE_MAC_MEMMGR		/* Mac-specific junk */
.//JPEG/jmemsys.h:140:  /* Methods for reading/writing/closing this backing-store object */
.//JPEG/jmemsys.h:152:  /* Private fields for system-dependent backing-store management */
.//JPEG/jmemsys.h:154:  /* For the MS-DOS manager (jmemdos.c), we need: */
.//JPEG/jmemsys.h:155:  handle_union handle;		/* reference to backing-store storage object */
.//JPEG/jmemsys.h:173: * Initial opening of a backing-store object.  This must fill in the
.//JPEG/jmemsys.h:186: * These routines take care of any system-dependent initialization and
.//JPEG/jmemsys.h:194: * all opened backing-store objects have been closed.
.//JPEG/jmorecfg.h:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jmorecfg.h:9: * JPEG software for special applications or support machine-dependent
.//JPEG/jmorecfg.h:16: *   8   for 8-bit sample values (the usual setting)
.//JPEG/jmorecfg.h:17: *   12  for 12-bit sample values
.//JPEG/jmorecfg.h:20: * We do not support run-time selection of data precision, sorry.
.//JPEG/jmorecfg.h:152:/* INT16 must hold at least the values -32768..32767. */
.//JPEG/jmorecfg.h:158:/* INT32 must hold at least signed 32-bit values. */
.//JPEG/jmorecfg.h:165: * images up to 64K*64K due to 16-bit fields in SOF markers.  Therefore
.//JPEG/jmorecfg.h:206:/* Here is the pseudo-keyword for declaring pointers that must be "far"
.//JPEG/jmorecfg.h:221: * in standard header files.  Or you may have conflicts with application-
.//JPEG/jmorecfg.h:265:#define DCT_FLOAT_SUPPORTED	/* floating-point: accurate, fast on fast HW */
.//JPEG/jmorecfg.h:270:#define C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
.//JPEG/jmorecfg.h:273:/* Note: if you selected 12-bit data precision, it is dangerous to turn off
.//JPEG/jmorecfg.h:274: * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit
.//JPEG/jmorecfg.h:286:#define D_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
.//JPEG/jmorecfg.h:293:#define QUANT_1PASS_SUPPORTED	    /* 1-pass color quantization? */
.//JPEG/jmorecfg.h:294:#define QUANT_2PASS_SUPPORTED	    /* 2-pass color quantization? */
.//JPEG/jmorecfg.h:320:/* Definitions for speed-related optimizations. */
.//JPEG/jmorecfg.h:338: * two 16-bit shorts is faster than multiplying two ints.  Define MULTIPLIER
.//JPEG/jmorecfg.h:351: * pre-ANSI compilers (because they insist on converting to double anyway).
.//JPEG/jmorecfg.h:352: * The code below therefore chooses float if we have ANSI-style prototypes.
.//JPEG/jpegint.h:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//JPEG/jpegint.h:18:	/* Remaining modes require a full-image buffer to have been created */
.//JPEG/jpegint.h:33:#define DSTATE_PRESCAN	204	/* performing dummy pass for 2-pass quant */
.//JPEG/jpegint.h:55:/* Main buffer control (downsampled-data buffer) */
.//JPEG/jpegint.h:142:  boolean is_dummy_pass;	/* True during 1st pass for 2-pass quant */
.//JPEG/jpegint.h:157:/* Main buffer control (downsampled-data buffer) */
.//JPEG/jpegint.h:196:  /* Read a restart marker --- exported for use by entropy decoder only */
.//JPEG/jpegint.h:199:  /* State of marker reader --- nominally internal, but applications
.//JPEG/jpegint.h:204:  int next_restart_num;		/* next restart number expected (0-7) */
.//JPEG/jpegint.h:286:	 (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
.//JPEG/jpegint.h:294:/* Short forms of external names for systems with brain-damaged linkers. */
.//JPEG/jpegint.h:385:/* Suppress undefined-structure complaints if necessary. */
.//JPEG/jpeglib.h:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//JPEG/jpeglib.h:45:#define NUM_ARITH_TBLS      16	/* Arith-coding tables are numbered 0..15 */
.//JPEG/jpeglib.h:67:typedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
.//JPEG/jpeglib.h:68:typedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */
.//JPEG/jpeglib.h:72:typedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
.//JPEG/jpeglib.h:73:typedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */
.//JPEG/jpeglib.h:121:  int component_index;		/* its index in SOF or cinfo->comp_info[] */
.//JPEG/jpeglib.h:168:  int last_col_width;		/* # of non-dummy blocks across in last MCU */
.//JPEG/jpeglib.h:169:  int last_row_height;		/* # of non-dummy blocks down in last MCU */
.//JPEG/jpeglib.h:177:  /* Private per-component storage for DCT or IDCT subsystem. */
.//JPEG/jpeglib.h:182:/* The script for encoding a multiple-scan file is an array of these: */
.//JPEG/jpeglib.h:220:	JDCT_FLOAT		/* floating-point: accurate, fast on fast HW */
.//JPEG/jpeglib.h:235:	JDITHER_FS		/* Floyd-Steinberg error diffusion dither */
.//JPEG/jpeglib.h:274:  /* Description of source image --- these fields must be filled in by
.//JPEG/jpeglib.h:286:  /* Compression parameters --- these fields must be set before calling
.//JPEG/jpeglib.h:309:  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
.//JPEG/jpeglib.h:310:  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
.//JPEG/jpeglib.h:311:  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
.//JPEG/jpeglib.h:314:  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
.//JPEG/jpeglib.h:315:  /* The default value of scan_info is NULL, which causes a single-scan
.//JPEG/jpeglib.h:316:   * sequential JPEG file to be emitted.  To create a multi-scan file,
.//JPEG/jpeglib.h:354:  JDIMENSION next_scanline;	/* 0 .. image_height-1  */
.//JPEG/jpeglib.h:417:  /* Basic description of image --- filled in by jpeg_read_header(). */
.//JPEG/jpeglib.h:425:  /* Decompression processing parameters --- these fields must be set before
.//JPEG/jpeglib.h:446:  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
.//JPEG/jpeglib.h:448:  /* these are significant only in buffered-image mode: */
.//JPEG/jpeglib.h:449:  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
.//JPEG/jpeglib.h:451:  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */
.//JPEG/jpeglib.h:473:   * The application can supply a colormap by setting colormap non-NULL before
.//JPEG/jpeglib.h:479:  JSAMPARRAY colormap;		/* The color map as a 2-D pixel array */
.//JPEG/jpeglib.h:489:  JDIMENSION output_scanline;	/* 0 .. output_height-1  */
.//JPEG/jpeglib.h:506:   * It is -1 when no data has yet been received, otherwise it is the point
.//JPEG/jpeglib.h:509:   * This pointer is NULL when reading a non-progressive file.
.//JPEG/jpeglib.h:511:  int (*coef_bits)[DCTSIZE2];	/* -1 or current Al value for each coef */
.//JPEG/jpeglib.h:513:  /* Internal JPEG parameters --- the application usually need not look at
.//JPEG/jpeglib.h:541:  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
.//JPEG/jpeglib.h:542:  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
.//JPEG/jpeglib.h:543:  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
.//JPEG/jpeglib.h:589:  JSAMPLE * sample_range_limit; /* table for fast range-limiting */
.//JPEG/jpeglib.h:670:  /* For recoverable corrupt-data errors, we emit a warning message,
.//JPEG/jpeglib.h:676:  long num_warnings;		/* number of corrupt-data warnings */
.//JPEG/jpeglib.h:693:  const char * const * addon_message_table; /* Non-library errors */
.//JPEG/jpeglib.h:796:   * used for virtual-array buffers.)  May be changed by outer application
.//JPEG/jpeglib.h:806:/* Routine signature for application-supplied marker processing methods.
.//JPEG/jpeglib.h:807: * Need not pass marker code since it is stored in cinfo->unread_marker.
.//JPEG/jpeglib.h:824:/* Short forms of external names for systems with brain-damaged linkers.
.//JPEG/jpeglib.h:883:/* Default error-management setup */
.//JPEG/jpeglib.h:892: * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
.//JPEG/jpeglib.h:967:#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
.//JPEG/jpeglib.h:986:/* Additional entry points for buffered-image mode. */
.//JPEG/jpeglib.h:1014:/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
.//JPEG/jpeglib.h:1036:/* Default restart-marker-resync procedure for use by data source modules */
.//JPEG/jpeglib.h:1051:/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
.//JPEG/jquant1.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//JPEG/jquant1.cpp:8: * This file contains 1-pass color quantization (color mapping) routines.
.//JPEG/jquant1.cpp:10: * color values.  Optional Floyd-Steinberg or ordered dithering is available.
.//JPEG/jquant1.cpp:21: * The main purpose of 1-pass quantization is to provide a fast, if not very
.//JPEG/jquant1.cpp:22: * high quality, colormapped output capability.  A 2-pass quantizer usually
.//JPEG/jquant1.cpp:27: * In 1-pass quantization the colormap must be chosen in advance of seeing the
.//JPEG/jquant1.cpp:36: * N-dimensional-array-subscript calculation.  Most of the arithmetic involved
.//JPEG/jquant1.cpp:42: *    sum( colorindex[component-number][pixel-component-value] )
.//JPEG/jquant1.cpp:60: * output value.  The dither value is equivalent to (0.5 - threshold) times
.//JPEG/jquant1.cpp:65: * The normal calculation would be to form pixel value + dither, range-limit
.//JPEG/jquant1.cpp:67: * We can skip the separate range-limiting step by extending the colorindex
.//JPEG/jquant1.cpp:74:#define ODITHER_MASK  (ODITHER_SIZE-1) /* mask for wrapping around counters */
.//JPEG/jquant1.cpp:80:  /* Bayer's order-4 dither array.  Generated by the code given in
.//JPEG/jquant1.cpp:82:   * The values in this array must range from 0 to ODITHER_CELLS-1.
.//JPEG/jquant1.cpp:103:/* Declarations for Floyd-Steinberg dithering.
.//JPEG/jquant1.cpp:107: * to its not-yet-processed neighbors using the standard F-S fractions,
.//JPEG/jquant1.cpp:110: * We work left-to-right on even rows, right-to-left on odd rows.
.//JPEG/jquant1.cpp:121: * end saves us from special-casing the first and last pixels.
.//JPEG/jquant1.cpp:146:  JSAMPARRAY sv_colormap;	/* The color map as a 2-D pixel array */
.//JPEG/jquant1.cpp:162:  /* Variables for Floyd-Steinberg dithering */
.//JPEG/jquant1.cpp:171: * Policy-making subroutines for create_colormap and create_colorindex.
.//JPEG/jquant1.cpp:191:  int nc = cinfo->out_color_components; /* number of color components */
.//JPEG/jquant1.cpp:192:  int max_colors = cinfo->desired_number_of_colors;
.//JPEG/jquant1.cpp:207:  iroot--;			/* now iroot = floor(root) */
.//JPEG/jquant1.cpp:228:      j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
.//JPEG/jquant1.cpp:275:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant1.cpp:281:  total_colors = select_ncolors(cinfo, cquantize->Ncolors);
.//JPEG/jquant1.cpp:284:  if (cinfo->out_color_components == 3)
.//JPEG/jquant1.cpp:286:	     total_colors, cquantize->Ncolors[0],
.//JPEG/jquant1.cpp:287:	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
.//JPEG/jquant1.cpp:292:  /* The colors are ordered in the map in standard row-major order, */
.//JPEG/jquant1.cpp:293:  /* i.e. rightmost (highest-indexed) color changes most rapidly. */
.//JPEG/jquant1.cpp:295:  colormap = (*cinfo->mem->alloc_sarray)
.//JPEG/jquant1.cpp:297:     (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);
.//JPEG/jquant1.cpp:303:  for (i = 0; i < cinfo->out_color_components; i++) {
.//JPEG/jquant1.cpp:305:    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
.//JPEG/jquant1.cpp:309:      val = output_value(cinfo, i, j, nci-1);
.//JPEG/jquant1.cpp:323:  cquantize->sv_colormap = colormap;
.//JPEG/jquant1.cpp:324:  cquantize->sv_actual = total_colors;
.//JPEG/jquant1.cpp:335:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant1.cpp:340:   * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
.//JPEG/jquant1.cpp:344:  if (cinfo->dither_mode == JDITHER_ORDERED) {
.//JPEG/jquant1.cpp:346:    cquantize->is_padded = TRUE;
.//JPEG/jquant1.cpp:349:    cquantize->is_padded = FALSE;
.//JPEG/jquant1.cpp:352:  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
.//JPEG/jquant1.cpp:355:     (JDIMENSION) cinfo->out_color_components);
.//JPEG/jquant1.cpp:358:  blksize = cquantize->sv_actual;
.//JPEG/jquant1.cpp:360:  for (i = 0; i < cinfo->out_color_components; i++) {
.//JPEG/jquant1.cpp:362:    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
.//JPEG/jquant1.cpp:367:      cquantize->colorindex[i] += MAXJSAMPLE;
.//JPEG/jquant1.cpp:371:    indexptr = cquantize->colorindex[i];
.//JPEG/jquant1.cpp:373:    k = largest_input_value(cinfo, i, 0, nci-1);
.//JPEG/jquant1.cpp:376:	k = largest_input_value(cinfo, i, ++val, nci-1);
.//JPEG/jquant1.cpp:383:	indexptr[-j] = indexptr[0];
.//JPEG/jquant1.cpp:391: * Create an ordered-dither array for a component having ncolors
.//JPEG/jquant1.cpp:403:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jquant1.cpp:405:  /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
.//JPEG/jquant1.cpp:407:   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
.//JPEG/jquant1.cpp:408:   * On 16-bit-int machine, be careful to avoid overflow.
.//JPEG/jquant1.cpp:410:  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
.//JPEG/jquant1.cpp:413:      num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
.//JPEG/jquant1.cpp:418:      odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);
.//JPEG/jquant1.cpp:426: * Create the ordered-dither tables.
.//JPEG/jquant1.cpp:434:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant1.cpp:438:  for (i = 0; i < cinfo->out_color_components; i++) {
.//JPEG/jquant1.cpp:439:    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
.//JPEG/jquant1.cpp:442:      if (nci == cquantize->Ncolors[j]) {
.//JPEG/jquant1.cpp:443:	odither = cquantize->odither[j];
.//JPEG/jquant1.cpp:449:    cquantize->odither[i] = odither;
.//JPEG/jquant1.cpp:463:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant1.cpp:464:  JSAMPARRAY colorindex = cquantize->colorindex;
.//JPEG/jquant1.cpp:469:  JDIMENSION width = cinfo->output_width;
.//JPEG/jquant1.cpp:470:  register int nc = cinfo->out_color_components;
.//JPEG/jquant1.cpp:475:    for (col = width; col > 0; col--) {
.//JPEG/jquant1.cpp:491:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant1.cpp:494:  JSAMPROW colorindex0 = cquantize->colorindex[0];
.//JPEG/jquant1.cpp:495:  JSAMPROW colorindex1 = cquantize->colorindex[1];
.//JPEG/jquant1.cpp:496:  JSAMPROW colorindex2 = cquantize->colorindex[2];
.//JPEG/jquant1.cpp:499:  JDIMENSION width = cinfo->output_width;
.//JPEG/jquant1.cpp:504:    for (col = width; col > 0; col--) {
.//JPEG/jquant1.cpp:519:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant1.cpp:525:  int nc = cinfo->out_color_components;
.//JPEG/jquant1.cpp:529:  JDIMENSION width = cinfo->output_width;
.//JPEG/jquant1.cpp:535:    row_index = cquantize->row_index;
.//JPEG/jquant1.cpp:539:      colorindex_ci = cquantize->colorindex[ci];
.//JPEG/jquant1.cpp:540:      dither = cquantize->odither[ci][row_index];
.//JPEG/jquant1.cpp:543:      for (col = width; col > 0; col--) {
.//JPEG/jquant1.cpp:544:	/* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
.//JPEG/jquant1.cpp:546:	 * Range-limiting need not be done explicitly, as we have extended
.//JPEG/jquant1.cpp:547:	 * the colorindex table to produce the right answers for out-of-range
.//JPEG/jquant1.cpp:548:	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
.//JPEG/jquant1.cpp:559:    cquantize->row_index = row_index;
.//JPEG/jquant1.cpp:569:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant1.cpp:573:  JSAMPROW colorindex0 = cquantize->colorindex[0];
.//JPEG/jquant1.cpp:574:  JSAMPROW colorindex1 = cquantize->colorindex[1];
.//JPEG/jquant1.cpp:575:  JSAMPROW colorindex2 = cquantize->colorindex[2];
.//JPEG/jquant1.cpp:582:  JDIMENSION width = cinfo->output_width;
.//JPEG/jquant1.cpp:585:    row_index = cquantize->row_index;
.//JPEG/jquant1.cpp:588:    dither0 = cquantize->odither[0][row_index];
.//JPEG/jquant1.cpp:589:    dither1 = cquantize->odither[1][row_index];
.//JPEG/jquant1.cpp:590:    dither2 = cquantize->odither[2][row_index];
.//JPEG/jquant1.cpp:593:    for (col = width; col > 0; col--) {
.//JPEG/jquant1.cpp:604:    cquantize->row_index = row_index;
.//JPEG/jquant1.cpp:612:/* General case, with Floyd-Steinberg dithering */
.//JPEG/jquant1.cpp:614:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant1.cpp:626:  int nc = cinfo->out_color_components;
.//JPEG/jquant1.cpp:627:  int dir;			/* 1 for left-to-right, -1 for right-to-left */
.//JPEG/jquant1.cpp:632:  JDIMENSION width = cinfo->output_width;
.//JPEG/jquant1.cpp:633:  JSAMPLE *range_limit = cinfo->sample_range_limit;
.//JPEG/jquant1.cpp:643:      if (cquantize->on_odd_row) {
.//JPEG/jquant1.cpp:645:	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
.//JPEG/jquant1.cpp:646:	output_ptr += width-1;
.//JPEG/jquant1.cpp:647:	dir = -1;
.//JPEG/jquant1.cpp:648:	dirnc = -nc;
.//JPEG/jquant1.cpp:649:	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
.//JPEG/jquant1.cpp:654:	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
.//JPEG/jquant1.cpp:656:      colorindex_ci = cquantize->colorindex[ci];
.//JPEG/jquant1.cpp:657:      colormap_ci = cquantize->sv_colormap[ci];
.//JPEG/jquant1.cpp:663:      for (col = width; col > 0; col--) {
.//JPEG/jquant1.cpp:673:	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
.//JPEG/jquant1.cpp:674:	 * The maximum error is +- MAXJSAMPLE; this sets the required size
.//JPEG/jquant1.cpp:685:	cur -= GETJSAMPLE(colormap_ci[pixcode]);
.//JPEG/jquant1.cpp:688:	 * next-line error sums left by 1 column.
.//JPEG/jquant1.cpp:706:      /* Post-loop cleanup: we must unload the final error value into the
.//JPEG/jquant1.cpp:712:    cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
.//JPEG/jquant1.cpp:718: * Allocate workspace for Floyd-Steinberg errors.
.//JPEG/jquant1.cpp:724:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant1.cpp:728:  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
.//JPEG/jquant1.cpp:729:  for (i = 0; i < cinfo->out_color_components; i++) {
.//JPEG/jquant1.cpp:730:    cquantize->fserrors[i] = (FSERRPTR)
.//JPEG/jquant1.cpp:731:      (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
.//JPEG/jquant1.cpp:737: * Initialize for one-pass color quantization.
.//JPEG/jquant1.cpp:743:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant1.cpp:748:  cinfo->colormap = cquantize->sv_colormap;
.//JPEG/jquant1.cpp:749:  cinfo->actual_number_of_colors = cquantize->sv_actual;
.//JPEG/jquant1.cpp:752:  switch (cinfo->dither_mode) {
.//JPEG/jquant1.cpp:754:    if (cinfo->out_color_components == 3)
.//JPEG/jquant1.cpp:755:      cquantize->pub.color_quantize = color_quantize3;
.//JPEG/jquant1.cpp:757:      cquantize->pub.color_quantize = color_quantize;
.//JPEG/jquant1.cpp:760:    if (cinfo->out_color_components == 3)
.//JPEG/jquant1.cpp:761:      cquantize->pub.color_quantize = quantize3_ord_dither;
.//JPEG/jquant1.cpp:763:      cquantize->pub.color_quantize = quantize_ord_dither;
.//JPEG/jquant1.cpp:764:    cquantize->row_index = 0;	/* initialize state for ordered dither */
.//JPEG/jquant1.cpp:769:    if (! cquantize->is_padded)
.//JPEG/jquant1.cpp:771:    /* Create ordered-dither tables if we didn't already. */
.//JPEG/jquant1.cpp:772:    if (cquantize->odither[0] == NULL)
.//JPEG/jquant1.cpp:776:    cquantize->pub.color_quantize = quantize_fs_dither;
.//JPEG/jquant1.cpp:777:    cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
.//JPEG/jquant1.cpp:778:    /* Allocate Floyd-Steinberg workspace if didn't already. */
.//JPEG/jquant1.cpp:779:    if (cquantize->fserrors[0] == NULL)
.//JPEG/jquant1.cpp:782:    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
.//JPEG/jquant1.cpp:783:    for (i = 0; i < cinfo->out_color_components; i++)
.//JPEG/jquant1.cpp:784:      jzero_far((void FAR *) cquantize->fserrors[i], arraysize);
.//JPEG/jquant1.cpp:800:  /* no work in 1-pass case */
.//JPEG/jquant1.cpp:817: * Module initialization routine for 1-pass color quantization.
.//JPEG/jquant1.cpp:826:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jquant1.cpp:828:  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
.//JPEG/jquant1.cpp:829:  cquantize->pub.start_pass = start_pass_1_quant;
.//JPEG/jquant1.cpp:830:  cquantize->pub.finish_pass = finish_pass_1_quant;
.//JPEG/jquant1.cpp:831:  cquantize->pub.new_color_map = new_color_map_1_quant;
.//JPEG/jquant1.cpp:832:  cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
.//JPEG/jquant1.cpp:833:  cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */
.//JPEG/jquant1.cpp:836:  if (cinfo->out_color_components > MAX_Q_COMPS)
.//JPEG/jquant1.cpp:839:  if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
.//JPEG/jquant1.cpp:846:  /* Allocate Floyd-Steinberg workspace now if requested.
.//JPEG/jquant1.cpp:852:  if (cinfo->dither_mode == JDITHER_FS)
.//JPEG/jquant2.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//JPEG/jquant2.cpp:8: * This file contains 2-pass color quantization (color mapping) routines.
.//JPEG/jquant2.cpp:11: * Floyd-Steinberg dithering.
.//JPEG/jquant2.cpp:13: * externally-given color map.
.//JPEG/jquant2.cpp:28: * This module implements the well-known Heckbert paradigm for color
.//JPEG/jquant2.cpp:32: *   Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.
.//JPEG/jquant2.cpp:40: * Next, the color-selection step begins with a box representing the whole
.//JPEG/jquant2.cpp:46: * color (optionally after applying a Floyd-Steinberg dithering correction).
.//JPEG/jquant2.cpp:50: * Heckbert-style quantizers vary a good deal in their policies for choosing
.//JPEG/jquant2.cpp:61: * externally-supplied colormap.  We have therefore abandoned that approach.
.//JPEG/jquant2.cpp:62: * The present code works in the post-conversion color space, typically RGB.
.//JPEG/jquant2.cpp:69: * If you want to use this code to quantize a non-RGB color space, you'll
.//JPEG/jquant2.cpp:112: * and clamping those that do overflow to the maximum value will give close-
.//JPEG/jquant2.cpp:114: * to 128Kb, which is a useful savings on PC-class machines.
.//JPEG/jquant2.cpp:115: * (In the second pass the histogram space is re-used for pixel mapping data;
.//JPEG/jquant2.cpp:120: * of a true 3-D array, we use a row of pointers to 2-D arrays.  Each
.//JPEG/jquant2.cpp:122: * each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that
.//JPEG/jquant2.cpp:142:#define C0_SHIFT  (BITS_IN_JSAMPLE-HIST_C0_BITS)
.//JPEG/jquant2.cpp:143:#define C1_SHIFT  (BITS_IN_JSAMPLE-HIST_C1_BITS)
.//JPEG/jquant2.cpp:144:#define C2_SHIFT  (BITS_IN_JSAMPLE-HIST_C2_BITS)
.//JPEG/jquant2.cpp:152:typedef hist1d FAR * hist2d;	/* type for the 2nd-level pointers */
.//JPEG/jquant2.cpp:153:typedef hist2d * hist3d;	/* type for top-level pointer */
.//JPEG/jquant2.cpp:156:/* Declarations for Floyd-Steinberg dithering.
.//JPEG/jquant2.cpp:160: * to its not-yet-processed neighbors using the standard F-S fractions,
.//JPEG/jquant2.cpp:163: * We work left-to-right on even rows, right-to-left on odd rows.
.//JPEG/jquant2.cpp:173: * each end saves us from special-casing the first and last pixels.
.//JPEG/jquant2.cpp:205:  /* Variables for Floyd-Steinberg dithering */
.//JPEG/jquant2.cpp:227:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant2.cpp:230:  register hist3d histogram = cquantize->histogram;
.//JPEG/jquant2.cpp:233:  JDIMENSION width = cinfo->output_width;
.//JPEG/jquant2.cpp:237:    for (col = width; col > 0; col--) {
.//JPEG/jquant2.cpp:244:	(*histp)--;
.//JPEG/jquant2.cpp:263:  /* The volume (actually 2-norm) of the box */
.//JPEG/jquant2.cpp:283:    if (boxp->colorcount > maxc && boxp->volume > 0) {
.//JPEG/jquant2.cpp:285:      maxc = boxp->colorcount;
.//JPEG/jquant2.cpp:303:    if (boxp->volume > maxv) {
.//JPEG/jquant2.cpp:305:      maxv = boxp->volume;
.//JPEG/jquant2.cpp:317:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant2.cpp:318:  hist3d histogram = cquantize->histogram;
.//JPEG/jquant2.cpp:325:  c0min = boxp->c0min;  c0max = boxp->c0max;
.//JPEG/jquant2.cpp:326:  c1min = boxp->c1min;  c1max = boxp->c1max;
.//JPEG/jquant2.cpp:327:  c2min = boxp->c2min;  c2max = boxp->c2max;
.//JPEG/jquant2.cpp:335:	    boxp->c0min = c0min = c0;
.//JPEG/jquant2.cpp:341:    for (c0 = c0max; c0 >= c0min; c0--)
.//JPEG/jquant2.cpp:346:	    boxp->c0max = c0max = c0;
.//JPEG/jquant2.cpp:357:	    boxp->c1min = c1min = c1;
.//JPEG/jquant2.cpp:363:    for (c1 = c1max; c1 >= c1min; c1--)
.//JPEG/jquant2.cpp:368:	    boxp->c1max = c1max = c1;
.//JPEG/jquant2.cpp:379:	    boxp->c2min = c2min = c2;
.//JPEG/jquant2.cpp:385:    for (c2 = c2max; c2 >= c2min; c2--)
.//JPEG/jquant2.cpp:390:	    boxp->c2max = c2max = c2;
.//JPEG/jquant2.cpp:397:   * We use 2-norm rather than real volume here; this biases the method
.//JPEG/jquant2.cpp:400:   * Since the differences are expressed in histogram-cell units,
.//JPEG/jquant2.cpp:404:  dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
.//JPEG/jquant2.cpp:405:  dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
.//JPEG/jquant2.cpp:406:  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
.//JPEG/jquant2.cpp:407:  boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
.//JPEG/jquant2.cpp:419:  boxp->colorcount = ccount;
.//JPEG/jquant2.cpp:445:    b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
.//JPEG/jquant2.cpp:446:    b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
.//JPEG/jquant2.cpp:451:    c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
.//JPEG/jquant2.cpp:452:    c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
.//JPEG/jquant2.cpp:453:    c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
.//JPEG/jquant2.cpp:474:      lb = (b1->c0max + b1->c0min) / 2;
.//JPEG/jquant2.cpp:475:      b1->c0max = lb;
.//JPEG/jquant2.cpp:476:      b2->c0min = lb+1;
.//JPEG/jquant2.cpp:479:      lb = (b1->c1max + b1->c1min) / 2;
.//JPEG/jquant2.cpp:480:      b1->c1max = lb;
.//JPEG/jquant2.cpp:481:      b2->c1min = lb+1;
.//JPEG/jquant2.cpp:484:      lb = (b1->c2max + b1->c2min) / 2;
.//JPEG/jquant2.cpp:485:      b1->c2max = lb;
.//JPEG/jquant2.cpp:486:      b2->c2min = lb+1;
.//JPEG/jquant2.cpp:504:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant2.cpp:505:  hist3d histogram = cquantize->histogram;
.//JPEG/jquant2.cpp:515:  c0min = boxp->c0min;  c0max = boxp->c0max;
.//JPEG/jquant2.cpp:516:  c1min = boxp->c1min;  c1max = boxp->c1max;
.//JPEG/jquant2.cpp:517:  c2min = boxp->c2min;  c2max = boxp->c2max;
.//JPEG/jquant2.cpp:532:  cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
.//JPEG/jquant2.cpp:533:  cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
.//JPEG/jquant2.cpp:534:  cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
.//JPEG/jquant2.cpp:547:  boxlist = (boxptr) (*cinfo->mem->alloc_small)
.//JPEG/jquant2.cpp:557:  /* Shrink it to actually-used volume and set its statistics */
.//JPEG/jquant2.cpp:559:  /* Perform median-cut to produce final box list */
.//JPEG/jquant2.cpp:564:  cinfo->actual_number_of_colors = numboxes;
.//JPEG/jquant2.cpp:570: * These routines are concerned with the time-critical task of mapping input
.//JPEG/jquant2.cpp:573: * We re-use the histogram space as an "inverse color map", essentially a
.//JPEG/jquant2.cpp:574: * cache for the results of nearest-color searches.  All colors within a
.//JPEG/jquant2.cpp:593: * it needs a work array to hold the best-distance-so-far for each histogram
.//JPEG/jquant2.cpp:606: * three-fourths of the colormap entries are rejected by Heckbert's criterion,
.//JPEG/jquant2.cpp:614: * faster than the brute-force method, but it is also far more complex and
.//JPEG/jquant2.cpp:618: * refined method might be faster than the present code --- but then again,
.//JPEG/jquant2.cpp:624:#define BOX_C0_LOG  (HIST_C0_BITS-3)
.//JPEG/jquant2.cpp:625:#define BOX_C1_LOG  (HIST_C1_BITS-3)
.//JPEG/jquant2.cpp:626:#define BOX_C2_LOG  (HIST_C2_BITS-3)
.//JPEG/jquant2.cpp:642: * inner-loop variables.
.//JPEG/jquant2.cpp:657:  int numcolors = cinfo->actual_number_of_colors;
.//JPEG/jquant2.cpp:665:   * Actually we compute the coordinates of the center of the upper-corner
.//JPEG/jquant2.cpp:670:  maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
.//JPEG/jquant2.cpp:672:  maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
.//JPEG/jquant2.cpp:674:  maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
.//JPEG/jquant2.cpp:678:   *  1. its minimum squared-distance to any point in the update box
.//JPEG/jquant2.cpp:680:   *  2. its maximum squared-distance to any point in the update box.
.//JPEG/jquant2.cpp:688:    /* We compute the squared-c0-distance term, then add in the other two. */
.//JPEG/jquant2.cpp:689:    x = GETJSAMPLE(cinfo->colormap[0][i]);
.//JPEG/jquant2.cpp:691:      tdist = (x - minc0) * C0_SCALE;
.//JPEG/jquant2.cpp:693:      tdist = (x - maxc0) * C0_SCALE;
.//JPEG/jquant2.cpp:696:      tdist = (x - maxc0) * C0_SCALE;
.//JPEG/jquant2.cpp:698:      tdist = (x - minc0) * C0_SCALE;
.//JPEG/jquant2.cpp:704:	tdist = (x - maxc0) * C0_SCALE;
.//JPEG/jquant2.cpp:707:	tdist = (x - minc0) * C0_SCALE;
.//JPEG/jquant2.cpp:712:    x = GETJSAMPLE(cinfo->colormap[1][i]);
.//JPEG/jquant2.cpp:714:      tdist = (x - minc1) * C1_SCALE;
.//JPEG/jquant2.cpp:716:      tdist = (x - maxc1) * C1_SCALE;
.//JPEG/jquant2.cpp:719:      tdist = (x - maxc1) * C1_SCALE;
.//JPEG/jquant2.cpp:721:      tdist = (x - minc1) * C1_SCALE;
.//JPEG/jquant2.cpp:726:	tdist = (x - maxc1) * C1_SCALE;
.//JPEG/jquant2.cpp:729:	tdist = (x - minc1) * C1_SCALE;
.//JPEG/jquant2.cpp:734:    x = GETJSAMPLE(cinfo->colormap[2][i]);
.//JPEG/jquant2.cpp:736:      tdist = (x - minc2) * C2_SCALE;
.//JPEG/jquant2.cpp:738:      tdist = (x - maxc2) * C2_SCALE;
.//JPEG/jquant2.cpp:741:      tdist = (x - maxc2) * C2_SCALE;
.//JPEG/jquant2.cpp:743:      tdist = (x - minc2) * C2_SCALE;
.//JPEG/jquant2.cpp:748:	tdist = (x - maxc2) * C2_SCALE;
.//JPEG/jquant2.cpp:751:	tdist = (x - minc2) * C2_SCALE;
.//JPEG/jquant2.cpp:793:  /* This array holds the distance to the nearest-so-far color for each cell */
.//JPEG/jquant2.cpp:796:  /* Initialize best-distance for each cell of the update box */
.//JPEG/jquant2.cpp:798:  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
.//JPEG/jquant2.cpp:803:   * If that's less than best-so-far, update best distance and color number.
.//JPEG/jquant2.cpp:814:    inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
.//JPEG/jquant2.cpp:816:    inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
.//JPEG/jquant2.cpp:818:    inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
.//JPEG/jquant2.cpp:828:    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
.//JPEG/jquant2.cpp:831:      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
.//JPEG/jquant2.cpp:834:	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
.//JPEG/jquant2.cpp:856:/* Fill the inverse-colormap entries in the update box that contains */
.//JPEG/jquant2.cpp:860:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant2.cpp:861:  hist3d histogram = cquantize->histogram;
.//JPEG/jquant2.cpp:919:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant2.cpp:920:  hist3d histogram = cquantize->histogram;
.//JPEG/jquant2.cpp:926:  JDIMENSION width = cinfo->output_width;
.//JPEG/jquant2.cpp:931:    for (col = width; col > 0; col--) {
.//JPEG/jquant2.cpp:942:      *outptr++ = (JSAMPLE) (*cachep - 1);
.//JPEG/jquant2.cpp:951:/* This version performs Floyd-Steinberg dithering */
.//JPEG/jquant2.cpp:953:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant2.cpp:954:  hist3d histogram = cquantize->histogram;
.//JPEG/jquant2.cpp:962:  int dir;			/* +1 or -1 depending on direction */
.//JPEG/jquant2.cpp:966:  JDIMENSION width = cinfo->output_width;
.//JPEG/jquant2.cpp:967:  JSAMPLE *range_limit = cinfo->sample_range_limit;
.//JPEG/jquant2.cpp:968:  int *error_limit = cquantize->error_limiter;
.//JPEG/jquant2.cpp:969:  JSAMPROW colormap0 = cinfo->colormap[0];
.//JPEG/jquant2.cpp:970:  JSAMPROW colormap1 = cinfo->colormap[1];
.//JPEG/jquant2.cpp:971:  JSAMPROW colormap2 = cinfo->colormap[2];
.//JPEG/jquant2.cpp:977:    if (cquantize->on_odd_row) {
.//JPEG/jquant2.cpp:979:      inptr += (width-1) * 3;	/* so point to rightmost pixel */
.//JPEG/jquant2.cpp:980:      outptr += width-1;
.//JPEG/jquant2.cpp:981:      dir = -1;
.//JPEG/jquant2.cpp:982:      dir3 = -3;
.//JPEG/jquant2.cpp:983:      errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
.//JPEG/jquant2.cpp:984:      cquantize->on_odd_row = FALSE; /* flip for next time */
.//JPEG/jquant2.cpp:989:      errorptr = cquantize->fserrors; /* => entry before first real column */
.//JPEG/jquant2.cpp:990:      cquantize->on_odd_row = TRUE; /* flip for next time */
.//JPEG/jquant2.cpp:998:    for (col = width; col > 0; col--) {
.//JPEG/jquant2.cpp:1016:      /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
.//JPEG/jquant2.cpp:1017:       * The maximum error is +- MAXJSAMPLE (or less with error limiting);
.//JPEG/jquant2.cpp:1033:      { register int pixcode = *cachep - 1;
.//JPEG/jquant2.cpp:1036:	cur0 -= GETJSAMPLE(colormap0[pixcode]);
.//JPEG/jquant2.cpp:1037:	cur1 -= GETJSAMPLE(colormap1[pixcode]);
.//JPEG/jquant2.cpp:1038:	cur2 -= GETJSAMPLE(colormap2[pixcode]);
.//JPEG/jquant2.cpp:1042:       * next-line error sums left by 1 column.
.//JPEG/jquant2.cpp:1079:    /* Post-loop cleanup: we must unload the final error values into the
.//JPEG/jquant2.cpp:1091: * Initialize the error-limiting transfer function (lookup table).
.//JPEG/jquant2.cpp:1092: * The raw F-S error computation can potentially compute error values of up to
.//JPEG/jquant2.cpp:1093: * +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be
.//JPEG/jquant2.cpp:1095: * effects include weird fringes at color-area boundaries, isolated bright
.//JPEG/jquant2.cpp:1102: * A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty
.//JPEG/jquant2.cpp:1111:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant2.cpp:1115:  table = (int *) (*cinfo->mem->alloc_small)
.//JPEG/jquant2.cpp:1117:  table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
.//JPEG/jquant2.cpp:1118:  cquantize->error_limiter = table;
.//JPEG/jquant2.cpp:1121:  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
.//JPEG/jquant2.cpp:1124:    table[in] = out; table[-in] = -out;
.//JPEG/jquant2.cpp:1126:  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
.//JPEG/jquant2.cpp:1128:    table[in] = out; table[-in] = -out;
.//JPEG/jquant2.cpp:1132:    table[in] = out; table[-in] = -out;
.//JPEG/jquant2.cpp:1145:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant2.cpp:1147:  /* Select the representative colors and fill in cinfo->colormap */
.//JPEG/jquant2.cpp:1148:  cinfo->colormap = cquantize->sv_colormap;
.//JPEG/jquant2.cpp:1149:  select_colors(cinfo, cquantize->desired);
.//JPEG/jquant2.cpp:1151:  cquantize->needs_zeroed = TRUE;
.//JPEG/jquant2.cpp:1169:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant2.cpp:1170:  hist3d histogram = cquantize->histogram;
.//JPEG/jquant2.cpp:1173:  /* Only F-S dithering or no dithering is supported. */
.//JPEG/jquant2.cpp:1174:  /* If user asks for ordered dither, give him F-S. */
.//JPEG/jquant2.cpp:1175:  if (cinfo->dither_mode != JDITHER_NONE)
.//JPEG/jquant2.cpp:1176:    cinfo->dither_mode = JDITHER_FS;
.//JPEG/jquant2.cpp:1180:    cquantize->pub.color_quantize = prescan_quantize;
.//JPEG/jquant2.cpp:1181:    cquantize->pub.finish_pass = finish_pass1;
.//JPEG/jquant2.cpp:1182:    cquantize->needs_zeroed = TRUE; /* Always zero histogram */
.//JPEG/jquant2.cpp:1185:    if (cinfo->dither_mode == JDITHER_FS)
.//JPEG/jquant2.cpp:1186:      cquantize->pub.color_quantize = pass2_fs_dither;
.//JPEG/jquant2.cpp:1188:      cquantize->pub.color_quantize = pass2_no_dither;
.//JPEG/jquant2.cpp:1189:    cquantize->pub.finish_pass = finish_pass2;
.//JPEG/jquant2.cpp:1192:    i = cinfo->actual_number_of_colors;
.//JPEG/jquant2.cpp:1198:    if (cinfo->dither_mode == JDITHER_FS) {
.//JPEG/jquant2.cpp:1199:      size_t arraysize = (size_t) ((cinfo->output_width + 2) *
.//JPEG/jquant2.cpp:1201:      /* Allocate Floyd-Steinberg workspace if we didn't already. */
.//JPEG/jquant2.cpp:1202:      if (cquantize->fserrors == NULL)
.//JPEG/jquant2.cpp:1203:	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
.//JPEG/jquant2.cpp:1206:      jzero_far((void FAR *) cquantize->fserrors, arraysize);
.//JPEG/jquant2.cpp:1207:      /* Make the error-limit table if we didn't already. */
.//JPEG/jquant2.cpp:1208:      if (cquantize->error_limiter == NULL)
.//JPEG/jquant2.cpp:1210:      cquantize->on_odd_row = FALSE;
.//JPEG/jquant2.cpp:1215:  if (cquantize->needs_zeroed) {
.//JPEG/jquant2.cpp:1220:    cquantize->needs_zeroed = FALSE;
.//JPEG/jquant2.cpp:1232:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//JPEG/jquant2.cpp:1235:  cquantize->needs_zeroed = TRUE;
.//JPEG/jquant2.cpp:1240: * Module initialization routine for 2-pass color quantization.
.//JPEG/jquant2.cpp:1250:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//JPEG/jquant2.cpp:1252:  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
.//JPEG/jquant2.cpp:1253:  cquantize->pub.start_pass = start_pass_2_quant;
.//JPEG/jquant2.cpp:1254:  cquantize->pub.new_color_map = new_color_map_2_quant;
.//JPEG/jquant2.cpp:1255:  cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
.//JPEG/jquant2.cpp:1256:  cquantize->error_limiter = NULL;
.//JPEG/jquant2.cpp:1259:  if (cinfo->out_color_components != 3)
.//JPEG/jquant2.cpp:1263:  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
.//JPEG/jquant2.cpp:1266:    cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
.//JPEG/jquant2.cpp:1270:  cquantize->needs_zeroed = TRUE; /* histogram is garbage now */
.//JPEG/jquant2.cpp:1276:  if (cinfo->enable_2pass_quant) {
.//JPEG/jquant2.cpp:1278:    int desired = cinfo->desired_number_of_colors;
.//JPEG/jquant2.cpp:1285:    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
.//JPEG/jquant2.cpp:1287:    cquantize->desired = desired;
.//JPEG/jquant2.cpp:1289:    cquantize->sv_colormap = NULL;
.//JPEG/jquant2.cpp:1291:  /* Only F-S dithering or no dithering is supported. */
.//JPEG/jquant2.cpp:1292:  /* If user asks for ordered dither, give him F-S. */
.//JPEG/jquant2.cpp:1293:  if (cinfo->dither_mode != JDITHER_NONE)
.//JPEG/jquant2.cpp:1294:    cinfo->dither_mode = JDITHER_FS;
.//JPEG/jquant2.cpp:1296:  /* Allocate Floyd-Steinberg workspace if necessary.
.//JPEG/jquant2.cpp:1301:  if (cinfo->dither_mode == JDITHER_FS) {
.//JPEG/jquant2.cpp:1302:    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
.//JPEG/jquant2.cpp:1304:       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
.//JPEG/jquant2.cpp:1305:    /* Might as well create the error-limiting table too. */
.//JPEG/jutils.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//JPEG/jutils.cpp:20: * jpeg_zigzag_order[i] is the zigzag-order position of the i'th element
.//JPEG/jutils.cpp:40: * jpeg_natural_order[i] is the natural-order position of the i'th element
.//JPEG/jutils.cpp:46: * wild stores without adding an inner-loop test, we put some extra
.//JPEG/jutils.cpp:49: * The worst case would be a run-length of 15, which means we need 16
.//JPEG/jutils.cpp:76:  return (a + b - 1L) / b;
.//JPEG/jutils.cpp:85:  a += b - 1L;
.//JPEG/jutils.cpp:86:  return a - (a % b);
.//JPEG/jutils.cpp:91: * and coefficient-block arrays.  This won't work on 80x86 because the arrays
.//JPEG/jutils.cpp:92: * are FAR and we're assuming a small-pointer memory model.  However, some
.//JPEG/jutils.cpp:93: * DOS compilers provide far-pointer versions of memcpy() and memset() even
.//JPEG/jutils.cpp:94: * in the small-model libraries.  These will be used if USE_FMEM is defined.
.//JPEG/jutils.cpp:131:  for (row = num_rows; row > 0; row--) {
.//JPEG/jutils.cpp:137:    for (count = num_cols; count > 0; count--)
.//JPEG/jutils.cpp:157:  for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {
.//JPEG/jutils.cpp:167:/* This might be sample-array data, block-array data, or alloc_large data. */
.//JPEG/jutils.cpp:175:  for (count = bytestozero; count > 0; count--) {
.//JPEG/jversion.h:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//JPEG/jversion.h:12:#define JVERSION	"6b  27-Mar-1998"
.//JPEG/Makefile:61:debug: CFLAGS += -DDEBUG -g3
.//JPEG/Makefile:64:release: CFLAGS += -O2 -DRELEASE -pipe -fomit-frame-pointer
.//JPEG/Makefile:71:	/bin/rm -f ${CLEAN}
.//JPEG/Makefile:74:	${CC} ${CFLAGS} -c $<
.//main.cpp:13:	printf("\t --in <Ray File>\n");
.//main.cpp:14:	printf("\t [--width <image width=%d>] [--height <image height=%d>]\n",DEFAULT_RESOLUTION,DEFAULT_RESOLUTION);
.//main.cpp:15:	printf("\t [--cplx <complexity=%d>]\n",DEFAULT_COMPLEXITY);
.//main.cpp:30:	cmdLineParse(argc-1,&argv[1],paramNames,4,params);
.//Makefile:41:CFLAGS		+= -I.
.//Makefile:43:	LFLAGS	+= -LJPEG -lJPEG -framework OpenGL -framework GLUT
.//Makefile:45:	LFLAGS	+= -LJPEG -lJPEG -lglut -lGLU -lGL
.//Makefile:54:debug: CFLAGS += -DDEBUG -g3
.//Makefile:57:release: CFLAGS += -O2 -DRELEASE -pipe -fomit-frame-pointer
.//Makefile:61:	${CC} -o $@ ${OBJECTS} ${LFLAGS}
.//Makefile:64:	/bin/rm -f ${CLEAN}
.//Makefile:65:	${MAKE} -C JPEG clean
.//Makefile:68:	${CC} ${CFLAGS} -o $@ -c $<
.//Makefile:71:	${MAKE} -C JPEG
.//Ray/mouse.cpp:10:	startX=endX=-1;
.//Ray/mouse.cpp:11:	startY=endY=-1;
.//Ray/mouse.cpp:50:	d[0]=x-endX;
.//Ray/mouse.cpp:51:	d[1]=y-endY;
.//Ray/rayBox.cpp:25:	fprintf(fp,"#shape_box %d\n",material->index);
.//Ray/rayBox.h:28:	// Ray-Tracing stuff //
.//Ray/rayBox.h:30:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//Ray/rayBox.todo.cpp:7://  Ray-tracing stuff //
.//Ray/rayBox.todo.cpp:10:	return -1;
.//Ray/rayBox.todo.cpp:13:	bBox=BoundingBox3D(center-(length/2),center+(length/2));
.//Ray/rayBox.todo.cpp:21:	return -1;
.//Ray/rayCone.cpp:27:	fprintf(fp,"#shape_cone %d\n",material->index);
.//Ray/rayCone.h:6:/** This class represents a cone whose central axis isparallel to the y-axis, and 
.//Ray/rayCone.h:29:	// Ray-Tracing stuff //
.//Ray/rayCone.h:31:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//Ray/rayCone.todo.cpp:8://  Ray-tracing stuff //
.//Ray/rayCone.todo.cpp:11:	return -1;
.//Ray/rayCone.todo.cpp:17:	bBox=BoundingBox3D(center+p,center-p);
.//Ray/rayCone.todo.cpp:25:	return -1;
.//Ray/rayCylinder.cpp:28:	fprintf(fp,"#shape_cylinder %d\n",material->index);
.//Ray/rayCylinder.h:6:/** This class represents a cylinder whose central axis is parallel to the y-axis, 
.//Ray/rayCylinder.h:28:	// Ray-Tracing stuff //
.//Ray/rayCylinder.h:30:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//Ray/rayCylinder.todo.cpp:8://  Ray-tracing stuff //
.//Ray/rayCylinder.todo.cpp:11:	return -1;
.//Ray/rayCylinder.todo.cpp:17:	bBox=BoundingBox3D(center+p,center-p);
.//Ray/rayCylinder.todo.cpp:25:	return -1;
.//Ray/rayDirectionalLight.h:18:	// Ray-Tracing stuff //
.//Ray/rayDirectionalLight.todo.cpp:11://  Ray-tracing stuff //
.//Ray/rayFileInstance.cpp:11:	fprintf(fp,"#ray_file_instance %d\n",rayFile->index);
.//Ray/rayFileInstance.cpp:14:	return rayFile->scene->group->intersect(ray,iInfo,mx);
.//Ray/rayFileInstance.cpp:18:	bBox=rayFile->scene->group->setBoundingBox();
.//Ray/rayFileInstance.cpp:22:int RayFileInstance::isStatic(void){return rayFile->scene->group->isStatic();}
.//Ray/rayFileInstance.cpp:29:int RayFileInstance::drawOpenGL(int materialIndex){return rayFile->scene->group->drawOpenGL(materialIndex);}
.//Ray/rayFileInstance.h:8:/** This subclass of RayShape stores a reference to a .ray file included in the scene-graph.*/
.//Ray/rayFileInstance.h:17:	// Ray-Tracing stuff //
.//Ray/rayFileInstance.h:19:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//Ray/rayGroup.cpp:13:	if(i1->t < i2->t){return -1;}
.//Ray/rayGroup.cpp:14:	else if(i2->t<i1->t){return 1;}
.//Ray/rayGroup.cpp:40:	for(int i=0;i<sNum;i++){shapes[i]->write(indent+2,fp);}
.//Ray/rayGroup.cpp:58:	for(i=0;i<sNum;i++){if(!shapes[i]->isStatic()){s=0;}}
.//Ray/rayGroup.cpp:59:	for(i=0;i<sNum;i++){shapes[i]->setUpOpenGL(cplx,setCallList && (!s));}
.//Ray/rayGroup.cpp:119:	for(int i=0;i<sNum;i++){if(!shapes[i]->isStatic()){return 0;}}
.//Ray/rayGroup.h:32:	/** An array of RayShapeHit elements that can be used for bounding-volume sorting*/
.//Ray/rayGroup.h:59:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//Ray/rayGroup.h:147:/** This class represents a parametrizable transformation that stores a pointer to the 3x3 skew-symmetric logarithm of the
.//Ray/rayGroup.h:148:  * rotation and a pointer to the translation vector. When it returns a transformation, it exponentiates the 3x3 skew-symmetric
.//Ray/rayGroup.h:157:  * unit-quaternion obtained by normalizing. */
.//Ray/rayGroup.todo.cpp:10://  Ray-tracing stuff //
.//Ray/rayGroup.todo.cpp:16:		double distance = shapes[i]->intersect(ray, iInfo, minDistance);
.//Ray/rayGroup.todo.cpp:30:		tBBox=shapes[i]->setBoundingBox();
.//Ray/rayGroup.todo.cpp:55:        curShape->drawOpenGL( materialIndex );
.//Ray/rayGroup.todo.cpp:57:	return -1; // TODO: return something real
.//Ray/rayKey.cpp:36:	return -1;
.//Ray/rayKey.cpp:160:	type=-1;
.//Ray/rayKey.cpp:170:	type=-1;
.//Ray/rayKey.cpp:174:	for(int i=0;i<pNum;i++){sampleData[i]->setCurrentValue(t,curveType);}
.//Ray/rayKey.cpp:188:		matrix->value=&(((ParameterSamples<Matrix4D>*)sampleData[i])->currentValue);
.//Ray/rayKey.cpp:193:		eulerAndTranslation->value=&(((ParameterSamples<EulerAnglesAndTranslation>*)sampleData[i])->currentValue);
.//Ray/rayKey.cpp:198:		rClosestAndTranslation->value=&(((ParameterSamples<RotationAndTranslation>*)sampleData[i])->currentValue);
.//Ray/rayKey.cpp:203:		rLogarithmAndTranslation->value=&(((ParameterSamples<LogRotationAndTranslation>*)sampleData[i])->currentValue);
.//Ray/rayKey.cpp:208:		quaternionAndTranslation->value=&(((ParameterSamples<QuaternionAndTranslation>*)sampleData[i])->currentValue);
.//Ray/rayKey.cpp:239:		if(!sampleData[i] || !sampleData[i]->set(keyFile.samples())){
.//Ray/rayKey.cpp:246:				((ParameterSamples<Matrix4D>*)sampleData[i])->samples[j]=keyFile[j][i];
.//Ray/rayKey.cpp:250:					((ParameterSamples<EulerAnglesAndTranslation>*)sampleData[i])->samples[j]=
.//Ray/rayKey.cpp:251:						EulerAnglesAndTranslation(keyFile[j][i],((ParameterSamples<EulerAnglesAndTranslation>*)sampleData[i])->samples[j-1]);
.//Ray/rayKey.cpp:253:				else{((ParameterSamples<EulerAnglesAndTranslation>*)sampleData[i])->samples[j]=keyFile[j][i];}
.//Ray/rayKey.cpp:256:				((ParameterSamples<RotationAndTranslation>*)sampleData[i])->samples[j]=keyFile[j][i];
.//Ray/rayKey.cpp:260:					((ParameterSamples<LogRotationAndTranslation>*)sampleData[i])->samples[j]=
.//Ray/rayKey.cpp:261:						LogRotationAndTranslation(keyFile[j][i],((ParameterSamples<LogRotationAndTranslation>*)sampleData[i])->samples[j-1]);
.//Ray/rayKey.cpp:263:				else{((ParameterSamples<LogRotationAndTranslation>*)sampleData[i])->samples[j]=keyFile[j][i];}
.//Ray/rayKey.cpp:267:					((ParameterSamples<QuaternionAndTranslation>*)sampleData[i])->samples[j]=
.//Ray/rayKey.cpp:268:						QuaternionAndTranslation(keyFile[j][i],((ParameterSamples<QuaternionAndTranslation>*)sampleData[i])->samples[j-1]);
.//Ray/rayKey.cpp:270:				else{((ParameterSamples<QuaternionAndTranslation>*)sampleData[i])->samples[j]=keyFile[j][i];}
.//Ray/rayKey.h:6:/** This class stores the matrix samples for all the parameters of the key-frames read out from a .key file */
.//Ray/rayKey.h:21:	/** This method provides access to the i-th row of transformation information.
.//Ray/rayKey.h:22:	  * The ordering is such that the (i,j)-th entry corresponds to the i-th sample of the j-th parameter.*/
.//Ray/rayKey.h:24:	/** This method returns the name of the i-th parameter */
.//Ray/rayKey.h:26:	/** This method returns the index of the parameter with the specified name. -1 is returned if no parameter matches the name. */
.//Ray/rayKey.h:28:	/** This method returns the number of key-frames stored. */
.//Ray/rayKey.h:50:	/** This method sets the RayKeyData object from a collection of key-frame transformations, using the specified type to indicate how the transformations
.//Ray/rayKey.h:53:	/** Tis method updates the in-between value of all the parameters, using the interpolation/approximation method specified by curveType. */
.//Ray/rayKey.h:56:	/** This method returns a ParametrizedRayGroup object which links to the in-between value of the i-th parameter.*/
.//Ray/rayLight.h:19:	// Ray-Tracing stuff //
.//Ray/rayPointLight.h:5:/** This class describes a point-light light-source. This light has a fixed 
.//Ray/rayPointLight.h:6:  * position and the light attenuates as function of the distance from the light-source.
.//Ray/rayPointLight.h:10:	/** The position of the spot-light */
.//Ray/rayPointLight.h:25:	// Ray-Tracing stuff //
.//Ray/rayPointLight.todo.cpp:11://  Ray-tracing stuff //
.//Ray/rayScene.cpp:39:	index=-1;
.//Ray/rayScene.cpp:44:	this->foo[0]=0;
.//Ray/rayScene.cpp:57:		if(foo[strlen(foo)-1]=='!'){foo[strlen(foo)-1]='\0';}
.//Ray/rayScene.cpp:64:	if(!tex){i=-1;}
.//Ray/rayScene.cpp:65:	else{i=tex->index;}
.//Ray/rayScene.cpp:91:	if(!img->ReadImage(filename)){
.//Ray/rayScene.cpp:120:	if(fscanf(fp," %s",filename) != 1 || !scene->read(filename,transformType)){
.//Ray/rayScene.cpp:182:	if(camera){camera->write(fp);}
.//Ray/rayScene.cpp:194:		for(i=0;i<lightNum;i++){lights[i]->write(fp);}
.//Ray/rayScene.cpp:216:	for(i=0;i<group->shapeNum();i++){group->shapes[i]->write(0,fp);}
.//Ray/rayScene.cpp:233:	int indL=-1, indM=-1, indT=-1,indRF=-1,indV=-1,indK=-1;
.//Ray/rayScene.cpp:239:	group->set(Matrix4D::IdentityMatrix());
.//Ray/rayScene.cpp:242:	lightNum=-1;
.//Ray/rayScene.cpp:243:	textureNum=-1;
.//Ray/rayScene.cpp:244:	materialNum=-1;
.//Ray/rayScene.cpp:245:	rayFileNum=-1;
.//Ray/rayScene.cpp:246:	vertexNum=-1;
.//Ray/rayScene.cpp:247:	keyFileNum=-1;
.//Ray/rayScene.cpp:277:				if(!camera->read(fp)){
.//Ray/rayScene.cpp:344:			if(lightNum>-1){
.//Ray/rayScene.cpp:375:			if(textureNum>-1){
.//Ray/rayScene.cpp:406:			if(materialNum>-1){
.//Ray/rayScene.cpp:439:			if(vertexNum>-1){
.//Ray/rayScene.cpp:470:			if(rayFileNum>-1){ParseLineError(cmndCtr,"attempted to define ray_file_num more than once\n");}
.//Ray/rayScene.cpp:483:		//Next we try read out the number of key-files. We make sure that we have
.//Ray/rayScene.cpp:485:		//of key-files is only specified once. Once we have a "good" ray file
.//Ray/rayScene.cpp:490:			if(keyFileNum>-1){ParseLineError(cmndCtr,"attempted to define key_file_num more than once\n");}
.//Ray/rayScene.cpp:516:			if(textureNum == -1){
.//Ray/rayScene.cpp:537:			if(materialNum==-1){
.//Ray/rayScene.cpp:549:					if(temp==-1){materials[indM].tex=NULL;}
.//Ray/rayScene.cpp:570:			if(vertexNum==-1){
.//Ray/rayScene.cpp:587:			if(rayFileNum==-1){ParseLineError(cmndCtr,"attempted to define ray_files before ray_file_num\n");}
.//Ray/rayScene.cpp:602:			if(lightNum==-1){ParseLineError(cmndCtr,"attempted to define lights before light_num\n");}
.//Ray/rayScene.cpp:610:				if(!lights[indL]->read(fp)){ParseLineError(cmndCtr,"failed to parse light\n");}
.//Ray/rayScene.cpp:618:			if(keyFileNum==-1){ParseLineError(cmndCtr,"attempted to define key_files before key_file_num\n");}
.//Ray/rayScene.cpp:640:		//We check if we have come to the end of a scene-graph group. If we have
.//Ray/rayScene.cpp:656:	if(indL<(lightNum-1)){ParseError("Couldn't find enough lights for light_num");}
.//Ray/rayScene.cpp:657:	if(indM<(materialNum-1)){ParseError("Couldn't find enough materials for material_num");}
.//Ray/rayScene.cpp:658:	if(indT<(textureNum-1)){ParseError("Couldn't find enough textures for texture_num");}
.//Ray/rayScene.cpp:659:	if(indRF<(rayFileNum-1)){ParseError("Couldn't find enough ray_files for ray_file_num");}
.//Ray/rayScene.cpp:660:	if(lightNum==-1){lightNum=0;}
.//Ray/rayScene.cpp:661:	if(materialNum==-1){materialNum=0;}
.//Ray/rayScene.cpp:662:	if(textureNum==-1){textureNum=0;}
.//Ray/rayScene.cpp:663:	if(rayFileNum==-1){rayFileNum=0;}
.//Ray/rayScene.cpp:664:	if(vertexNum==-1){vertexNum=0;}
.//Ray/rayScene.cpp:673:	if(!newNode || !((StaticRayGroup*)newNode)->read(fp)){ParseLineError(cmndCtr,"failed to allocate memory for StaticGroup\n");}
.//Ray/rayScene.cpp:674:	currNode->addShape(newNode);
.//Ray/rayScene.cpp:682:		/* We check if we have come to the end of a scene-graph group and we
.//Ray/rayScene.cpp:698:	int i,idx=-1;
.//Ray/rayScene.cpp:708:	strcpy(newNode->pName,paramName);
.//Ray/rayScene.cpp:709:	currNode->addShape(newNode);
.//Ray/rayScene.cpp:743:		current->addShape(rayFileInstance);
.//Ray/rayScene.cpp:751:		if(!sphere || !sphere->read(fp,&temp)){ParseLineError(cmndCtr,"failed to allocate memory for Sphere\n");}
.//Ray/rayScene.cpp:754:		else{sphere->material=&(materials[temp]);}
.//Ray/rayScene.cpp:755:		current->addShape(sphere);
.//Ray/rayScene.cpp:761:		if (!box || !box->read(fp,&temp)){ParseLineError(cmndCtr,"failed to allocate memory for Box\n");}
.//Ray/rayScene.cpp:764:		else{box->material=&(materials[temp]);}
.//Ray/rayScene.cpp:765:		current->addShape(box);
.//Ray/rayScene.cpp:771:		if(!cone || !cone->read(fp,&temp)){ParseLineError(cmndCtr,"failed to allocate memory for Cone\n");}
.//Ray/rayScene.cpp:774:		else{cone->material=&(materials[temp]);}
.//Ray/rayScene.cpp:775:		current->addShape(cone);
.//Ray/rayScene.cpp:781:		if (!cylinder || !cylinder->read(fp,&temp)){ParseLineError(cmndCtr,"failed to allocate memory for Cylinder\n");}
.//Ray/rayScene.cpp:784:		else{cylinder->material=&(materials[temp]);}
.//Ray/rayScene.cpp:785:		current->addShape(cylinder);
.//Ray/rayScene.cpp:791:		if(!triangle->read(fp,&temp,vertices,vertexNum)){
.//Ray/rayScene.cpp:797:		else{triangle->material=&(materials[temp]);}
.//Ray/rayScene.cpp:798:		current->addShape(triangle);
.//Ray/rayScene.cpp:808:	for(i=0;i<rayFileNum;i++){rayFiles[i].scene->setUpOpenGL(cplx);}
.//Ray/rayScene.cpp:810:	group->setUpOpenGL(cplx,1);
.//Ray/rayScene.cpp:813:	camera->drawOpenGL();
.//Ray/rayScene.cpp:816:	for(int i=0;i<lightNum;i++){lights[i]->drawOpenGL(i);}	
.//Ray/rayScene.cpp:818:	group->drawOpenGL(-1);
.//Ray/rayScene.cpp:824:		tt-=(int)tt;
.//Ray/rayScene.cpp:827:	for(i=0;i<rayFileNum;i++){rayFiles[i].scene->setCurrentTime(t,curveFit);}
.//Ray/rayScene.cpp:838:	ray.position=camera->position;
.//Ray/rayScene.cpp:843:			ray=GetRay(camera,i,height-j-1,width,height);
.//Ray/rayScene.h:65:	/** The coefficient for the specular fall-off of the material */
.//Ray/rayScene.h:111:/** This class stores information about the scene-graph read out from a .ray file. */
.//Ray/rayScene.h:123:	/** This method reads in ray-file name from the .ray file and reads the scene-graph from the specified file.*/
.//Ray/rayScene.h:125:	/** This method writes out ray-file name to a .ray file. If no file is specified,
.//Ray/rayScene.h:126:	  * the ray-file name is written out to stdout. */
.//Ray/rayScene.h:160:	/** The root of the scene-graph */
.//Ray/rayScene.h:169:	/** This method reads in the scene-graph from a .ray file. */
.//Ray/rayScene.h:171:	/** This method reads in the scene-graph from a .ray file. */
.//Ray/rayScene.h:173:	/** This method writes out the scene-graph to a .ray file. */
.//Ray/rayScene.h:175:	/** This method writes out the scene-graph to a .ray file. If no file is specified the scene-graph is written out stdout. */
.//Ray/rayScene.h:179:	// Ray-Tracing stuff //
.//Ray/rayScene.h:195:	/** This is the function responsible for the recursive ray-tracing returning the color obtained
.//Ray/rayScene.h:197:	  * or the contribution from subsequent bounces is guaranteed to be less than the cut-off.\n
.//Ray/rayScene.todo.cpp:11:// Ray-tracing stuff //
.//Ray/rayShape.h:7:/** This is the abstract class that all ray-traceable objects must implement. */
.//Ray/rayShape.h:21:	// Ray-Tracing stuff //
.//Ray/rayShape.h:26:	  * set and a value greater than 0 is returned. Otherwise, -1 is returned. (This is useful for
.//Ray/rayShape.h:30:	virtual double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1)=0;
.//Ray/raySphere.cpp:23:	fprintf(fp,"#shape_sphere %d\n",material->index);
.//Ray/raySphere.h:27:	// Ray-Tracing stuff //
.//Ray/raySphere.h:29:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//Ray/raySphere.todo.cpp:7://  Ray-tracing stuff //
.//Ray/raySphere.todo.cpp:10:	return -1;
.//Ray/raySphere.todo.cpp:14:	bBox=BoundingBox3D(center+p,center-p);
.//Ray/raySphere.todo.cpp:25:	return -1;  // TODO: Return something real
.//Ray/raySpotLight.h:5:/** This class describes a spot-light light-source. This light has a fixed 
.//Ray/raySpotLight.h:7:  * function of the distance from the light-source and the angle between the
.//Ray/raySpotLight.h:14:	/** The position of the spot-light */
.//Ray/raySpotLight.h:26:	/** The cut-off angle for the spot light (should be in the range [0,Pi/2]) */
.//Ray/raySpotLight.h:28:	/** The rate at which the intensity falls off as light travels in the non-preferred direction (should be in the range [0,128]) */
.//Ray/raySpotLight.h:37:	// Ray-Tracing stuff //
.//Ray/raySpotLight.todo.cpp:12://  Ray-tracing stuff //
.//Ray/raySpotLight.todo.cpp:36:    // Spotlight-specific params
.//Ray/rayTriangle.cpp:35:	fprintf(fp,"#shape_triangle %d\n",material->index);
.//Ray/rayTriangle.cpp:37:	fprintf(fp,"  %d %d %d\n",v[0]->index,v[1]->index,v[2]->index);
.//Ray/rayTriangle.h:35:	// Ray-Tracing stuff //
.//Ray/rayTriangle.h:37:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//Ray/rayTriangle.todo.cpp:7://  Ray-tracing stuff //
.//Ray/rayTriangle.todo.cpp:12:	return -1;
.//Ray/rayTriangle.todo.cpp:16:	pList[0]=v[0]->position;
.//Ray/rayTriangle.todo.cpp:17:	pList[1]=v[1]->position;
.//Ray/rayTriangle.todo.cpp:18:	pList[2]=v[2]->position;
.//Ray/rayTriangle.todo.cpp:21:		bBox.p[0][i]-=RAYEPS;
.//Ray/rayTriangle.todo.cpp:32:        Point3D curNormal = v[0]->position.crossProduct( v[1]->position );
.//Ray/rayTriangle.todo.cpp:34:        glVertex3f( v[0]->position.p[0], v[0]->position.p[1], v[0]->position.p[2] );
.//Ray/rayTriangle.todo.cpp:36:        curNormal = v[1]->position.crossProduct( v[2]->position );
.//Ray/rayTriangle.todo.cpp:38:        glVertex3f( v[1]->position.p[0], v[1]->position.p[1], v[1]->position.p[2] );
.//Ray/rayTriangle.todo.cpp:40:        curNormal = v[2]->position.crossProduct( v[0]->position );
.//Ray/rayTriangle.todo.cpp:42:        glVertex3f( v[2]->position.p[0], v[2]->position.p[1], v[2]->position.p[2] );
.//Ray/rayTriangle.todo.cpp:44:	return -1;
.//Ray/rayWindow.cpp:62:/** This function writes out the specified string, left-aligned, at the specified location, onto the OpenGL window. */
.//Ray/rayWindow.cpp:93:/** This function writes out the specified string, right-aligned, at the specified location, onto the OpenGL window. */
.//Ray/rayWindow.cpp:98:	WriteLeftString(vp[2]-x-glutBitmapLength(GLUT_BITMAP_HELVETICA_18,(unsigned char*) str),y,str);
.//Ray/rayWindow.cpp:117:			temp=0+j*3+(vp[3]-i-1)*(vp[2])*3;
.//Ray/rayWindow.cpp:119:			temp=1+j*3+(vp[3]-i-1)*(vp[2])*3;
.//Ray/rayWindow.cpp:121:			temp=2+j*3+(vp[3]-i-1)*(vp[2])*3;
.//Ray/rayWindow.cpp:133:	scene->setCurrentTime(GetTime()-startTime,curveFit);
.//Ray/rayWindow.cpp:155:		scene->camera->rotateUp(center,0.01*d[0]);
.//Ray/rayWindow.cpp:156:		scene->camera->rotateRight(center,0.01*d[1]);
.//Ray/rayWindow.cpp:159:		scene->camera->moveForward(radius/15*d[1]);
.//Ray/rayWindow.cpp:162:		scene->camera->moveRight(-radius/250*d[0]);
.//Ray/rayWindow.cpp:163:		scene->camera->moveUp(radius/250*d[1]);
.//Ray/rayWindow.cpp:195:				scene->camera->position[0],scene->camera->position[1],scene->camera->position[2],
.//Ray/rayWindow.cpp:196:				scene->camera->direction[0],scene->camera->direction[1],scene->camera->direction[2],
.//Ray/rayWindow.cpp:197:				scene->camera->up[0],scene->camera->up[1],scene->camera->up[2]);
.//Ray/rayWindow.cpp:255:/** This function is called when the user updates the draw mode in the drop-down menu. */
.//Ray/rayWindow.cpp:261:/** This function is called when the user updates the cull mode in the drop-down menu. */
.//Ray/rayWindow.cpp:271:/** This function is called when the user updates the curve fitting method in the drop-down menu. */
.//Ray/rayWindow.cpp:277:/** This function is called when the user selects one of the main menu options in the drop-down menu. */
.//Ray/rayWindow.cpp:293:	float d=radius+(scene->camera->position-center).length();
.//Ray/rayWindow.cpp:299:	gluPerspective(scene->camera->heightAngle*180.0/PI,scene->camera->aspectRatio,.1*d,2*d);
.//Ray/rayWindow.cpp:304:	if(drawMode[0]==GL_FILL){scene->drawOpenGL();}
.//Ray/rayWindow.cpp:310:		scene->drawOpenGL();
.//Ray/rayWindow.cpp:317:		scene->drawOpenGL();
.//Ray/rayWindow.cpp:327:		frameRate=10/(frameCountStart-t);
.//Ray/rayWindow.cpp:347:	scene->camera->aspectRatio=(float)width/(float)height;
.//Ray/rayWindow.cpp:364:	BoundingBox3D b=scene->group->setBoundingBox();
.//Ray/rayWindow.cpp:366:	radius=(b.p[0]-b.p[1]).length()/2;
.//Ray/rayWindow.cpp:375:	glClearColor(scene->background[0],scene->background[1],scene->background[2],1.0);
.//Ray/rayWindow.cpp:402:	glutAddMenuEntry(" Catmull-Rom Interpolation ",CATMULL_ROM);
.//Ray/rayWindow.cpp:403:	glutAddMenuEntry(" Uniform Cubic B-Spline Approximation ", UNIFORM_CUBIC_B_SPLINE);
.//Ray/rayWindow.cpp:411:	// Attach the drop-down menu to the right button
.//Ray/rayWindow.cpp:424:	scene->setUpOpenGL(cplx);
.//Ray/rayWindow.h:15:		/** A value indicating that back-face culling should be used */
.//Ray/rayWindow.h:17:		/** A value indicating that front-face culling should be used */
.//Ray/rayWindow.h:49:	/** This function writes out the specified string, left-aligned, at the specified location, onto the OpenGL window. */
.//Ray/rayWindow.h:51:	/** This function writes out the specified string, right-aligned, at the specified location, onto the OpenGL window. */
.//Ray/rayWindow.h:81:	/** This function is called when the user updates the draw mode in the drop-down menu. */
.//Ray/rayWindow.h:83:	/** This function is called when the user updates the cull mode in the drop-down menu. */
.//Ray/rayWindow.h:85:	/** This function is called when the user updates the curve fitting method in the drop-down menu. */
.//Ray/rayWindow.h:87:	/** This function is called when the user selects one of the main menu options in the drop-down menu. */
.//SVD/Image/bmp.cpp:11:typedef unsigned short int WORD;	/* 16-bit unsigned integer. */
.//SVD/Image/bmp.cpp:12:typedef unsigned int DWORD;			/* 32-bit unsigned integer */
.//SVD/Image/bmp.cpp:13:typedef int LONG;					/* 32-bit signed integer */
.//SVD/Image/bmp.cpp:252:    /* ignore bmih.biClrUsed - we assume a true color display, and
.//SVD/Image/bmp.cpp:254:    /* ignore bmih.biClrImportant - same reason */
.//SVD/Image/bmp.cpp:282:				img(x,img.height()-y-1)=p;
.//SVD/Image/bmp.cpp:374:			p=img(x,img.height()-y-1);
.//SVD/Image/bmp.cpp:378:			/* putc(p->a, fp), nbytes++; */
.//SVD/Image/bmp.cpp:381:		/* Padding for 32-bit boundary */
.//SVD/Image/image.cpp:89:	// Generate the in-between line segment pairs
.//SVD/Image/image.cpp:99:	// Generate the in-between morphs
.//SVD/Image/image.cpp:102:	// Cross-dissolve to get the final image
.//SVD/Image/image.h:10:/** This structure represents a 4-channel, floating point precision pixel. */
.//SVD/Image/image.h:27:/** This structure represents a 4-channel, 32-bit, RGBA pixel. */
.//SVD/Image/image.h:82:	  * of noise that should be added. The actual amount of noise added is in the range [-noise,noise].
.//SVD/Image/image.h:132:	  * The final pixel values are obtained by using Floyd-Steinberg dithering for propogating quantization errors.
.//SVD/Image/image.h:154:	/** This method scales an image using bilinear-interpolation to obtain pixel values and writes out the new image to outputImage.
.//SVD/Image/image.h:160:	/** This method scales an image using Gaussian-weighting to obtain pixel values and writes out the new image to outputImage.
.//SVD/Image/image.h:172:	/** This method rotates an image using bilinear-interpolation to obtain pixel values and writes out the new image to outputImage.
.//SVD/Image/image.h:178:	/** This method rotates an image using Gaussian-weighting to obtain pixel values and writes out the new image to outputImage.
.//SVD/Image/image.h:185:	/** This method sets the alpha-channel of the current image using the information provided in the matte image.
.//SVD/Image/image.h:191:	  * The method uses the values in the alpha-channel of the overlay image to determine how pixels should be blended.
.//SVD/Image/image.h:204:	/** This method applies a fun-filter to the current image and writes out the new image to outputImage.
.//SVD/Image/image.h:209:	/** This static method applies a Beier-Neely morph and writes out the new image to outputImage.
.//SVD/Image/image.h:211:	  * The time-step parameter, in the range of [0,1], specifies the point in the morph at which the output image should be obtained.
.//SVD/Image/image.h:221:	/** This static method cross-dissolves two image and writes out the new image to outputImage.
.//SVD/Image/image.h:222:	  * The method generates an image which is the blend of the source and destination, using the blend-weight in the range [0,1] to
.//SVD/Image/image.h:229:	/** This method returns the value of the image, sampled at position (x,y) using nearest-point sampling.
.//SVD/Image/image.h:234:	/** This method returns the value of the image, sampled at position (x,y) using bilinear-weighted sampling.
.//SVD/Image/image.h:239:	/** This method returns the value of the image, sampled at position (x,y) using Gaussian-weighted sampling.
.//SVD/Image/jpeg.cpp:17:	/* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
.//SVD/Image/jpeg.cpp:18:	my_error_ptr myerr = (my_error_ptr) cinfo->err;
.//SVD/Image/jpeg.cpp:22:	(*cinfo->err->output_message) (cinfo);
.//SVD/Image/jpeg.cpp:25:	longjmp(myerr->setjmp_buffer, 1);
.//SVD/Image/jpeg.cpp:78:	buffer = (*cinfo.mem->alloc_sarray) ((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);
.//SVD/Image/jpeg.cpp:93:			if(cinfo.output_components==1){img(i,cinfo.output_scanline-1)=p;}
.//SVD/Image/jpeg.cpp:94:			else{img(i/3,cinfo.output_scanline-1)=p;}
.//SVD/Image/lineSegments.cpp:14:	outSegments.x1=(int)(segments1.x1*(1.-weight)+segments2.x1*weight);
.//SVD/Image/lineSegments.cpp:15:	outSegments.y1=(int)(segments1.y1*(1.-weight)+segments2.y1*weight);
.//SVD/Image/lineSegments.cpp:16:	outSegments.x2=(int)(segments1.x2*(1.-weight)+segments2.x2*weight);
.//SVD/Image/lineSegments.cpp:17:	outSegments.y2=(int)(segments1.y2*(1.-weight)+segments2.y2*weight);
.//SVD/Image/lineSegments.cpp:90:		dx=x-targetX;
.//SVD/Image/lineSegments.cpp:91:		dy=y-targetY;
.//SVD/Image/lineSegments.h:14:	/** The coordinates of the end-points of the line segment.*/
.//SVD/Image/lineSegments.h:40:	/** This method sets the values (x,y) to the coordinates of the unit-vector perpendicular to the direction
.//SVD/JPEG/ckconfig.cpp:4: * Copyright (C) 1991-1994, Thomas G. Lane.
.//SVD/JPEG/ckconfig.cpp:30: * We start out with the assumption that your system has all the ANSI-standard
.//SVD/JPEG/ckconfig.cpp:49: * We try the non-BSD convention first; define NEED_BSD_STRINGS
.//SVD/JPEG/ckconfig.cpp:77: * says "typedef something-or-other size_t;".  Then, change the line below
.//SVD/JPEG/ckconfig.cpp:93:/* The next question is whether your compiler supports ANSI-style function
.//SVD/JPEG/ckconfig.cpp:105:struct methods_struct {		/* check method-pointer declarations */
.//SVD/JPEG/ckconfig.cpp:252:  else if (arg != -67) {	/* expected result for signed char */
.//SVD/JPEG/ckconfig.cpp:266:/* See whether right-shift on a long is signed or not. */
.//SVD/JPEG/ckconfig.cpp:270:  if (res == -0x7F7E80CL) {	/* expected result for signed shift */
.//SVD/JPEG/ckconfig.cpp:273:  /* see if unsigned-shift hack will fix it. */
.//SVD/JPEG/ckconfig.cpp:275:  res |= (~0L) << (32-4);
.//SVD/JPEG/ckconfig.cpp:276:  if (res == -0x7F7E80CL) {	/* expected result now? */
.//SVD/JPEG/ckconfig.cpp:293:  char signed_char_check = (char) (-67);
.//SVD/JPEG/ckconfig.cpp:303:  fprintf(outfile, "/* jconfig.h --- generated by ckconfig.c */\n");
.//SVD/JPEG/ckconfig.cpp:366:  if (is_shifting_signed(-0x7F7E80B1L))
.//SVD/JPEG/ckconfig.cpp:377:  fprintf(outfile, "#undef TWO_FILE_COMMANDLINE	/* You may need this on non-Unix systems */\n");
.//SVD/JPEG/jcapimin.cpp:4: * Copyright (C) 1994-1998, Thomas G. Lane.
.//SVD/JPEG/jcapimin.cpp:10: * needed in either the normal full-compression case or the transcoding-only
.//SVD/JPEG/jcapimin.cpp:15: * parameter-setup helper routines, jcomapi.c for routines shared by
.//SVD/JPEG/jcapimin.cpp:35:  cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
.//SVD/JPEG/jcapimin.cpp:49:    struct jpeg_error_mgr * err = cinfo->err;
.//SVD/JPEG/jcapimin.cpp:50:    void * client_data = cinfo->client_data; /* ignore Purify complaint here */
.//SVD/JPEG/jcapimin.cpp:52:    cinfo->err = err;
.//SVD/JPEG/jcapimin.cpp:53:    cinfo->client_data = client_data;
.//SVD/JPEG/jcapimin.cpp:55:  cinfo->is_decompressor = FALSE;
.//SVD/JPEG/jcapimin.cpp:61:  cinfo->progress = NULL;
.//SVD/JPEG/jcapimin.cpp:62:  cinfo->dest = NULL;
.//SVD/JPEG/jcapimin.cpp:64:  cinfo->comp_info = NULL;
.//SVD/JPEG/jcapimin.cpp:67:    cinfo->quant_tbl_ptrs[i] = NULL;
.//SVD/JPEG/jcapimin.cpp:70:    cinfo->dc_huff_tbl_ptrs[i] = NULL;
.//SVD/JPEG/jcapimin.cpp:71:    cinfo->ac_huff_tbl_ptrs[i] = NULL;
.//SVD/JPEG/jcapimin.cpp:74:  cinfo->script_space = NULL;
.//SVD/JPEG/jcapimin.cpp:76:  cinfo->input_gamma = 1.0;	/* in case application forgets */
.//SVD/JPEG/jcapimin.cpp:79:  cinfo->global_state = CSTATE_START;
.//SVD/JPEG/jcapimin.cpp:107: * Forcibly suppress or un-suppress all quantization and Huffman tables.
.//SVD/JPEG/jcapimin.cpp:114: * since it is called by jpeg_start_compress, we put it here --- otherwise
.//SVD/JPEG/jcapimin.cpp:126:    if ((qtbl = cinfo->quant_tbl_ptrs[i]) != NULL)
.//SVD/JPEG/jcapimin.cpp:127:      qtbl->sent_table = suppress;
.//SVD/JPEG/jcapimin.cpp:131:    if ((htbl = cinfo->dc_huff_tbl_ptrs[i]) != NULL)
.//SVD/JPEG/jcapimin.cpp:132:      htbl->sent_table = suppress;
.//SVD/JPEG/jcapimin.cpp:133:    if ((htbl = cinfo->ac_huff_tbl_ptrs[i]) != NULL)
.//SVD/JPEG/jcapimin.cpp:134:      htbl->sent_table = suppress;
.//SVD/JPEG/jcapimin.cpp:151:  if (cinfo->global_state == CSTATE_SCANNING ||
.//SVD/JPEG/jcapimin.cpp:152:      cinfo->global_state == CSTATE_RAW_OK) {
.//SVD/JPEG/jcapimin.cpp:154:    if (cinfo->next_scanline < cinfo->image_height)
.//SVD/JPEG/jcapimin.cpp:156:    (*cinfo->master->finish_pass) (cinfo);
.//SVD/JPEG/jcapimin.cpp:157:  } else if (cinfo->global_state != CSTATE_WRCOEFS)
.//SVD/JPEG/jcapimin.cpp:158:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jcapimin.cpp:160:  while (! cinfo->master->is_last_pass) {
.//SVD/JPEG/jcapimin.cpp:161:    (*cinfo->master->prepare_for_pass) (cinfo);
.//SVD/JPEG/jcapimin.cpp:162:    for (iMCU_row = 0; iMCU_row < cinfo->total_iMCU_rows; iMCU_row++) {
.//SVD/JPEG/jcapimin.cpp:163:      if (cinfo->progress != NULL) {
.//SVD/JPEG/jcapimin.cpp:164:	cinfo->progress->pass_counter = (long) iMCU_row;
.//SVD/JPEG/jcapimin.cpp:165:	cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows;
.//SVD/JPEG/jcapimin.cpp:166:	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//SVD/JPEG/jcapimin.cpp:171:      if (! (*cinfo->coef->compress_data) (cinfo, (JSAMPIMAGE) NULL))
.//SVD/JPEG/jcapimin.cpp:174:    (*cinfo->master->finish_pass) (cinfo);
.//SVD/JPEG/jcapimin.cpp:177:  (*cinfo->marker->write_file_trailer) (cinfo);
.//SVD/JPEG/jcapimin.cpp:178:  (*cinfo->dest->term_destination) (cinfo);
.//SVD/JPEG/jcapimin.cpp:197:  if (cinfo->next_scanline != 0 ||
.//SVD/JPEG/jcapimin.cpp:198:      (cinfo->global_state != CSTATE_SCANNING &&
.//SVD/JPEG/jcapimin.cpp:199:       cinfo->global_state != CSTATE_RAW_OK &&
.//SVD/JPEG/jcapimin.cpp:200:       cinfo->global_state != CSTATE_WRCOEFS))
.//SVD/JPEG/jcapimin.cpp:201:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jcapimin.cpp:203:  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);
.//SVD/JPEG/jcapimin.cpp:204:  write_marker_byte = cinfo->marker->write_marker_byte;	/* copy for speed */
.//SVD/JPEG/jcapimin.cpp:205:  while (datalen--) {
.//SVD/JPEG/jcapimin.cpp:216:  if (cinfo->next_scanline != 0 ||
.//SVD/JPEG/jcapimin.cpp:217:      (cinfo->global_state != CSTATE_SCANNING &&
.//SVD/JPEG/jcapimin.cpp:218:       cinfo->global_state != CSTATE_RAW_OK &&
.//SVD/JPEG/jcapimin.cpp:219:       cinfo->global_state != CSTATE_WRCOEFS))
.//SVD/JPEG/jcapimin.cpp:220:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jcapimin.cpp:222:  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);
.//SVD/JPEG/jcapimin.cpp:228:  (*cinfo->marker->write_marker_byte) (cinfo, val);
.//SVD/JPEG/jcapimin.cpp:250: * will not re-emit the tables unless it is passed write_all_tables=TRUE.
.//SVD/JPEG/jcapimin.cpp:256:  if (cinfo->global_state != CSTATE_START)
.//SVD/JPEG/jcapimin.cpp:257:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jcapimin.cpp:260:  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
.//SVD/JPEG/jcapimin.cpp:261:  (*cinfo->dest->init_destination) (cinfo);
.//SVD/JPEG/jcapimin.cpp:265:  (*cinfo->marker->write_tables_only) (cinfo);
.//SVD/JPEG/jcapimin.cpp:267:  (*cinfo->dest->term_destination) (cinfo);
.//SVD/JPEG/jcapistd.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jcapistd.cpp:10: * used in the normal full-compression case.  They are not used by a
.//SVD/JPEG/jcapistd.cpp:11: * transcoding-only application.  Note that if an application links in
.//SVD/JPEG/jcapistd.cpp:40:  if (cinfo->global_state != CSTATE_START)
.//SVD/JPEG/jcapistd.cpp:41:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jcapistd.cpp:47:  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
.//SVD/JPEG/jcapistd.cpp:48:  (*cinfo->dest->init_destination) (cinfo);
.//SVD/JPEG/jcapistd.cpp:52:  (*cinfo->master->prepare_for_pass) (cinfo);
.//SVD/JPEG/jcapistd.cpp:56:  cinfo->next_scanline = 0;
.//SVD/JPEG/jcapistd.cpp:57:  cinfo->global_state = (cinfo->raw_data_in ? CSTATE_RAW_OK : CSTATE_SCANNING);
.//SVD/JPEG/jcapistd.cpp:72: * so that the application need not adjust num_lines for end-of-image
.//SVD/JPEG/jcapistd.cpp:73: * when using a multiple-scanline buffer.
.//SVD/JPEG/jcapistd.cpp:82:  if (cinfo->global_state != CSTATE_SCANNING)
.//SVD/JPEG/jcapistd.cpp:83:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jcapistd.cpp:84:  if (cinfo->next_scanline >= cinfo->image_height)
.//SVD/JPEG/jcapistd.cpp:88:  if (cinfo->progress != NULL) {
.//SVD/JPEG/jcapistd.cpp:89:    cinfo->progress->pass_counter = (long) cinfo->next_scanline;
.//SVD/JPEG/jcapistd.cpp:90:    cinfo->progress->pass_limit = (long) cinfo->image_height;
.//SVD/JPEG/jcapistd.cpp:91:    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//SVD/JPEG/jcapistd.cpp:99:  if (cinfo->master->call_pass_startup)
.//SVD/JPEG/jcapistd.cpp:100:    (*cinfo->master->pass_startup) (cinfo);
.//SVD/JPEG/jcapistd.cpp:103:  rows_left = cinfo->image_height - cinfo->next_scanline;
.//SVD/JPEG/jcapistd.cpp:108:  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, num_lines);
.//SVD/JPEG/jcapistd.cpp:109:  cinfo->next_scanline += row_ctr;
.//SVD/JPEG/jcapistd.cpp:125:  if (cinfo->global_state != CSTATE_RAW_OK)
.//SVD/JPEG/jcapistd.cpp:126:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jcapistd.cpp:127:  if (cinfo->next_scanline >= cinfo->image_height) {
.//SVD/JPEG/jcapistd.cpp:133:  if (cinfo->progress != NULL) {
.//SVD/JPEG/jcapistd.cpp:134:    cinfo->progress->pass_counter = (long) cinfo->next_scanline;
.//SVD/JPEG/jcapistd.cpp:135:    cinfo->progress->pass_limit = (long) cinfo->image_height;
.//SVD/JPEG/jcapistd.cpp:136:    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//SVD/JPEG/jcapistd.cpp:144:  if (cinfo->master->call_pass_startup)
.//SVD/JPEG/jcapistd.cpp:145:    (*cinfo->master->pass_startup) (cinfo);
.//SVD/JPEG/jcapistd.cpp:148:  lines_per_iMCU_row = cinfo->max_v_samp_factor * DCTSIZE;
.//SVD/JPEG/jcapistd.cpp:153:  if (! (*cinfo->coef->compress_data) (cinfo, data)) {
.//SVD/JPEG/jcapistd.cpp:159:  cinfo->next_scanline += lines_per_iMCU_row;
.//SVD/JPEG/jccoefct.cpp:4: * Copyright (C) 1994-1997, Thomas G. Lane.
.//SVD/JPEG/jccoefct.cpp:10: * The coefficient buffer lies between forward-DCT and entropy encoding steps.
.//SVD/JPEG/jccoefct.cpp:18:/* We use a full-image coefficient buffer when doing Huffman optimization,
.//SVD/JPEG/jccoefct.cpp:19: * and also for writing multiple-scan JPEG files.  In all cases, the DCT
.//SVD/JPEG/jccoefct.cpp:42:  /* For single-pass compression, it's sufficient to buffer just one MCU
.//SVD/JPEG/jccoefct.cpp:48:   * In multi-pass modes, this array points to the current MCU's blocks
.//SVD/JPEG/jccoefct.cpp:53:  /* In multi-pass modes, we need a virtual block array for each component. */
.//SVD/JPEG/jccoefct.cpp:73:/* Reset within-iMCU-row counters for a new row */
.//SVD/JPEG/jccoefct.cpp:75:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jccoefct.cpp:81:  if (cinfo->comps_in_scan > 1) {
.//SVD/JPEG/jccoefct.cpp:82:    coef->MCU_rows_per_iMCU_row = 1;
.//SVD/JPEG/jccoefct.cpp:84:    if (coef->iMCU_row_num < (cinfo->total_iMCU_rows-1))
.//SVD/JPEG/jccoefct.cpp:85:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
.//SVD/JPEG/jccoefct.cpp:87:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
.//SVD/JPEG/jccoefct.cpp:90:  coef->mcu_ctr = 0;
.//SVD/JPEG/jccoefct.cpp:91:  coef->MCU_vert_offset = 0;
.//SVD/JPEG/jccoefct.cpp:102:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jccoefct.cpp:104:  coef->iMCU_row_num = 0;
.//SVD/JPEG/jccoefct.cpp:109:    if (coef->whole_image[0] != NULL)
.//SVD/JPEG/jccoefct.cpp:111:    coef->pub.compress_data = compress_data;
.//SVD/JPEG/jccoefct.cpp:115:    if (coef->whole_image[0] == NULL)
.//SVD/JPEG/jccoefct.cpp:117:    coef->pub.compress_data = compress_first_pass;
.//SVD/JPEG/jccoefct.cpp:120:    if (coef->whole_image[0] == NULL)
.//SVD/JPEG/jccoefct.cpp:122:    coef->pub.compress_data = compress_output;
.//SVD/JPEG/jccoefct.cpp:133: * Process some data in the single-pass case.
.//SVD/JPEG/jccoefct.cpp:145:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jccoefct.cpp:147:  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
.//SVD/JPEG/jccoefct.cpp:148:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//SVD/JPEG/jccoefct.cpp:154:  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
.//SVD/JPEG/jccoefct.cpp:156:    for (MCU_col_num = coef->mcu_ctr; MCU_col_num <= last_MCU_col;
.//SVD/JPEG/jccoefct.cpp:168:      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jccoefct.cpp:169:	compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jccoefct.cpp:170:	blockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
.//SVD/JPEG/jccoefct.cpp:171:						: compptr->last_col_width;
.//SVD/JPEG/jccoefct.cpp:172:	xpos = MCU_col_num * compptr->MCU_sample_width;
.//SVD/JPEG/jccoefct.cpp:174:	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
.//SVD/JPEG/jccoefct.cpp:175:	  if (coef->iMCU_row_num < last_iMCU_row ||
.//SVD/JPEG/jccoefct.cpp:176:	      yoffset+yindex < compptr->last_row_height) {
.//SVD/JPEG/jccoefct.cpp:177:	    (*cinfo->fdct->forward_DCT) (cinfo, compptr,
.//SVD/JPEG/jccoefct.cpp:178:					 input_buf[compptr->component_index],
.//SVD/JPEG/jccoefct.cpp:179:					 coef->MCU_buffer[blkn],
.//SVD/JPEG/jccoefct.cpp:181:	    if (blockcnt < compptr->MCU_width) {
.//SVD/JPEG/jccoefct.cpp:183:	      jzero_far((void FAR *) coef->MCU_buffer[blkn + blockcnt],
.//SVD/JPEG/jccoefct.cpp:184:			(compptr->MCU_width - blockcnt) * SIZEOF(JBLOCK));
.//SVD/JPEG/jccoefct.cpp:185:	      for (bi = blockcnt; bi < compptr->MCU_width; bi++) {
.//SVD/JPEG/jccoefct.cpp:186:		coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn+bi-1][0][0];
.//SVD/JPEG/jccoefct.cpp:191:	    jzero_far((void FAR *) coef->MCU_buffer[blkn],
.//SVD/JPEG/jccoefct.cpp:192:		      compptr->MCU_width * SIZEOF(JBLOCK));
.//SVD/JPEG/jccoefct.cpp:193:	    for (bi = 0; bi < compptr->MCU_width; bi++) {
.//SVD/JPEG/jccoefct.cpp:194:	      coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn-1][0][0];
.//SVD/JPEG/jccoefct.cpp:197:	  blkn += compptr->MCU_width;
.//SVD/JPEG/jccoefct.cpp:202:       * re-DCT the MCU on restart (a bit inefficient, could be fixed...)
.//SVD/JPEG/jccoefct.cpp:204:      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
.//SVD/JPEG/jccoefct.cpp:206:	coef->MCU_vert_offset = yoffset;
.//SVD/JPEG/jccoefct.cpp:207:	coef->mcu_ctr = MCU_col_num;
.//SVD/JPEG/jccoefct.cpp:212:    coef->mcu_ctr = 0;
.//SVD/JPEG/jccoefct.cpp:215:  coef->iMCU_row_num++;
.//SVD/JPEG/jccoefct.cpp:224: * Process some data in the first pass of a multi-pass case.
.//SVD/JPEG/jccoefct.cpp:241: * at the scan-dependent variables (MCU dimensions, etc).
.//SVD/JPEG/jccoefct.cpp:247:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jccoefct.cpp:248:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//SVD/JPEG/jccoefct.cpp:256:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jccoefct.cpp:259:    buffer = (*cinfo->mem->access_virt_barray)
.//SVD/JPEG/jccoefct.cpp:260:      ((j_common_ptr) cinfo, coef->whole_image[ci],
.//SVD/JPEG/jccoefct.cpp:261:       coef->iMCU_row_num * compptr->v_samp_factor,
.//SVD/JPEG/jccoefct.cpp:262:       (JDIMENSION) compptr->v_samp_factor, TRUE);
.//SVD/JPEG/jccoefct.cpp:263:    /* Count non-dummy DCT block rows in this iMCU row. */
.//SVD/JPEG/jccoefct.cpp:264:    if (coef->iMCU_row_num < last_iMCU_row)
.//SVD/JPEG/jccoefct.cpp:265:      block_rows = compptr->v_samp_factor;
.//SVD/JPEG/jccoefct.cpp:268:      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
.//SVD/JPEG/jccoefct.cpp:269:      if (block_rows == 0) block_rows = compptr->v_samp_factor;
.//SVD/JPEG/jccoefct.cpp:271:    blocks_across = compptr->width_in_blocks;
.//SVD/JPEG/jccoefct.cpp:272:    h_samp_factor = compptr->h_samp_factor;
.//SVD/JPEG/jccoefct.cpp:276:      ndummy = h_samp_factor - ndummy;
.//SVD/JPEG/jccoefct.cpp:277:    /* Perform DCT for all non-dummy blocks in this iMCU row.  Each call
.//SVD/JPEG/jccoefct.cpp:282:      (*cinfo->fdct->forward_DCT) (cinfo, compptr,
.//SVD/JPEG/jccoefct.cpp:290:	lastDC = thisblockrow[-1][0];
.//SVD/JPEG/jccoefct.cpp:301:    if (coef->iMCU_row_num == last_iMCU_row) {
.//SVD/JPEG/jccoefct.cpp:304:      for (block_row = block_rows; block_row < compptr->v_samp_factor;
.//SVD/JPEG/jccoefct.cpp:307:	lastblockrow = buffer[block_row-1];
.//SVD/JPEG/jccoefct.cpp:311:	  lastDC = lastblockrow[h_samp_factor-1][0];
.//SVD/JPEG/jccoefct.cpp:331: * Process some data in subsequent passes of a multi-pass case.
.//SVD/JPEG/jccoefct.cpp:343:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jccoefct.cpp:355:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jccoefct.cpp:356:    compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jccoefct.cpp:357:    buffer[ci] = (*cinfo->mem->access_virt_barray)
.//SVD/JPEG/jccoefct.cpp:358:      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
.//SVD/JPEG/jccoefct.cpp:359:       coef->iMCU_row_num * compptr->v_samp_factor,
.//SVD/JPEG/jccoefct.cpp:360:       (JDIMENSION) compptr->v_samp_factor, FALSE);
.//SVD/JPEG/jccoefct.cpp:364:  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
.//SVD/JPEG/jccoefct.cpp:366:    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;
.//SVD/JPEG/jccoefct.cpp:370:      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jccoefct.cpp:371:	compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jccoefct.cpp:372:	start_col = MCU_col_num * compptr->MCU_width;
.//SVD/JPEG/jccoefct.cpp:373:	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
.//SVD/JPEG/jccoefct.cpp:375:	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
.//SVD/JPEG/jccoefct.cpp:376:	    coef->MCU_buffer[blkn++] = buffer_ptr++;
.//SVD/JPEG/jccoefct.cpp:381:      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
.//SVD/JPEG/jccoefct.cpp:383:	coef->MCU_vert_offset = yoffset;
.//SVD/JPEG/jccoefct.cpp:384:	coef->mcu_ctr = MCU_col_num;
.//SVD/JPEG/jccoefct.cpp:389:    coef->mcu_ctr = 0;
.//SVD/JPEG/jccoefct.cpp:392:  coef->iMCU_row_num++;
.//SVD/JPEG/jccoefct.cpp:410:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jccoefct.cpp:412:  cinfo->coef = (struct jpeg_c_coef_controller *) coef;
.//SVD/JPEG/jccoefct.cpp:413:  coef->pub.start_pass = start_pass_coef;
.//SVD/JPEG/jccoefct.cpp:418:    /* Allocate a full-image virtual array for each component, */
.//SVD/JPEG/jccoefct.cpp:423:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jccoefct.cpp:425:      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
.//SVD/JPEG/jccoefct.cpp:427:	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
.//SVD/JPEG/jccoefct.cpp:428:				(long) compptr->h_samp_factor),
.//SVD/JPEG/jccoefct.cpp:429:	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
.//SVD/JPEG/jccoefct.cpp:430:				(long) compptr->v_samp_factor),
.//SVD/JPEG/jccoefct.cpp:431:	 (JDIMENSION) compptr->v_samp_factor);
.//SVD/JPEG/jccoefct.cpp:437:    /* We only need a single-MCU buffer. */
.//SVD/JPEG/jccoefct.cpp:442:      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jccoefct.cpp:445:      coef->MCU_buffer[i] = buffer + i;
.//SVD/JPEG/jccoefct.cpp:447:    coef->whole_image[0] = NULL; /* flag for no virtual arrays */
.//SVD/JPEG/jccolor.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//SVD/JPEG/jccolor.cpp:21:  /* Private state for RGB->YCC conversion */
.//SVD/JPEG/jccolor.cpp:28:/**************** RGB -> YCbCr conversion: most common case **************/
.//SVD/JPEG/jccolor.cpp:31: * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
.//SVD/JPEG/jccolor.cpp:32: * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
.//SVD/JPEG/jccolor.cpp:35: *	Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + CENTERJSAMPLE
.//SVD/JPEG/jccolor.cpp:36: *	Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + CENTERJSAMPLE
.//SVD/JPEG/jccolor.cpp:37: * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
.//SVD/JPEG/jccolor.cpp:44: * To avoid floating-point arithmetic, we represent the fractional constants
.//SVD/JPEG/jccolor.cpp:50: * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
.//SVD/JPEG/jccolor.cpp:51: * for 12-bit samples it is still acceptable.  It's not very reasonable for
.//SVD/JPEG/jccolor.cpp:52: * 16-bit samples, but if you want lossless storage you shouldn't be changing
.//SVD/JPEG/jccolor.cpp:54: * The CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included
.//SVD/JPEG/jccolor.cpp:58:#define SCALEBITS	16	/* speediest right-shift on some machines */
.//SVD/JPEG/jccolor.cpp:60:#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
.//SVD/JPEG/jccolor.cpp:82: * Initialize for RGB->YCC colorspace conversion.
.//SVD/JPEG/jccolor.cpp:88:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//SVD/JPEG/jccolor.cpp:93:  cconvert->rgb_ycc_tab = rgb_ycc_tab = (INT32 *)
.//SVD/JPEG/jccolor.cpp:94:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jccolor.cpp:101:    rgb_ycc_tab[i+R_CB_OFF] = (-FIX(0.16874)) * i;
.//SVD/JPEG/jccolor.cpp:102:    rgb_ycc_tab[i+G_CB_OFF] = (-FIX(0.33126)) * i;
.//SVD/JPEG/jccolor.cpp:103:    /* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.
.//SVD/JPEG/jccolor.cpp:105:     * not MAXJSAMPLE+1, and thus that we don't have to range-limit.
.//SVD/JPEG/jccolor.cpp:107:    rgb_ycc_tab[i+B_CB_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;
.//SVD/JPEG/jccolor.cpp:109:    rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;
.//SVD/JPEG/jccolor.cpp:111:    rgb_ycc_tab[i+G_CR_OFF] = (-FIX(0.41869)) * i;
.//SVD/JPEG/jccolor.cpp:112:    rgb_ycc_tab[i+B_CR_OFF] = (-FIX(0.08131)) * i;
.//SVD/JPEG/jccolor.cpp:120: * Note that we change from the application's interleaved-pixel format
.//SVD/JPEG/jccolor.cpp:121: * to our internal noninterleaved, one-plane-per-component format.
.//SVD/JPEG/jccolor.cpp:134:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//SVD/JPEG/jccolor.cpp:136:  register INT32 * ctab = cconvert->rgb_ycc_tab;
.//SVD/JPEG/jccolor.cpp:140:  JDIMENSION num_cols = cinfo->image_width;
.//SVD/JPEG/jccolor.cpp:142:  while (--num_rows >= 0) {
.//SVD/JPEG/jccolor.cpp:154:       * must be too; we do not need an explicit range-limiting operation.
.//SVD/JPEG/jccolor.cpp:175:/**************** Cases other than RGB -> YCbCr **************/
.//SVD/JPEG/jccolor.cpp:180: * This version handles RGB->grayscale conversion, which is the same
.//SVD/JPEG/jccolor.cpp:181: * as the RGB->Y portion of RGB->YCbCr.
.//SVD/JPEG/jccolor.cpp:190:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//SVD/JPEG/jccolor.cpp:192:  register INT32 * ctab = cconvert->rgb_ycc_tab;
.//SVD/JPEG/jccolor.cpp:196:  JDIMENSION num_cols = cinfo->image_width;
.//SVD/JPEG/jccolor.cpp:198:  while (--num_rows >= 0) {
.//SVD/JPEG/jccolor.cpp:218: * This version handles Adobe-style CMYK->YCCK conversion,
.//SVD/JPEG/jccolor.cpp:219: * where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same
.//SVD/JPEG/jccolor.cpp:229:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//SVD/JPEG/jccolor.cpp:231:  register INT32 * ctab = cconvert->rgb_ycc_tab;
.//SVD/JPEG/jccolor.cpp:235:  JDIMENSION num_cols = cinfo->image_width;
.//SVD/JPEG/jccolor.cpp:237:  while (--num_rows >= 0) {
.//SVD/JPEG/jccolor.cpp:245:      r = MAXJSAMPLE - GETJSAMPLE(inptr[0]);
.//SVD/JPEG/jccolor.cpp:246:      g = MAXJSAMPLE - GETJSAMPLE(inptr[1]);
.//SVD/JPEG/jccolor.cpp:247:      b = MAXJSAMPLE - GETJSAMPLE(inptr[2]);
.//SVD/JPEG/jccolor.cpp:248:      /* K passes through as-is */
.//SVD/JPEG/jccolor.cpp:252:       * must be too; we do not need an explicit range-limiting operation.
.//SVD/JPEG/jccolor.cpp:287:  JDIMENSION num_cols = cinfo->image_width;
.//SVD/JPEG/jccolor.cpp:288:  int instride = cinfo->input_components;
.//SVD/JPEG/jccolor.cpp:290:  while (--num_rows >= 0) {
.//SVD/JPEG/jccolor.cpp:304: * This version handles multi-component colorspaces without conversion.
.//SVD/JPEG/jccolor.cpp:317:  int nc = cinfo->num_components;
.//SVD/JPEG/jccolor.cpp:318:  JDIMENSION num_cols = cinfo->image_width;
.//SVD/JPEG/jccolor.cpp:320:  while (--num_rows >= 0) {
.//SVD/JPEG/jccolor.cpp:357:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jccolor.cpp:359:  cinfo->cconvert = (struct jpeg_color_converter *) cconvert;
.//SVD/JPEG/jccolor.cpp:361:  cconvert->pub.start_pass = null_method;
.//SVD/JPEG/jccolor.cpp:364:  switch (cinfo->in_color_space) {
.//SVD/JPEG/jccolor.cpp:366:    if (cinfo->input_components != 1)
.//SVD/JPEG/jccolor.cpp:372:    if (cinfo->input_components != RGB_PIXELSIZE)
.//SVD/JPEG/jccolor.cpp:378:    if (cinfo->input_components != 3)
.//SVD/JPEG/jccolor.cpp:384:    if (cinfo->input_components != 4)
.//SVD/JPEG/jccolor.cpp:389:    if (cinfo->input_components < 1)
.//SVD/JPEG/jccolor.cpp:395:  switch (cinfo->jpeg_color_space) {
.//SVD/JPEG/jccolor.cpp:397:    if (cinfo->num_components != 1)
.//SVD/JPEG/jccolor.cpp:399:    if (cinfo->in_color_space == JCS_GRAYSCALE)
.//SVD/JPEG/jccolor.cpp:400:      cconvert->pub.color_convert = grayscale_convert;
.//SVD/JPEG/jccolor.cpp:401:    else if (cinfo->in_color_space == JCS_RGB) {
.//SVD/JPEG/jccolor.cpp:402:      cconvert->pub.start_pass = rgb_ycc_start;
.//SVD/JPEG/jccolor.cpp:403:      cconvert->pub.color_convert = rgb_gray_convert;
.//SVD/JPEG/jccolor.cpp:404:    } else if (cinfo->in_color_space == JCS_YCbCr)
.//SVD/JPEG/jccolor.cpp:405:      cconvert->pub.color_convert = grayscale_convert;
.//SVD/JPEG/jccolor.cpp:411:    if (cinfo->num_components != 3)
.//SVD/JPEG/jccolor.cpp:413:    if (cinfo->in_color_space == JCS_RGB && RGB_PIXELSIZE == 3)
.//SVD/JPEG/jccolor.cpp:414:      cconvert->pub.color_convert = null_convert;
.//SVD/JPEG/jccolor.cpp:420:    if (cinfo->num_components != 3)
.//SVD/JPEG/jccolor.cpp:422:    if (cinfo->in_color_space == JCS_RGB) {
.//SVD/JPEG/jccolor.cpp:423:      cconvert->pub.start_pass = rgb_ycc_start;
.//SVD/JPEG/jccolor.cpp:424:      cconvert->pub.color_convert = rgb_ycc_convert;
.//SVD/JPEG/jccolor.cpp:425:    } else if (cinfo->in_color_space == JCS_YCbCr)
.//SVD/JPEG/jccolor.cpp:426:      cconvert->pub.color_convert = null_convert;
.//SVD/JPEG/jccolor.cpp:432:    if (cinfo->num_components != 4)
.//SVD/JPEG/jccolor.cpp:434:    if (cinfo->in_color_space == JCS_CMYK)
.//SVD/JPEG/jccolor.cpp:435:      cconvert->pub.color_convert = null_convert;
.//SVD/JPEG/jccolor.cpp:441:    if (cinfo->num_components != 4)
.//SVD/JPEG/jccolor.cpp:443:    if (cinfo->in_color_space == JCS_CMYK) {
.//SVD/JPEG/jccolor.cpp:444:      cconvert->pub.start_pass = rgb_ycc_start;
.//SVD/JPEG/jccolor.cpp:445:      cconvert->pub.color_convert = cmyk_ycck_convert;
.//SVD/JPEG/jccolor.cpp:446:    } else if (cinfo->in_color_space == JCS_YCCK)
.//SVD/JPEG/jccolor.cpp:447:      cconvert->pub.color_convert = null_convert;
.//SVD/JPEG/jccolor.cpp:453:    if (cinfo->jpeg_color_space != cinfo->in_color_space ||
.//SVD/JPEG/jccolor.cpp:454:	cinfo->num_components != cinfo->input_components)
.//SVD/JPEG/jccolor.cpp:456:    cconvert->pub.color_convert = null_convert;
.//SVD/JPEG/jcdctmgr.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jcdctmgr.cpp:8: * This file contains the forward-DCT management logic.
.//SVD/JPEG/jcdctmgr.cpp:28:  /* The actual post-DCT divisors --- not identical to the quant table
.//SVD/JPEG/jcdctmgr.cpp:35:  /* Same as above for the floating-point case. */
.//SVD/JPEG/jcdctmgr.cpp:46: * Verify that all referenced Q-tables are present, and set up
.//SVD/JPEG/jcdctmgr.cpp:56:  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
.//SVD/JPEG/jcdctmgr.cpp:62:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcdctmgr.cpp:64:    qtblno = compptr->quant_tbl_no;
.//SVD/JPEG/jcdctmgr.cpp:67:	cinfo->quant_tbl_ptrs[qtblno] == NULL)
.//SVD/JPEG/jcdctmgr.cpp:69:    qtbl = cinfo->quant_tbl_ptrs[qtblno];
.//SVD/JPEG/jcdctmgr.cpp:72:    switch (cinfo->dct_method) {
.//SVD/JPEG/jcdctmgr.cpp:78:      if (fdct->divisors[qtblno] == NULL) {
.//SVD/JPEG/jcdctmgr.cpp:79:	fdct->divisors[qtblno] = (DCTELEM *)
.//SVD/JPEG/jcdctmgr.cpp:80:	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcdctmgr.cpp:83:      dtbl = fdct->divisors[qtblno];
.//SVD/JPEG/jcdctmgr.cpp:85:	dtbl[i] = ((DCTELEM) qtbl->quantval[i]) << 3;
.//SVD/JPEG/jcdctmgr.cpp:112:	if (fdct->divisors[qtblno] == NULL) {
.//SVD/JPEG/jcdctmgr.cpp:113:	  fdct->divisors[qtblno] = (DCTELEM *)
.//SVD/JPEG/jcdctmgr.cpp:114:	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcdctmgr.cpp:117:	dtbl = fdct->divisors[qtblno];
.//SVD/JPEG/jcdctmgr.cpp:120:	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
.//SVD/JPEG/jcdctmgr.cpp:122:		    CONST_BITS-3);
.//SVD/JPEG/jcdctmgr.cpp:145:	if (fdct->float_divisors[qtblno] == NULL) {
.//SVD/JPEG/jcdctmgr.cpp:146:	  fdct->float_divisors[qtblno] = (FAST_FLOAT *)
.//SVD/JPEG/jcdctmgr.cpp:147:	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcdctmgr.cpp:150:	fdtbl = fdct->float_divisors[qtblno];
.//SVD/JPEG/jcdctmgr.cpp:155:	      (1.0 / (((double) qtbl->quantval[i] *
.//SVD/JPEG/jcdctmgr.cpp:187:  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
.//SVD/JPEG/jcdctmgr.cpp:188:  forward_DCT_method_ptr do_dct = fdct->do_dct;
.//SVD/JPEG/jcdctmgr.cpp:189:  DCTELEM * divisors = fdct->divisors[compptr->quant_tbl_no];
.//SVD/JPEG/jcdctmgr.cpp:196:    /* Load data into workspace, applying unsigned->signed conversion */
.//SVD/JPEG/jcdctmgr.cpp:205:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//SVD/JPEG/jcdctmgr.cpp:206:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//SVD/JPEG/jcdctmgr.cpp:207:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//SVD/JPEG/jcdctmgr.cpp:208:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//SVD/JPEG/jcdctmgr.cpp:209:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//SVD/JPEG/jcdctmgr.cpp:210:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//SVD/JPEG/jcdctmgr.cpp:211:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//SVD/JPEG/jcdctmgr.cpp:212:	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//SVD/JPEG/jcdctmgr.cpp:215:	  for (elemc = DCTSIZE; elemc > 0; elemc--) {
.//SVD/JPEG/jcdctmgr.cpp:216:	    *workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
.//SVD/JPEG/jcdctmgr.cpp:239:	 * (at default quantization settings, more like three-quarters...)
.//SVD/JPEG/jcdctmgr.cpp:252:	  temp = -temp;
.//SVD/JPEG/jcdctmgr.cpp:255:	  temp = -temp;
.//SVD/JPEG/jcdctmgr.cpp:274:/* This version is used for floating-point DCT implementations. */
.//SVD/JPEG/jcdctmgr.cpp:277:  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
.//SVD/JPEG/jcdctmgr.cpp:278:  float_DCT_method_ptr do_dct = fdct->do_float_dct;
.//SVD/JPEG/jcdctmgr.cpp:279:  FAST_FLOAT * divisors = fdct->float_divisors[compptr->quant_tbl_no];
.//SVD/JPEG/jcdctmgr.cpp:286:    /* Load data into workspace, applying unsigned->signed conversion */
.//SVD/JPEG/jcdctmgr.cpp:295:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//SVD/JPEG/jcdctmgr.cpp:296:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//SVD/JPEG/jcdctmgr.cpp:297:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//SVD/JPEG/jcdctmgr.cpp:298:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//SVD/JPEG/jcdctmgr.cpp:299:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//SVD/JPEG/jcdctmgr.cpp:300:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//SVD/JPEG/jcdctmgr.cpp:301:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//SVD/JPEG/jcdctmgr.cpp:302:	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//SVD/JPEG/jcdctmgr.cpp:305:	  for (elemc = DCTSIZE; elemc > 0; elemc--) {
.//SVD/JPEG/jcdctmgr.cpp:307:	      (GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
.//SVD/JPEG/jcdctmgr.cpp:328:	 * The maximum coefficient size is +-16K (for 12-bit data), so this
.//SVD/JPEG/jcdctmgr.cpp:329:	 * code should work for either 16-bit or 32-bit ints.
.//SVD/JPEG/jcdctmgr.cpp:331:	output_ptr[i] = (JCOEF) ((int) (temp + (FAST_FLOAT) 16384.5) - 16384);
.//SVD/JPEG/jcdctmgr.cpp:351:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcdctmgr.cpp:353:  cinfo->fdct = (struct jpeg_forward_dct *) fdct;
.//SVD/JPEG/jcdctmgr.cpp:354:  fdct->pub.start_pass = start_pass_fdctmgr;
.//SVD/JPEG/jcdctmgr.cpp:356:  switch (cinfo->dct_method) {
.//SVD/JPEG/jcdctmgr.cpp:359:    fdct->pub.forward_DCT = forward_DCT;
.//SVD/JPEG/jcdctmgr.cpp:360:    fdct->do_dct = jpeg_fdct_islow;
.//SVD/JPEG/jcdctmgr.cpp:365:    fdct->pub.forward_DCT = forward_DCT;
.//SVD/JPEG/jcdctmgr.cpp:366:    fdct->do_dct = jpeg_fdct_ifast;
.//SVD/JPEG/jcdctmgr.cpp:371:    fdct->pub.forward_DCT = forward_DCT_float;
.//SVD/JPEG/jcdctmgr.cpp:372:    fdct->do_float_dct = jpeg_fdct_float;
.//SVD/JPEG/jcdctmgr.cpp:382:    fdct->divisors[i] = NULL;
.//SVD/JPEG/jcdctmgr.cpp:384:    fdct->float_divisors[i] = NULL;
.//SVD/JPEG/jchuff.cpp:4:* Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jchuff.cpp:30:	INT32 put_buffer;		/* current bit-accumulation buffer */
.//SVD/JPEG/jchuff.cpp:62:	int next_restart_num;		/* next restart number to write (0-7) */
.//SVD/JPEG/jchuff.cpp:100:* Initialize for a Huffman-compressed scan.
.//SVD/JPEG/jchuff.cpp:108:	huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jchuff.cpp:114:		entropy->pub.encode_mcu = encode_mcu_gather;
.//SVD/JPEG/jchuff.cpp:115:		entropy->pub.finish_pass = finish_pass_gather;
.//SVD/JPEG/jchuff.cpp:120:		entropy->pub.encode_mcu = encode_mcu_huff;
.//SVD/JPEG/jchuff.cpp:121:		entropy->pub.finish_pass = finish_pass_huff;
.//SVD/JPEG/jchuff.cpp:124:	for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jchuff.cpp:125:		compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jchuff.cpp:126:		dctbl = compptr->dc_tbl_no;
.//SVD/JPEG/jchuff.cpp:127:		actbl = compptr->ac_tbl_no;
.//SVD/JPEG/jchuff.cpp:138:			if (entropy->dc_count_ptrs[dctbl] == NULL)
.//SVD/JPEG/jchuff.cpp:139:				entropy->dc_count_ptrs[dctbl] = (long *)
.//SVD/JPEG/jchuff.cpp:140:				(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jchuff.cpp:142:			MEMZERO(entropy->dc_count_ptrs[dctbl], 257 * SIZEOF(long));
.//SVD/JPEG/jchuff.cpp:143:			if (entropy->ac_count_ptrs[actbl] == NULL)
.//SVD/JPEG/jchuff.cpp:144:				entropy->ac_count_ptrs[actbl] = (long *)
.//SVD/JPEG/jchuff.cpp:145:				(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jchuff.cpp:147:			MEMZERO(entropy->ac_count_ptrs[actbl], 257 * SIZEOF(long));
.//SVD/JPEG/jchuff.cpp:153:				& entropy->dc_derived_tbls[dctbl]);
.//SVD/JPEG/jchuff.cpp:155:				& entropy->ac_derived_tbls[actbl]);
.//SVD/JPEG/jchuff.cpp:158:		entropy->saved.last_dc_val[ci] = 0;
.//SVD/JPEG/jchuff.cpp:162:	entropy->saved.put_buffer = 0;
.//SVD/JPEG/jchuff.cpp:163:	entropy->saved.put_bits = 0;
.//SVD/JPEG/jchuff.cpp:166:	entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jchuff.cpp:167:	entropy->next_restart_num = 0;
.//SVD/JPEG/jchuff.cpp:189:	/* Note that huffsize[] and huffcode[] are filled in code-length order,
.//SVD/JPEG/jchuff.cpp:190:	* paralleling the order of the symbols themselves in htbl->huffval[].
.//SVD/JPEG/jchuff.cpp:197:		isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
.//SVD/JPEG/jchuff.cpp:204:		(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jchuff.cpp:212:		i = (int) htbl->bits[l];
.//SVD/JPEG/jchuff.cpp:215:		while (i--)
.//SVD/JPEG/jchuff.cpp:248:	MEMZERO(dtbl->ehufsi, SIZEOF(dtbl->ehufsi));
.//SVD/JPEG/jchuff.cpp:250:	/* This is also a convenient place to check for out-of-range
.//SVD/JPEG/jchuff.cpp:258:		i = htbl->huffval[p];
.//SVD/JPEG/jchuff.cpp:259:		if (i < 0 || i > maxsymbol || dtbl->ehufsi[i])
.//SVD/JPEG/jchuff.cpp:261:		dtbl->ehufco[i] = huffcode[p];
.//SVD/JPEG/jchuff.cpp:262:		dtbl->ehufsi[i] = huffsize[p];
.//SVD/JPEG/jchuff.cpp:271:{ *(state)->next_output_byte++ = (JOCTET) (val);  \
.//SVD/JPEG/jchuff.cpp:272:	if (--(state)->free_in_buffer == 0)  \
.//SVD/JPEG/jchuff.cpp:281:	struct jpeg_destination_mgr * dest = state->cinfo->dest;
.//SVD/JPEG/jchuff.cpp:283:	if (! (*dest->empty_output_buffer) (state->cinfo))
.//SVD/JPEG/jchuff.cpp:286:	state->next_output_byte = dest->next_output_byte;
.//SVD/JPEG/jchuff.cpp:287:	state->free_in_buffer = dest->free_in_buffer;
.//SVD/JPEG/jchuff.cpp:295:* left-justified in this part.  At most 16 bits can be passed to emit_bits
.//SVD/JPEG/jchuff.cpp:307:	register int put_bits = state->cur.put_bits;
.//SVD/JPEG/jchuff.cpp:311:		ERREXIT(state->cinfo, JERR_HUFF_MISSING_CODE);
.//SVD/JPEG/jchuff.cpp:313:	put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
.//SVD/JPEG/jchuff.cpp:317:	put_buffer <<= 24 - put_bits; /* align incoming bits */
.//SVD/JPEG/jchuff.cpp:319:	put_buffer |= state->cur.put_buffer; /* and merge with old buffer contents */
.//SVD/JPEG/jchuff.cpp:329:		put_bits -= 8;
.//SVD/JPEG/jchuff.cpp:332:	state->cur.put_buffer = put_buffer; /* update state variables */
.//SVD/JPEG/jchuff.cpp:333:	state->cur.put_bits = put_bits;
.//SVD/JPEG/jchuff.cpp:344:	state->cur.put_buffer = 0;	/* and reset bit-buffer to empty */
.//SVD/JPEG/jchuff.cpp:345:	state->cur.put_bits = 0;
.//SVD/JPEG/jchuff.cpp:362:	temp = temp2 = block[0] - last_dc_val;
.//SVD/JPEG/jchuff.cpp:365:		temp = -temp;		/* temp is abs value of input */
.//SVD/JPEG/jchuff.cpp:368:		temp2--;
.//SVD/JPEG/jchuff.cpp:377:	/* Check for out-of-range coefficient values.
.//SVD/JPEG/jchuff.cpp:381:		ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
.//SVD/JPEG/jchuff.cpp:383:	/* Emit the Huffman-coded symbol for the number of bits */
.//SVD/JPEG/jchuff.cpp:384:	if (! emit_bits(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))
.//SVD/JPEG/jchuff.cpp:401:				/* if run length > 15, must emit special run-length-16 codes (0xF0) */
.//SVD/JPEG/jchuff.cpp:403:					if (! emit_bits(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))
.//SVD/JPEG/jchuff.cpp:405:					r -= 16;
.//SVD/JPEG/jchuff.cpp:410:					temp = -temp;		/* temp is abs value of input */
.//SVD/JPEG/jchuff.cpp:412:					temp2--;
.//SVD/JPEG/jchuff.cpp:419:				/* Check for out-of-range coefficient values */
.//SVD/JPEG/jchuff.cpp:421:					ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
.//SVD/JPEG/jchuff.cpp:425:				if (! emit_bits(state, actbl->ehufco[i], actbl->ehufsi[i]))
.//SVD/JPEG/jchuff.cpp:437:		/* If the last coef(s) were zero, emit an end-of-block code */
.//SVD/JPEG/jchuff.cpp:439:			if (! emit_bits(state, actbl->ehufco[0], actbl->ehufsi[0]))
.//SVD/JPEG/jchuff.cpp:461:	/* Re-initialize DC predictions to 0 */
.//SVD/JPEG/jchuff.cpp:462:	for (ci = 0; ci < state->cinfo->comps_in_scan; ci++)
.//SVD/JPEG/jchuff.cpp:463:		state->cur.last_dc_val[ci] = 0;
.//SVD/JPEG/jchuff.cpp:472:* Encode and output one MCU's worth of Huffman-compressed coefficients.
.//SVD/JPEG/jchuff.cpp:478:	huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jchuff.cpp:484:	state.next_output_byte = cinfo->dest->next_output_byte;
.//SVD/JPEG/jchuff.cpp:485:	state.free_in_buffer = cinfo->dest->free_in_buffer;
.//SVD/JPEG/jchuff.cpp:486:	ASSIGN_STATE(state.cur, entropy->saved);
.//SVD/JPEG/jchuff.cpp:490:	if (cinfo->restart_interval) {
.//SVD/JPEG/jchuff.cpp:491:		if (entropy->restarts_to_go == 0)
.//SVD/JPEG/jchuff.cpp:492:			if (! emit_restart(&state, entropy->next_restart_num))
.//SVD/JPEG/jchuff.cpp:497:	for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//SVD/JPEG/jchuff.cpp:498:		ci = cinfo->MCU_membership[blkn];
.//SVD/JPEG/jchuff.cpp:499:		compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jchuff.cpp:502:			entropy->dc_derived_tbls[compptr->dc_tbl_no],
.//SVD/JPEG/jchuff.cpp:503:			entropy->ac_derived_tbls[compptr->ac_tbl_no]))
.//SVD/JPEG/jchuff.cpp:510:	cinfo->dest->next_output_byte = state.next_output_byte;
.//SVD/JPEG/jchuff.cpp:511:	cinfo->dest->free_in_buffer = state.free_in_buffer;
.//SVD/JPEG/jchuff.cpp:512:	ASSIGN_STATE(entropy->saved, state.cur);
.//SVD/JPEG/jchuff.cpp:514:	/* Update restart-interval state too */
.//SVD/JPEG/jchuff.cpp:515:	if (cinfo->restart_interval) {
.//SVD/JPEG/jchuff.cpp:516:		if (entropy->restarts_to_go == 0) {
.//SVD/JPEG/jchuff.cpp:517:			entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jchuff.cpp:518:			entropy->next_restart_num++;
.//SVD/JPEG/jchuff.cpp:519:			entropy->next_restart_num &= 7;
.//SVD/JPEG/jchuff.cpp:521:		entropy->restarts_to_go--;
.//SVD/JPEG/jchuff.cpp:529:* Finish up at the end of a Huffman-compressed scan.
.//SVD/JPEG/jchuff.cpp:535:	huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jchuff.cpp:539:	state.next_output_byte = cinfo->dest->next_output_byte;
.//SVD/JPEG/jchuff.cpp:540:	state.free_in_buffer = cinfo->dest->free_in_buffer;
.//SVD/JPEG/jchuff.cpp:541:	ASSIGN_STATE(state.cur, entropy->saved);
.//SVD/JPEG/jchuff.cpp:549:	cinfo->dest->next_output_byte = state.next_output_byte;
.//SVD/JPEG/jchuff.cpp:550:	cinfo->dest->free_in_buffer = state.free_in_buffer;
.//SVD/JPEG/jchuff.cpp:551:	ASSIGN_STATE(entropy->saved, state.cur);
.//SVD/JPEG/jchuff.cpp:559:* that is to be Huffman-coded. (This process MUST agree with the code above.)
.//SVD/JPEG/jchuff.cpp:581:	temp = block[0] - last_dc_val;
.//SVD/JPEG/jchuff.cpp:583:		temp = -temp;
.//SVD/JPEG/jchuff.cpp:591:	/* Check for out-of-range coefficient values.
.//SVD/JPEG/jchuff.cpp:608:			/* if run length > 15, must emit special run-length-16 codes (0xF0) */
.//SVD/JPEG/jchuff.cpp:611:				r -= 16;
.//SVD/JPEG/jchuff.cpp:616:				temp = -temp;
.//SVD/JPEG/jchuff.cpp:622:			/* Check for out-of-range coefficient values */
.//SVD/JPEG/jchuff.cpp:633:	/* If the last coef(s) were zero, emit an end-of-block code */
.//SVD/JPEG/jchuff.cpp:640:* Trial-encode one MCU's worth of Huffman-compressed coefficients.
.//SVD/JPEG/jchuff.cpp:647:	huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jchuff.cpp:652:	if (cinfo->restart_interval) {
.//SVD/JPEG/jchuff.cpp:653:		if (entropy->restarts_to_go == 0) {
.//SVD/JPEG/jchuff.cpp:654:			/* Re-initialize DC predictions to 0 */
.//SVD/JPEG/jchuff.cpp:655:			for (ci = 0; ci < cinfo->comps_in_scan; ci++)
.//SVD/JPEG/jchuff.cpp:656:				entropy->saved.last_dc_val[ci] = 0;
.//SVD/JPEG/jchuff.cpp:658:			entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jchuff.cpp:660:		entropy->restarts_to_go--;
.//SVD/JPEG/jchuff.cpp:663:	for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//SVD/JPEG/jchuff.cpp:664:		ci = cinfo->MCU_membership[blkn];
.//SVD/JPEG/jchuff.cpp:665:		compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jchuff.cpp:666:		htest_one_block(cinfo, MCU_data[blkn][0], entropy->saved.last_dc_val[ci],
.//SVD/JPEG/jchuff.cpp:667:			entropy->dc_count_ptrs[compptr->dc_tbl_no],
.//SVD/JPEG/jchuff.cpp:668:			entropy->ac_count_ptrs[compptr->ac_tbl_no]);
.//SVD/JPEG/jchuff.cpp:669:		entropy->saved.last_dc_val[ci] = MCU_data[blkn][0][0];
.//SVD/JPEG/jchuff.cpp:689:* practice, because it produces more all-ones bytes (which incur stuffed
.//SVD/JPEG/jchuff.cpp:696:* optimal; it may not choose the best possible limited-length code.  But
.//SVD/JPEG/jchuff.cpp:697:* typically only very-low-frequency symbols will be given less-than-optimal
.//SVD/JPEG/jchuff.cpp:699:* an optimal limited-length-code algorithm indicate that the difference is
.//SVD/JPEG/jchuff.cpp:700:* microscopic --- usually less than a hundredth of a percent of total size.
.//SVD/JPEG/jchuff.cpp:720:		others[i] = -1;		/* init links to empty */
.//SVD/JPEG/jchuff.cpp:723:						/* Including the pseudo-symbol 256 in the Huffman procedure guarantees
.//SVD/JPEG/jchuff.cpp:724:						* that no real symbol is given code-value of all ones, because 256
.//SVD/JPEG/jchuff.cpp:733:		c1 = -1;
.//SVD/JPEG/jchuff.cpp:744:		c2 = -1;
.//SVD/JPEG/jchuff.cpp:801:	for (i = MAX_CLEN; i > 16; i--) {
.//SVD/JPEG/jchuff.cpp:803:			j = i - 2;		/* find length of new prefix to be used */
.//SVD/JPEG/jchuff.cpp:805:				j--;
.//SVD/JPEG/jchuff.cpp:807:			bits[i] -= 2;		/* remove two symbols */
.//SVD/JPEG/jchuff.cpp:808:			bits[i-1]++;		/* one goes in this length */
.//SVD/JPEG/jchuff.cpp:810:			bits[j]--;		/* symbol of this length is now a prefix */
.//SVD/JPEG/jchuff.cpp:814:	/* Remove the count for the pseudo-symbol 256 from the largest codelength */
.//SVD/JPEG/jchuff.cpp:816:		i--;
.//SVD/JPEG/jchuff.cpp:817:	bits[i]--;
.//SVD/JPEG/jchuff.cpp:820:	MEMCOPY(htbl->bits, bits, SIZEOF(htbl->bits));
.//SVD/JPEG/jchuff.cpp:830:				htbl->huffval[p] = (UINT8) j;
.//SVD/JPEG/jchuff.cpp:837:	htbl->sent_table = FALSE;
.//SVD/JPEG/jchuff.cpp:842:* Finish up a statistics-gathering pass and create the new Huffman tables.
.//SVD/JPEG/jchuff.cpp:848:	huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jchuff.cpp:861:	for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jchuff.cpp:862:		compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jchuff.cpp:863:		dctbl = compptr->dc_tbl_no;
.//SVD/JPEG/jchuff.cpp:864:		actbl = compptr->ac_tbl_no;
.//SVD/JPEG/jchuff.cpp:866:			htblptr = & cinfo->dc_huff_tbl_ptrs[dctbl];
.//SVD/JPEG/jchuff.cpp:869:			jpeg_gen_optimal_table(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);
.//SVD/JPEG/jchuff.cpp:873:			htblptr = & cinfo->ac_huff_tbl_ptrs[actbl];
.//SVD/JPEG/jchuff.cpp:876:			jpeg_gen_optimal_table(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);
.//SVD/JPEG/jchuff.cpp:897:		(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jchuff.cpp:899:	cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
.//SVD/JPEG/jchuff.cpp:900:	entropy->pub.start_pass = start_pass_huff;
.//SVD/JPEG/jchuff.cpp:904:		entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
.//SVD/JPEG/jchuff.cpp:906:		entropy->dc_count_ptrs[i] = entropy->ac_count_ptrs[i] = NULL;
.//SVD/JPEG/jchuff.h:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jchuff.h:14: *  -1024 .. +1023  for 8-bit data;
.//SVD/JPEG/jchuff.h:15: * -16384 .. +16383 for 12-bit data.
.//SVD/JPEG/jchuff.h:33:/* Short forms of external names for systems with brain-damaged linkers. */
.//SVD/JPEG/jcinit.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jcinit.cpp:14: * For a transcoding-only application, we want to be able to use jcmaster.c
.//SVD/JPEG/jcinit.cpp:36:  if (! cinfo->raw_data_in) {
.//SVD/JPEG/jcinit.cpp:44:  if (cinfo->arith_code) {
.//SVD/JPEG/jcinit.cpp:47:    if (cinfo->progressive_mode) {
.//SVD/JPEG/jcinit.cpp:57:  /* Need a full-image coefficient buffer in any multi-pass mode. */
.//SVD/JPEG/jcinit.cpp:59:		(boolean) (cinfo->num_scans > 1 || cinfo->optimize_coding));
.//SVD/JPEG/jcinit.cpp:65:  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
.//SVD/JPEG/jcinit.cpp:71:  (*cinfo->marker->write_file_header) (cinfo);
.//SVD/JPEG/jcmainct.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jcmainct.cpp:9: * The main buffer lies between the pre-processor and the JPEG
.//SVD/JPEG/jcmainct.cpp:18:/* Note: currently, there is no operating mode in which a full-image buffer
.//SVD/JPEG/jcmainct.cpp:37:   * (we allocate one for each component).  In the full-image case, this
.//SVD/JPEG/jcmainct.cpp:43:  /* If using full-image storage, this array holds pointers to virtual-array
.//SVD/JPEG/jcmainct.cpp:44:   * control blocks for each component.  Unused if not full-image storage.
.//SVD/JPEG/jcmainct.cpp:71:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//SVD/JPEG/jcmainct.cpp:73:  /* Do nothing in raw-data mode. */
.//SVD/JPEG/jcmainct.cpp:74:  if (cinfo->raw_data_in)
.//SVD/JPEG/jcmainct.cpp:77:  main->cur_iMCU_row = 0;	/* initialize counters */
.//SVD/JPEG/jcmainct.cpp:78:  main->rowgroup_ctr = 0;
.//SVD/JPEG/jcmainct.cpp:79:  main->suspended = FALSE;
.//SVD/JPEG/jcmainct.cpp:80:  main->pass_mode = pass_mode;	/* save mode for use by process_data */
.//SVD/JPEG/jcmainct.cpp:85:    if (main->whole_image[0] != NULL)
.//SVD/JPEG/jcmainct.cpp:88:    main->pub.process_data = process_data_simple_main;
.//SVD/JPEG/jcmainct.cpp:94:    if (main->whole_image[0] == NULL)
.//SVD/JPEG/jcmainct.cpp:96:    main->pub.process_data = process_data_buffer_main;
.//SVD/JPEG/jcmainct.cpp:108: * This routine handles the simple pass-through mode,
.//SVD/JPEG/jcmainct.cpp:117:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//SVD/JPEG/jcmainct.cpp:119:  while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
.//SVD/JPEG/jcmainct.cpp:121:    if (main->rowgroup_ctr < DCTSIZE)
.//SVD/JPEG/jcmainct.cpp:122:      (*cinfo->prep->pre_process_data) (cinfo,
.//SVD/JPEG/jcmainct.cpp:124:					main->buffer, &main->rowgroup_ctr,
.//SVD/JPEG/jcmainct.cpp:131:    if (main->rowgroup_ctr != DCTSIZE)
.//SVD/JPEG/jcmainct.cpp:135:    if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
.//SVD/JPEG/jcmainct.cpp:142:      if (! main->suspended) {
.//SVD/JPEG/jcmainct.cpp:143:	(*in_row_ctr)--;
.//SVD/JPEG/jcmainct.cpp:144:	main->suspended = TRUE;
.//SVD/JPEG/jcmainct.cpp:151:    if (main->suspended) {
.//SVD/JPEG/jcmainct.cpp:153:      main->suspended = FALSE;
.//SVD/JPEG/jcmainct.cpp:155:    main->rowgroup_ctr = 0;
.//SVD/JPEG/jcmainct.cpp:156:    main->cur_iMCU_row++;
.//SVD/JPEG/jcmainct.cpp:165: * This routine handles all of the modes that use a full-size buffer.
.//SVD/JPEG/jcmainct.cpp:173:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//SVD/JPEG/jcmainct.cpp:176:  boolean writing = (main->pass_mode != JBUF_CRANK_DEST);
.//SVD/JPEG/jcmainct.cpp:178:  while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
.//SVD/JPEG/jcmainct.cpp:180:    if (main->rowgroup_ctr == 0) {
.//SVD/JPEG/jcmainct.cpp:181:      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcmainct.cpp:183:	main->buffer[ci] = (*cinfo->mem->access_virt_sarray)
.//SVD/JPEG/jcmainct.cpp:184:	  ((j_common_ptr) cinfo, main->whole_image[ci],
.//SVD/JPEG/jcmainct.cpp:185:	   main->cur_iMCU_row * (compptr->v_samp_factor * DCTSIZE),
.//SVD/JPEG/jcmainct.cpp:186:	   (JDIMENSION) (compptr->v_samp_factor * DCTSIZE), writing);
.//SVD/JPEG/jcmainct.cpp:190:	*in_row_ctr += cinfo->max_v_samp_factor * DCTSIZE;
.//SVD/JPEG/jcmainct.cpp:191:	main->rowgroup_ctr = DCTSIZE;
.//SVD/JPEG/jcmainct.cpp:198:      (*cinfo->prep->pre_process_data) (cinfo,
.//SVD/JPEG/jcmainct.cpp:200:					main->buffer, &main->rowgroup_ctr,
.//SVD/JPEG/jcmainct.cpp:203:      if (main->rowgroup_ctr < DCTSIZE)
.//SVD/JPEG/jcmainct.cpp:207:    /* Emit data, unless this is a sink-only pass. */
.//SVD/JPEG/jcmainct.cpp:208:    if (main->pass_mode != JBUF_SAVE_SOURCE) {
.//SVD/JPEG/jcmainct.cpp:209:      if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
.//SVD/JPEG/jcmainct.cpp:216:	if (! main->suspended) {
.//SVD/JPEG/jcmainct.cpp:217:	  (*in_row_ctr)--;
.//SVD/JPEG/jcmainct.cpp:218:	  main->suspended = TRUE;
.//SVD/JPEG/jcmainct.cpp:225:      if (main->suspended) {
.//SVD/JPEG/jcmainct.cpp:227:	main->suspended = FALSE;
.//SVD/JPEG/jcmainct.cpp:232:    main->rowgroup_ctr = 0;
.//SVD/JPEG/jcmainct.cpp:233:    main->cur_iMCU_row++;
.//SVD/JPEG/jcmainct.cpp:252:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcmainct.cpp:254:  cinfo->main = (struct jpeg_c_main_controller *) main;
.//SVD/JPEG/jcmainct.cpp:255:  main->pub.start_pass = start_pass_main;
.//SVD/JPEG/jcmainct.cpp:257:  /* We don't need to create a buffer in raw-data mode. */
.//SVD/JPEG/jcmainct.cpp:258:  if (cinfo->raw_data_in)
.//SVD/JPEG/jcmainct.cpp:266:    /* Allocate a full-image virtual array for each component */
.//SVD/JPEG/jcmainct.cpp:268:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcmainct.cpp:270:      main->whole_image[ci] = (*cinfo->mem->request_virt_sarray)
.//SVD/JPEG/jcmainct.cpp:272:	 compptr->width_in_blocks * DCTSIZE,
.//SVD/JPEG/jcmainct.cpp:273:	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
.//SVD/JPEG/jcmainct.cpp:274:				(long) compptr->v_samp_factor) * DCTSIZE,
.//SVD/JPEG/jcmainct.cpp:275:	 (JDIMENSION) (compptr->v_samp_factor * DCTSIZE));
.//SVD/JPEG/jcmainct.cpp:282:    main->whole_image[0] = NULL; /* flag for no virtual arrays */
.//SVD/JPEG/jcmainct.cpp:285:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcmainct.cpp:287:      main->buffer[ci] = (*cinfo->mem->alloc_sarray)
.//SVD/JPEG/jcmainct.cpp:289:	 compptr->width_in_blocks * DCTSIZE,
.//SVD/JPEG/jcmainct.cpp:290:	 (JDIMENSION) (compptr->v_samp_factor * DCTSIZE));
.//SVD/JPEG/jcmarker.cpp:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//SVD/JPEG/jcmarker.cpp:100: * enough buffer space for the initial markers (typ. 600-700 bytes) before
.//SVD/JPEG/jcmarker.cpp:111:  struct jpeg_destination_mgr * dest = cinfo->dest;
.//SVD/JPEG/jcmarker.cpp:113:  *(dest->next_output_byte)++ = (JOCTET) val;
.//SVD/JPEG/jcmarker.cpp:114:  if (--dest->free_in_buffer == 0) {
.//SVD/JPEG/jcmarker.cpp:115:    if (! (*dest->empty_output_buffer) (cinfo))
.//SVD/JPEG/jcmarker.cpp:132:/* Emit a 2-byte integer; these are always MSB first in JPEG files */
.//SVD/JPEG/jcmarker.cpp:148:  JQUANT_TBL * qtbl = cinfo->quant_tbl_ptrs[index];
.//SVD/JPEG/jcmarker.cpp:157:    if (qtbl->quantval[i] > 255)
.//SVD/JPEG/jcmarker.cpp:161:  if (! qtbl->sent_table) {
.//SVD/JPEG/jcmarker.cpp:170:      unsigned int qval = qtbl->quantval[jpeg_natural_order[i]];
.//SVD/JPEG/jcmarker.cpp:176:    qtbl->sent_table = TRUE;
.//SVD/JPEG/jcmarker.cpp:191:    htbl = cinfo->ac_huff_tbl_ptrs[index];
.//SVD/JPEG/jcmarker.cpp:194:    htbl = cinfo->dc_huff_tbl_ptrs[index];
.//SVD/JPEG/jcmarker.cpp:200:  if (! htbl->sent_table) {
.//SVD/JPEG/jcmarker.cpp:205:      length += htbl->bits[i];
.//SVD/JPEG/jcmarker.cpp:211:      emit_byte(cinfo, htbl->bits[i]);
.//SVD/JPEG/jcmarker.cpp:214:      emit_byte(cinfo, htbl->huffval[i]);
.//SVD/JPEG/jcmarker.cpp:216:    htbl->sent_table = TRUE;
.//SVD/JPEG/jcmarker.cpp:236:  for (i = 0; i < cinfo->comps_in_scan; i++) {
.//SVD/JPEG/jcmarker.cpp:237:    compptr = cinfo->cur_comp_info[i];
.//SVD/JPEG/jcmarker.cpp:238:    dc_in_use[compptr->dc_tbl_no] = 1;
.//SVD/JPEG/jcmarker.cpp:239:    ac_in_use[compptr->ac_tbl_no] = 1;
.//SVD/JPEG/jcmarker.cpp:253:      emit_byte(cinfo, cinfo->arith_dc_L[i] + (cinfo->arith_dc_U[i]<<4));
.//SVD/JPEG/jcmarker.cpp:257:      emit_byte(cinfo, cinfo->arith_ac_K[i]);
.//SVD/JPEG/jcmarker.cpp:272:  emit_2bytes(cinfo, (int) cinfo->restart_interval);
.//SVD/JPEG/jcmarker.cpp:285:  emit_2bytes(cinfo, 3 * cinfo->num_components + 2 + 5 + 1); /* length */
.//SVD/JPEG/jcmarker.cpp:288:  if ((long) cinfo->image_height > 65535L ||
.//SVD/JPEG/jcmarker.cpp:289:      (long) cinfo->image_width > 65535L)
.//SVD/JPEG/jcmarker.cpp:292:  emit_byte(cinfo, cinfo->data_precision);
.//SVD/JPEG/jcmarker.cpp:293:  emit_2bytes(cinfo, (int) cinfo->image_height);
.//SVD/JPEG/jcmarker.cpp:294:  emit_2bytes(cinfo, (int) cinfo->image_width);
.//SVD/JPEG/jcmarker.cpp:296:  emit_byte(cinfo, cinfo->num_components);
.//SVD/JPEG/jcmarker.cpp:298:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcmarker.cpp:300:    emit_byte(cinfo, compptr->component_id);
.//SVD/JPEG/jcmarker.cpp:301:    emit_byte(cinfo, (compptr->h_samp_factor << 4) + compptr->v_samp_factor);
.//SVD/JPEG/jcmarker.cpp:302:    emit_byte(cinfo, compptr->quant_tbl_no);
.//SVD/JPEG/jcmarker.cpp:316:  emit_2bytes(cinfo, 2 * cinfo->comps_in_scan + 2 + 1 + 3); /* length */
.//SVD/JPEG/jcmarker.cpp:318:  emit_byte(cinfo, cinfo->comps_in_scan);
.//SVD/JPEG/jcmarker.cpp:320:  for (i = 0; i < cinfo->comps_in_scan; i++) {
.//SVD/JPEG/jcmarker.cpp:321:    compptr = cinfo->cur_comp_info[i];
.//SVD/JPEG/jcmarker.cpp:322:    emit_byte(cinfo, compptr->component_id);
.//SVD/JPEG/jcmarker.cpp:323:    td = compptr->dc_tbl_no;
.//SVD/JPEG/jcmarker.cpp:324:    ta = compptr->ac_tbl_no;
.//SVD/JPEG/jcmarker.cpp:325:    if (cinfo->progressive_mode) {
.//SVD/JPEG/jcmarker.cpp:331:      if (cinfo->Ss == 0) {
.//SVD/JPEG/jcmarker.cpp:333:	if (cinfo->Ah != 0 && !cinfo->arith_code)
.//SVD/JPEG/jcmarker.cpp:342:  emit_byte(cinfo, cinfo->Ss);
.//SVD/JPEG/jcmarker.cpp:343:  emit_byte(cinfo, cinfo->Se);
.//SVD/JPEG/jcmarker.cpp:344:  emit_byte(cinfo, (cinfo->Ah << 4) + cinfo->Al);
.//SVD/JPEG/jcmarker.cpp:350:/* Emit a JFIF-compliant APP0 marker */
.//SVD/JPEG/jcmarker.cpp:354:   * Block ID			(4 bytes - ASCII "JFIF")
.//SVD/JPEG/jcmarker.cpp:356:   * Version Major, Minor	(2 bytes - major first)
.//SVD/JPEG/jcmarker.cpp:357:   * Units			(1 byte - 0x00 = none, 0x01 = inch, 0x02 = cm)
.//SVD/JPEG/jcmarker.cpp:358:   * Xdpu			(2 bytes - dots per unit horizontal)
.//SVD/JPEG/jcmarker.cpp:359:   * Ydpu			(2 bytes - dots per unit vertical)
.//SVD/JPEG/jcmarker.cpp:373:  emit_byte(cinfo, cinfo->JFIF_major_version); /* Version fields */
.//SVD/JPEG/jcmarker.cpp:374:  emit_byte(cinfo, cinfo->JFIF_minor_version);
.//SVD/JPEG/jcmarker.cpp:375:  emit_byte(cinfo, cinfo->density_unit); /* Pixel size information */
.//SVD/JPEG/jcmarker.cpp:376:  emit_2bytes(cinfo, (int) cinfo->X_density);
.//SVD/JPEG/jcmarker.cpp:377:  emit_2bytes(cinfo, (int) cinfo->Y_density);
.//SVD/JPEG/jcmarker.cpp:389:   * Block ID			(5 bytes - ASCII "Adobe")
.//SVD/JPEG/jcmarker.cpp:390:   * Version Number		(2 bytes - currently 100)
.//SVD/JPEG/jcmarker.cpp:391:   * Flags0			(2 bytes - currently 0)
.//SVD/JPEG/jcmarker.cpp:392:   * Flags1			(2 bytes - currently 0)
.//SVD/JPEG/jcmarker.cpp:415:  switch (cinfo->jpeg_color_space) {
.//SVD/JPEG/jcmarker.cpp:471:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//SVD/JPEG/jcmarker.cpp:476:  marker->last_restart_interval = 0;
.//SVD/JPEG/jcmarker.cpp:478:  if (cinfo->write_JFIF_header)	/* next an optional JFIF APP0 */
.//SVD/JPEG/jcmarker.cpp:480:  if (cinfo->write_Adobe_marker) /* next an optional Adobe APP14 */
.//SVD/JPEG/jcmarker.cpp:490: * try to error-check the quant table numbers as soon as they see the SOF.
.//SVD/JPEG/jcmarker.cpp:504:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcmarker.cpp:506:    prec += emit_dqt(cinfo, compptr->quant_tbl_no);
.//SVD/JPEG/jcmarker.cpp:508:  /* now prec is nonzero iff there are any 16-bit quant tables. */
.//SVD/JPEG/jcmarker.cpp:510:  /* Check for a non-baseline specification.
.//SVD/JPEG/jcmarker.cpp:513:  if (cinfo->arith_code || cinfo->progressive_mode ||
.//SVD/JPEG/jcmarker.cpp:514:      cinfo->data_precision != 8) {
.//SVD/JPEG/jcmarker.cpp:518:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcmarker.cpp:520:      if (compptr->dc_tbl_no > 1 || compptr->ac_tbl_no > 1)
.//SVD/JPEG/jcmarker.cpp:531:  if (cinfo->arith_code) {
.//SVD/JPEG/jcmarker.cpp:534:    if (cinfo->progressive_mode)
.//SVD/JPEG/jcmarker.cpp:539:      emit_sof(cinfo, M_SOF1);	/* SOF code for non-baseline Huffman file */
.//SVD/JPEG/jcmarker.cpp:553:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//SVD/JPEG/jcmarker.cpp:557:  if (cinfo->arith_code) {
.//SVD/JPEG/jcmarker.cpp:567:    for (i = 0; i < cinfo->comps_in_scan; i++) {
.//SVD/JPEG/jcmarker.cpp:568:      compptr = cinfo->cur_comp_info[i];
.//SVD/JPEG/jcmarker.cpp:569:      if (cinfo->progressive_mode) {
.//SVD/JPEG/jcmarker.cpp:571:	if (cinfo->Ss == 0) {
.//SVD/JPEG/jcmarker.cpp:572:	  if (cinfo->Ah == 0)	/* DC needs no table for refinement scan */
.//SVD/JPEG/jcmarker.cpp:573:	    emit_dht(cinfo, compptr->dc_tbl_no, FALSE);
.//SVD/JPEG/jcmarker.cpp:575:	  emit_dht(cinfo, compptr->ac_tbl_no, TRUE);
.//SVD/JPEG/jcmarker.cpp:579:	emit_dht(cinfo, compptr->dc_tbl_no, FALSE);
.//SVD/JPEG/jcmarker.cpp:580:	emit_dht(cinfo, compptr->ac_tbl_no, TRUE);
.//SVD/JPEG/jcmarker.cpp:585:  /* Emit DRI if required --- note that DRI value could change for each scan.
.//SVD/JPEG/jcmarker.cpp:588:  if (cinfo->restart_interval != marker->last_restart_interval) {
.//SVD/JPEG/jcmarker.cpp:590:    marker->last_restart_interval = cinfo->restart_interval;
.//SVD/JPEG/jcmarker.cpp:609: * Write an abbreviated table-specification datastream.
.//SVD/JPEG/jcmarker.cpp:623:    if (cinfo->quant_tbl_ptrs[i] != NULL)
.//SVD/JPEG/jcmarker.cpp:627:  if (! cinfo->arith_code) {
.//SVD/JPEG/jcmarker.cpp:629:      if (cinfo->dc_huff_tbl_ptrs[i] != NULL)
.//SVD/JPEG/jcmarker.cpp:631:      if (cinfo->ac_huff_tbl_ptrs[i] != NULL)
.//SVD/JPEG/jcmarker.cpp:651:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcmarker.cpp:653:  cinfo->marker = (struct jpeg_marker_writer *) marker;
.//SVD/JPEG/jcmarker.cpp:655:  marker->pub.write_file_header = write_file_header;
.//SVD/JPEG/jcmarker.cpp:656:  marker->pub.write_frame_header = write_frame_header;
.//SVD/JPEG/jcmarker.cpp:657:  marker->pub.write_scan_header = write_scan_header;
.//SVD/JPEG/jcmarker.cpp:658:  marker->pub.write_file_trailer = write_file_trailer;
.//SVD/JPEG/jcmarker.cpp:659:  marker->pub.write_tables_only = write_tables_only;
.//SVD/JPEG/jcmarker.cpp:660:  marker->pub.write_marker_header = write_marker_header;
.//SVD/JPEG/jcmarker.cpp:661:  marker->pub.write_marker_byte = write_marker_byte;
.//SVD/JPEG/jcmarker.cpp:663:  marker->last_restart_interval = 0;
.//SVD/JPEG/jcmaster.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jcmaster.cpp:10: * and inter-pass control (determining the number of passes and the work 
.//SVD/JPEG/jcmaster.cpp:55:  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
.//SVD/JPEG/jcmaster.cpp:56:      || cinfo->num_components <= 0 || cinfo->input_components <= 0)
.//SVD/JPEG/jcmaster.cpp:60:  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
.//SVD/JPEG/jcmaster.cpp:61:      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
.//SVD/JPEG/jcmaster.cpp:65:  samplesperrow = (long) cinfo->image_width * (long) cinfo->input_components;
.//SVD/JPEG/jcmaster.cpp:70:  /* For now, precision must match compiled-in value... */
.//SVD/JPEG/jcmaster.cpp:71:  if (cinfo->data_precision != BITS_IN_JSAMPLE)
.//SVD/JPEG/jcmaster.cpp:72:    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
.//SVD/JPEG/jcmaster.cpp:75:  if (cinfo->num_components > MAX_COMPONENTS)
.//SVD/JPEG/jcmaster.cpp:76:    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
.//SVD/JPEG/jcmaster.cpp:80:  cinfo->max_h_samp_factor = 1;
.//SVD/JPEG/jcmaster.cpp:81:  cinfo->max_v_samp_factor = 1;
.//SVD/JPEG/jcmaster.cpp:82:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcmaster.cpp:84:    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
.//SVD/JPEG/jcmaster.cpp:85:	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
.//SVD/JPEG/jcmaster.cpp:87:    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
.//SVD/JPEG/jcmaster.cpp:88:				   compptr->h_samp_factor);
.//SVD/JPEG/jcmaster.cpp:89:    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
.//SVD/JPEG/jcmaster.cpp:90:				   compptr->v_samp_factor);
.//SVD/JPEG/jcmaster.cpp:94:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcmaster.cpp:97:    compptr->component_index = ci;
.//SVD/JPEG/jcmaster.cpp:99:    compptr->DCT_scaled_size = DCTSIZE;
.//SVD/JPEG/jcmaster.cpp:101:    compptr->width_in_blocks = (JDIMENSION)
.//SVD/JPEG/jcmaster.cpp:102:      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
.//SVD/JPEG/jcmaster.cpp:103:		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
.//SVD/JPEG/jcmaster.cpp:104:    compptr->height_in_blocks = (JDIMENSION)
.//SVD/JPEG/jcmaster.cpp:105:      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
.//SVD/JPEG/jcmaster.cpp:106:		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
.//SVD/JPEG/jcmaster.cpp:108:    compptr->downsampled_width = (JDIMENSION)
.//SVD/JPEG/jcmaster.cpp:109:      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
.//SVD/JPEG/jcmaster.cpp:110:		    (long) cinfo->max_h_samp_factor);
.//SVD/JPEG/jcmaster.cpp:111:    compptr->downsampled_height = (JDIMENSION)
.//SVD/JPEG/jcmaster.cpp:112:      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
.//SVD/JPEG/jcmaster.cpp:113:		    (long) cinfo->max_v_samp_factor);
.//SVD/JPEG/jcmaster.cpp:115:    compptr->component_needed = TRUE;
.//SVD/JPEG/jcmaster.cpp:121:  cinfo->total_iMCU_rows = (JDIMENSION)
.//SVD/JPEG/jcmaster.cpp:122:    jdiv_round_up((long) cinfo->image_height,
.//SVD/JPEG/jcmaster.cpp:123:		  (long) (cinfo->max_v_samp_factor*DCTSIZE));
.//SVD/JPEG/jcmaster.cpp:131:/* Verify that the scan script in cinfo->scan_info[] is valid; also
.//SVD/JPEG/jcmaster.cpp:132: * determine whether it uses progressive JPEG, and set cinfo->progressive_mode.
.//SVD/JPEG/jcmaster.cpp:142:  /* -1 until that coefficient has been seen; then last Al for it */
.//SVD/JPEG/jcmaster.cpp:145:  if (cinfo->num_scans <= 0)
.//SVD/JPEG/jcmaster.cpp:148:  /* For sequential JPEG, all scans must have Ss=0, Se=DCTSIZE2-1;
.//SVD/JPEG/jcmaster.cpp:151:  scanptr = cinfo->scan_info;
.//SVD/JPEG/jcmaster.cpp:152:  if (scanptr->Ss != 0 || scanptr->Se != DCTSIZE2-1) {
.//SVD/JPEG/jcmaster.cpp:154:    cinfo->progressive_mode = TRUE;
.//SVD/JPEG/jcmaster.cpp:156:    for (ci = 0; ci < cinfo->num_components; ci++) 
.//SVD/JPEG/jcmaster.cpp:158:	*last_bitpos_ptr++ = -1;
.//SVD/JPEG/jcmaster.cpp:163:    cinfo->progressive_mode = FALSE;
.//SVD/JPEG/jcmaster.cpp:164:    for (ci = 0; ci < cinfo->num_components; ci++) 
.//SVD/JPEG/jcmaster.cpp:168:  for (scanno = 1; scanno <= cinfo->num_scans; scanptr++, scanno++) {
.//SVD/JPEG/jcmaster.cpp:170:    ncomps = scanptr->comps_in_scan;
.//SVD/JPEG/jcmaster.cpp:174:      thisi = scanptr->component_index[ci];
.//SVD/JPEG/jcmaster.cpp:175:      if (thisi < 0 || thisi >= cinfo->num_components)
.//SVD/JPEG/jcmaster.cpp:178:      if (ci > 0 && thisi <= scanptr->component_index[ci-1])
.//SVD/JPEG/jcmaster.cpp:182:    Ss = scanptr->Ss;
.//SVD/JPEG/jcmaster.cpp:183:    Se = scanptr->Se;
.//SVD/JPEG/jcmaster.cpp:184:    Ah = scanptr->Ah;
.//SVD/JPEG/jcmaster.cpp:185:    Al = scanptr->Al;
.//SVD/JPEG/jcmaster.cpp:186:    if (cinfo->progressive_mode) {
.//SVD/JPEG/jcmaster.cpp:190:       * Perhaps they really meant 0..N+1 for N-bit precision.
.//SVD/JPEG/jcmaster.cpp:191:       * Here we allow 0..10 for 8-bit data; Al larger than 10 results in
.//SVD/JPEG/jcmaster.cpp:192:       * out-of-range reconstructed DC values during the first DC scan,
.//SVD/JPEG/jcmaster.cpp:211:	last_bitpos_ptr = & last_bitpos[scanptr->component_index[ci]][0];
.//SVD/JPEG/jcmaster.cpp:221:	    if (Ah != last_bitpos_ptr[coefi] || Al != Ah-1)
.//SVD/JPEG/jcmaster.cpp:230:      if (Ss != 0 || Se != DCTSIZE2-1 || Ah != 0 || Al != 0)
.//SVD/JPEG/jcmaster.cpp:234:	thisi = scanptr->component_index[ci];
.//SVD/JPEG/jcmaster.cpp:243:  if (cinfo->progressive_mode) {
.//SVD/JPEG/jcmaster.cpp:250:    for (ci = 0; ci < cinfo->num_components; ci++) {
.//SVD/JPEG/jcmaster.cpp:256:    for (ci = 0; ci < cinfo->num_components; ci++) {
.//SVD/JPEG/jcmaster.cpp:273:  if (cinfo->scan_info != NULL) {
.//SVD/JPEG/jcmaster.cpp:274:    /* Prepare for current scan --- the script is already validated */
.//SVD/JPEG/jcmaster.cpp:275:    my_master_ptr master = (my_master_ptr) cinfo->master;
.//SVD/JPEG/jcmaster.cpp:276:    const jpeg_scan_info * scanptr = cinfo->scan_info + master->scan_number;
.//SVD/JPEG/jcmaster.cpp:278:    cinfo->comps_in_scan = scanptr->comps_in_scan;
.//SVD/JPEG/jcmaster.cpp:279:    for (ci = 0; ci < scanptr->comps_in_scan; ci++) {
.//SVD/JPEG/jcmaster.cpp:280:      cinfo->cur_comp_info[ci] =
.//SVD/JPEG/jcmaster.cpp:281:	&cinfo->comp_info[scanptr->component_index[ci]];
.//SVD/JPEG/jcmaster.cpp:283:    cinfo->Ss = scanptr->Ss;
.//SVD/JPEG/jcmaster.cpp:284:    cinfo->Se = scanptr->Se;
.//SVD/JPEG/jcmaster.cpp:285:    cinfo->Ah = scanptr->Ah;
.//SVD/JPEG/jcmaster.cpp:286:    cinfo->Al = scanptr->Al;
.//SVD/JPEG/jcmaster.cpp:291:    /* Prepare for single sequential-JPEG scan containing all components */
.//SVD/JPEG/jcmaster.cpp:292:    if (cinfo->num_components > MAX_COMPS_IN_SCAN)
.//SVD/JPEG/jcmaster.cpp:293:      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
.//SVD/JPEG/jcmaster.cpp:295:    cinfo->comps_in_scan = cinfo->num_components;
.//SVD/JPEG/jcmaster.cpp:296:    for (ci = 0; ci < cinfo->num_components; ci++) {
.//SVD/JPEG/jcmaster.cpp:297:      cinfo->cur_comp_info[ci] = &cinfo->comp_info[ci];
.//SVD/JPEG/jcmaster.cpp:299:    cinfo->Ss = 0;
.//SVD/JPEG/jcmaster.cpp:300:    cinfo->Se = DCTSIZE2-1;
.//SVD/JPEG/jcmaster.cpp:301:    cinfo->Ah = 0;
.//SVD/JPEG/jcmaster.cpp:302:    cinfo->Al = 0;
.//SVD/JPEG/jcmaster.cpp:310:/* cinfo->comps_in_scan and cinfo->cur_comp_info[] are already set */
.//SVD/JPEG/jcmaster.cpp:315:  if (cinfo->comps_in_scan == 1) {
.//SVD/JPEG/jcmaster.cpp:317:    /* Noninterleaved (single-component) scan */
.//SVD/JPEG/jcmaster.cpp:318:    compptr = cinfo->cur_comp_info[0];
.//SVD/JPEG/jcmaster.cpp:321:    cinfo->MCUs_per_row = compptr->width_in_blocks;
.//SVD/JPEG/jcmaster.cpp:322:    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
.//SVD/JPEG/jcmaster.cpp:325:    compptr->MCU_width = 1;
.//SVD/JPEG/jcmaster.cpp:326:    compptr->MCU_height = 1;
.//SVD/JPEG/jcmaster.cpp:327:    compptr->MCU_blocks = 1;
.//SVD/JPEG/jcmaster.cpp:328:    compptr->MCU_sample_width = DCTSIZE;
.//SVD/JPEG/jcmaster.cpp:329:    compptr->last_col_width = 1;
.//SVD/JPEG/jcmaster.cpp:333:    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
.//SVD/JPEG/jcmaster.cpp:334:    if (tmp == 0) tmp = compptr->v_samp_factor;
.//SVD/JPEG/jcmaster.cpp:335:    compptr->last_row_height = tmp;
.//SVD/JPEG/jcmaster.cpp:338:    cinfo->blocks_in_MCU = 1;
.//SVD/JPEG/jcmaster.cpp:339:    cinfo->MCU_membership[0] = 0;
.//SVD/JPEG/jcmaster.cpp:343:    /* Interleaved (multi-component) scan */
.//SVD/JPEG/jcmaster.cpp:344:    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
.//SVD/JPEG/jcmaster.cpp:345:      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
.//SVD/JPEG/jcmaster.cpp:349:    cinfo->MCUs_per_row = (JDIMENSION)
.//SVD/JPEG/jcmaster.cpp:350:      jdiv_round_up((long) cinfo->image_width,
.//SVD/JPEG/jcmaster.cpp:351:		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
.//SVD/JPEG/jcmaster.cpp:352:    cinfo->MCU_rows_in_scan = (JDIMENSION)
.//SVD/JPEG/jcmaster.cpp:353:      jdiv_round_up((long) cinfo->image_height,
.//SVD/JPEG/jcmaster.cpp:354:		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
.//SVD/JPEG/jcmaster.cpp:356:    cinfo->blocks_in_MCU = 0;
.//SVD/JPEG/jcmaster.cpp:358:    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jcmaster.cpp:359:      compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jcmaster.cpp:361:      compptr->MCU_width = compptr->h_samp_factor;
.//SVD/JPEG/jcmaster.cpp:362:      compptr->MCU_height = compptr->v_samp_factor;
.//SVD/JPEG/jcmaster.cpp:363:      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
.//SVD/JPEG/jcmaster.cpp:364:      compptr->MCU_sample_width = compptr->MCU_width * DCTSIZE;
.//SVD/JPEG/jcmaster.cpp:365:      /* Figure number of non-dummy blocks in last MCU column & row */
.//SVD/JPEG/jcmaster.cpp:366:      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
.//SVD/JPEG/jcmaster.cpp:367:      if (tmp == 0) tmp = compptr->MCU_width;
.//SVD/JPEG/jcmaster.cpp:368:      compptr->last_col_width = tmp;
.//SVD/JPEG/jcmaster.cpp:369:      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
.//SVD/JPEG/jcmaster.cpp:370:      if (tmp == 0) tmp = compptr->MCU_height;
.//SVD/JPEG/jcmaster.cpp:371:      compptr->last_row_height = tmp;
.//SVD/JPEG/jcmaster.cpp:373:      mcublks = compptr->MCU_blocks;
.//SVD/JPEG/jcmaster.cpp:374:      if (cinfo->blocks_in_MCU + mcublks > C_MAX_BLOCKS_IN_MCU)
.//SVD/JPEG/jcmaster.cpp:376:      while (mcublks-- > 0) {
.//SVD/JPEG/jcmaster.cpp:377:	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
.//SVD/JPEG/jcmaster.cpp:385:  if (cinfo->restart_in_rows > 0) {
.//SVD/JPEG/jcmaster.cpp:386:    long nominal = (long) cinfo->restart_in_rows * (long) cinfo->MCUs_per_row;
.//SVD/JPEG/jcmaster.cpp:387:    cinfo->restart_interval = (unsigned int) MIN(nominal, 65535L);
.//SVD/JPEG/jcmaster.cpp:393: * Per-pass setup.
.//SVD/JPEG/jcmaster.cpp:403:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//SVD/JPEG/jcmaster.cpp:405:  switch (master->pass_type) {
.//SVD/JPEG/jcmaster.cpp:412:    if (! cinfo->raw_data_in) {
.//SVD/JPEG/jcmaster.cpp:413:      (*cinfo->cconvert->start_pass) (cinfo);
.//SVD/JPEG/jcmaster.cpp:414:      (*cinfo->downsample->start_pass) (cinfo);
.//SVD/JPEG/jcmaster.cpp:415:      (*cinfo->prep->start_pass) (cinfo, JBUF_PASS_THRU);
.//SVD/JPEG/jcmaster.cpp:417:    (*cinfo->fdct->start_pass) (cinfo);
.//SVD/JPEG/jcmaster.cpp:418:    (*cinfo->entropy->start_pass) (cinfo, cinfo->optimize_coding);
.//SVD/JPEG/jcmaster.cpp:419:    (*cinfo->coef->start_pass) (cinfo,
.//SVD/JPEG/jcmaster.cpp:420:				(master->total_passes > 1 ?
.//SVD/JPEG/jcmaster.cpp:422:    (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
.//SVD/JPEG/jcmaster.cpp:423:    if (cinfo->optimize_coding) {
.//SVD/JPEG/jcmaster.cpp:425:      master->pub.call_pass_startup = FALSE;
.//SVD/JPEG/jcmaster.cpp:428:      master->pub.call_pass_startup = TRUE;
.//SVD/JPEG/jcmaster.cpp:436:    if (cinfo->Ss != 0 || cinfo->Ah == 0 || cinfo->arith_code) {
.//SVD/JPEG/jcmaster.cpp:437:      (*cinfo->entropy->start_pass) (cinfo, TRUE);
.//SVD/JPEG/jcmaster.cpp:438:      (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);
.//SVD/JPEG/jcmaster.cpp:439:      master->pub.call_pass_startup = FALSE;
.//SVD/JPEG/jcmaster.cpp:445:    master->pass_type = output_pass;
.//SVD/JPEG/jcmaster.cpp:446:    master->pass_number++;
.//SVD/JPEG/jcmaster.cpp:450:    /* Do a data-output pass. */
.//SVD/JPEG/jcmaster.cpp:451:    /* We need not repeat per-scan setup if prior optimization pass did it. */
.//SVD/JPEG/jcmaster.cpp:452:    if (! cinfo->optimize_coding) {
.//SVD/JPEG/jcmaster.cpp:456:    (*cinfo->entropy->start_pass) (cinfo, FALSE);
.//SVD/JPEG/jcmaster.cpp:457:    (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);
.//SVD/JPEG/jcmaster.cpp:459:    if (master->scan_number == 0)
.//SVD/JPEG/jcmaster.cpp:460:      (*cinfo->marker->write_frame_header) (cinfo);
.//SVD/JPEG/jcmaster.cpp:461:    (*cinfo->marker->write_scan_header) (cinfo);
.//SVD/JPEG/jcmaster.cpp:462:    master->pub.call_pass_startup = FALSE;
.//SVD/JPEG/jcmaster.cpp:468:  master->pub.is_last_pass = (master->pass_number == master->total_passes-1);
.//SVD/JPEG/jcmaster.cpp:471:  if (cinfo->progress != NULL) {
.//SVD/JPEG/jcmaster.cpp:472:    cinfo->progress->completed_passes = master->pass_number;
.//SVD/JPEG/jcmaster.cpp:473:    cinfo->progress->total_passes = master->total_passes;
.//SVD/JPEG/jcmaster.cpp:479: * Special start-of-pass hook.
.//SVD/JPEG/jcmaster.cpp:481: * In single-pass processing, we need this hook because we don't want to
.//SVD/JPEG/jcmaster.cpp:485: * In multi-pass processing, this routine is not used.
.//SVD/JPEG/jcmaster.cpp:491:  cinfo->master->call_pass_startup = FALSE; /* reset flag so call only once */
.//SVD/JPEG/jcmaster.cpp:493:  (*cinfo->marker->write_frame_header) (cinfo);
.//SVD/JPEG/jcmaster.cpp:494:  (*cinfo->marker->write_scan_header) (cinfo);
.//SVD/JPEG/jcmaster.cpp:505:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//SVD/JPEG/jcmaster.cpp:507:  /* The entropy coder always needs an end-of-pass call,
.//SVD/JPEG/jcmaster.cpp:510:  (*cinfo->entropy->finish_pass) (cinfo);
.//SVD/JPEG/jcmaster.cpp:513:  switch (master->pass_type) {
.//SVD/JPEG/jcmaster.cpp:518:    master->pass_type = output_pass;
.//SVD/JPEG/jcmaster.cpp:519:    if (! cinfo->optimize_coding)
.//SVD/JPEG/jcmaster.cpp:520:      master->scan_number++;
.//SVD/JPEG/jcmaster.cpp:524:    master->pass_type = output_pass;
.//SVD/JPEG/jcmaster.cpp:528:    if (cinfo->optimize_coding)
.//SVD/JPEG/jcmaster.cpp:529:      master->pass_type = huff_opt_pass;
.//SVD/JPEG/jcmaster.cpp:530:    master->scan_number++;
.//SVD/JPEG/jcmaster.cpp:534:  master->pass_number++;
.//SVD/JPEG/jcmaster.cpp:548:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcmaster.cpp:550:  cinfo->master = (struct jpeg_comp_master *) master;
.//SVD/JPEG/jcmaster.cpp:551:  master->pub.prepare_for_pass = prepare_for_pass;
.//SVD/JPEG/jcmaster.cpp:552:  master->pub.pass_startup = pass_startup;
.//SVD/JPEG/jcmaster.cpp:553:  master->pub.finish_pass = finish_pass_master;
.//SVD/JPEG/jcmaster.cpp:554:  master->pub.is_last_pass = FALSE;
.//SVD/JPEG/jcmaster.cpp:559:  if (cinfo->scan_info != NULL) {
.//SVD/JPEG/jcmaster.cpp:566:    cinfo->progressive_mode = FALSE;
.//SVD/JPEG/jcmaster.cpp:567:    cinfo->num_scans = 1;
.//SVD/JPEG/jcmaster.cpp:570:  if (cinfo->progressive_mode)	/*  TEMPORARY HACK ??? */
.//SVD/JPEG/jcmaster.cpp:571:    cinfo->optimize_coding = TRUE; /* assume default tables no good for progressive mode */
.//SVD/JPEG/jcmaster.cpp:576:    if (cinfo->optimize_coding)
.//SVD/JPEG/jcmaster.cpp:577:      master->pass_type = huff_opt_pass;
.//SVD/JPEG/jcmaster.cpp:579:      master->pass_type = output_pass;
.//SVD/JPEG/jcmaster.cpp:582:    master->pass_type = main_pass;
.//SVD/JPEG/jcmaster.cpp:584:  master->scan_number = 0;
.//SVD/JPEG/jcmaster.cpp:585:  master->pass_number = 0;
.//SVD/JPEG/jcmaster.cpp:586:  if (cinfo->optimize_coding)
.//SVD/JPEG/jcmaster.cpp:587:    master->total_passes = cinfo->num_scans * 2;
.//SVD/JPEG/jcmaster.cpp:589:    master->total_passes = cinfo->num_scans;
.//SVD/JPEG/jcomapi.cpp:4: * Copyright (C) 1994-1997, Thomas G. Lane.
.//SVD/JPEG/jcomapi.cpp:33:  /* Do nothing if called on a not-initialized or destroyed JPEG object. */
.//SVD/JPEG/jcomapi.cpp:34:  if (cinfo->mem == NULL)
.//SVD/JPEG/jcomapi.cpp:38:   * with some (brain-damaged) malloc libraries.
.//SVD/JPEG/jcomapi.cpp:40:  for (pool = JPOOL_NUMPOOLS-1; pool > JPOOL_PERMANENT; pool--) {
.//SVD/JPEG/jcomapi.cpp:41:    (*cinfo->mem->free_pool) (cinfo, pool);
.//SVD/JPEG/jcomapi.cpp:45:  if (cinfo->is_decompressor) {
.//SVD/JPEG/jcomapi.cpp:46:    cinfo->global_state = DSTATE_START;
.//SVD/JPEG/jcomapi.cpp:47:    /* Try to keep application from accessing now-deleted marker list.
.//SVD/JPEG/jcomapi.cpp:50:    ((j_decompress_ptr) cinfo)->marker_list = NULL;
.//SVD/JPEG/jcomapi.cpp:52:    cinfo->global_state = CSTATE_START;
.//SVD/JPEG/jcomapi.cpp:73:  if (cinfo->mem != NULL)
.//SVD/JPEG/jcomapi.cpp:74:    (*cinfo->mem->self_destruct) (cinfo);
.//SVD/JPEG/jcomapi.cpp:75:  cinfo->mem = NULL;		/* be safe if jpeg_destroy is called twice */
.//SVD/JPEG/jcomapi.cpp:76:  cinfo->global_state = 0;	/* mark it destroyed */
.//SVD/JPEG/jcomapi.cpp:91:    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JQUANT_TBL));
.//SVD/JPEG/jcomapi.cpp:92:  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
.//SVD/JPEG/jcomapi.cpp:103:    (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JHUFF_TBL));
.//SVD/JPEG/jcomapi.cpp:104:  tbl->sent_table = FALSE;	/* make sure this is false in any new table */
.//SVD/JPEG/jconfig.h:1:/* jconfig.h --- generated by ckconfig.c */
.//SVD/JPEG/jconfig.h:32:#undef TWO_FILE_COMMANDLINE	/* You may need this on non-Unix systems */
.//SVD/JPEG/jcparam.cpp:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//SVD/JPEG/jcparam.cpp:8: * This file contains optional default-setting code for the JPEG compressor.
.//SVD/JPEG/jcparam.cpp:37:  if (cinfo->global_state != CSTATE_START)
.//SVD/JPEG/jcparam.cpp:38:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jcparam.cpp:43:  qtblptr = & cinfo->quant_tbl_ptrs[which_tbl];
.//SVD/JPEG/jcparam.cpp:55:    (*qtblptr)->quantval[i] = (UINT16) temp;
.//SVD/JPEG/jcparam.cpp:59:  (*qtblptr)->sent_table = FALSE;
.//SVD/JPEG/jcparam.cpp:67: * and a straight percentage-scaling quality scale.  In most cases it's better
.//SVD/JPEG/jcparam.cpp:107:/* Convert a user-specified quality rating to a percentage scaling factor
.//SVD/JPEG/jcparam.cpp:116:  /* The basic table is used as-is (scaling 100) for a quality of 50.
.//SVD/JPEG/jcparam.cpp:117:   * Qualities 50..100 are converted to scaling percentage 200 - 2*Q;
.//SVD/JPEG/jcparam.cpp:125:    quality = 200 - quality*2;
.//SVD/JPEG/jcparam.cpp:134: * This is the standard quality-adjusting entry point for typical user
.//SVD/JPEG/jcparam.cpp:139:  /* Convert user 0-100 rating to percentage scaling */
.//SVD/JPEG/jcparam.cpp:161:  /* Copy the number-of-symbols-of-each-code-length counts */
.//SVD/JPEG/jcparam.cpp:162:  MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
.//SVD/JPEG/jcparam.cpp:174:  MEMCOPY((*htblptr)->huffval, val, nsymbols * SIZEOF(UINT8));
.//SVD/JPEG/jcparam.cpp:177:  (*htblptr)->sent_table = FALSE;
.//SVD/JPEG/jcparam.cpp:184:/* IMPORTANT: these are only valid for 8-bit data precision! */
.//SVD/JPEG/jcparam.cpp:187:    { /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
.//SVD/JPEG/jcparam.cpp:192:    { /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
.//SVD/JPEG/jcparam.cpp:197:    { /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
.//SVD/JPEG/jcparam.cpp:222:    { /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };
.//SVD/JPEG/jcparam.cpp:246:  add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[0],
.//SVD/JPEG/jcparam.cpp:248:  add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[0],
.//SVD/JPEG/jcparam.cpp:250:  add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[1],
.//SVD/JPEG/jcparam.cpp:252:  add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[1],
.//SVD/JPEG/jcparam.cpp:273:  if (cinfo->global_state != CSTATE_START)
.//SVD/JPEG/jcparam.cpp:274:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jcparam.cpp:280:  if (cinfo->comp_info == NULL)
.//SVD/JPEG/jcparam.cpp:281:    cinfo->comp_info = (jpeg_component_info *)
.//SVD/JPEG/jcparam.cpp:282:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//SVD/JPEG/jcparam.cpp:287:  cinfo->data_precision = BITS_IN_JSAMPLE;
.//SVD/JPEG/jcparam.cpp:295:    cinfo->arith_dc_L[i] = 0;
.//SVD/JPEG/jcparam.cpp:296:    cinfo->arith_dc_U[i] = 1;
.//SVD/JPEG/jcparam.cpp:297:    cinfo->arith_ac_K[i] = 5;
.//SVD/JPEG/jcparam.cpp:300:  /* Default is no multiple-scan output */
.//SVD/JPEG/jcparam.cpp:301:  cinfo->scan_info = NULL;
.//SVD/JPEG/jcparam.cpp:302:  cinfo->num_scans = 0;
.//SVD/JPEG/jcparam.cpp:305:  cinfo->raw_data_in = FALSE;
.//SVD/JPEG/jcparam.cpp:308:  cinfo->arith_code = FALSE;
.//SVD/JPEG/jcparam.cpp:311:  cinfo->optimize_coding = FALSE;
.//SVD/JPEG/jcparam.cpp:312:  /* The standard Huffman tables are only valid for 8-bit data precision.
.//SVD/JPEG/jcparam.cpp:317:  if (cinfo->data_precision > 8)
.//SVD/JPEG/jcparam.cpp:318:    cinfo->optimize_coding = TRUE;
.//SVD/JPEG/jcparam.cpp:320:  /* By default, use the simpler non-cosited sampling alignment */
.//SVD/JPEG/jcparam.cpp:321:  cinfo->CCIR601_sampling = FALSE;
.//SVD/JPEG/jcparam.cpp:324:  cinfo->smoothing_factor = 0;
.//SVD/JPEG/jcparam.cpp:327:  cinfo->dct_method = JDCT_DEFAULT;
.//SVD/JPEG/jcparam.cpp:330:  cinfo->restart_interval = 0;
.//SVD/JPEG/jcparam.cpp:331:  cinfo->restart_in_rows = 0;
.//SVD/JPEG/jcparam.cpp:342:  cinfo->JFIF_major_version = 1; /* Default JFIF version = 1.01 */
.//SVD/JPEG/jcparam.cpp:343:  cinfo->JFIF_minor_version = 1;
.//SVD/JPEG/jcparam.cpp:344:  cinfo->density_unit = 0;	/* Pixel size is unknown by default */
.//SVD/JPEG/jcparam.cpp:345:  cinfo->X_density = 1;		/* Pixel aspect ratio is square by default */
.//SVD/JPEG/jcparam.cpp:346:  cinfo->Y_density = 1;
.//SVD/JPEG/jcparam.cpp:361:  switch (cinfo->in_color_space) {
.//SVD/JPEG/jcparam.cpp:387: * Set the JPEG colorspace, and choose colorspace-dependent default values.
.//SVD/JPEG/jcparam.cpp:397:  (compptr = &cinfo->comp_info[index], \
.//SVD/JPEG/jcparam.cpp:398:   compptr->component_id = (id), \
.//SVD/JPEG/jcparam.cpp:399:   compptr->h_samp_factor = (hsamp), \
.//SVD/JPEG/jcparam.cpp:400:   compptr->v_samp_factor = (vsamp), \
.//SVD/JPEG/jcparam.cpp:401:   compptr->quant_tbl_no = (quant), \
.//SVD/JPEG/jcparam.cpp:402:   compptr->dc_tbl_no = (dctbl), \
.//SVD/JPEG/jcparam.cpp:403:   compptr->ac_tbl_no = (actbl) )
.//SVD/JPEG/jcparam.cpp:406:  if (cinfo->global_state != CSTATE_START)
.//SVD/JPEG/jcparam.cpp:407:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jcparam.cpp:413:  cinfo->jpeg_color_space = colorspace;
.//SVD/JPEG/jcparam.cpp:415:  cinfo->write_JFIF_header = FALSE; /* No marker for non-JFIF colorspaces */
.//SVD/JPEG/jcparam.cpp:416:  cinfo->write_Adobe_marker = FALSE; /* write no Adobe marker by default */
.//SVD/JPEG/jcparam.cpp:420:    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
.//SVD/JPEG/jcparam.cpp:421:    cinfo->num_components = 1;
.//SVD/JPEG/jcparam.cpp:426:    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag RGB */
.//SVD/JPEG/jcparam.cpp:427:    cinfo->num_components = 3;
.//SVD/JPEG/jcparam.cpp:433:    cinfo->write_JFIF_header = TRUE; /* Write a JFIF marker */
.//SVD/JPEG/jcparam.cpp:434:    cinfo->num_components = 3;
.//SVD/JPEG/jcparam.cpp:442:    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag CMYK */
.//SVD/JPEG/jcparam.cpp:443:    cinfo->num_components = 4;
.//SVD/JPEG/jcparam.cpp:450:    cinfo->write_Adobe_marker = TRUE; /* write Adobe marker to flag YCCK */
.//SVD/JPEG/jcparam.cpp:451:    cinfo->num_components = 4;
.//SVD/JPEG/jcparam.cpp:458:    cinfo->num_components = cinfo->input_components;
.//SVD/JPEG/jcparam.cpp:459:    if (cinfo->num_components < 1 || cinfo->num_components > MAX_COMPONENTS)
.//SVD/JPEG/jcparam.cpp:460:      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
.//SVD/JPEG/jcparam.cpp:462:    for (ci = 0; ci < cinfo->num_components; ci++) {
.//SVD/JPEG/jcparam.cpp:479:  scanptr->comps_in_scan = 1;
.//SVD/JPEG/jcparam.cpp:480:  scanptr->component_index[0] = ci;
.//SVD/JPEG/jcparam.cpp:481:  scanptr->Ss = Ss;
.//SVD/JPEG/jcparam.cpp:482:  scanptr->Se = Se;
.//SVD/JPEG/jcparam.cpp:483:  scanptr->Ah = Ah;
.//SVD/JPEG/jcparam.cpp:484:  scanptr->Al = Al;
.//SVD/JPEG/jcparam.cpp:497:    scanptr->comps_in_scan = 1;
.//SVD/JPEG/jcparam.cpp:498:    scanptr->component_index[0] = ci;
.//SVD/JPEG/jcparam.cpp:499:    scanptr->Ss = Ss;
.//SVD/JPEG/jcparam.cpp:500:    scanptr->Se = Se;
.//SVD/JPEG/jcparam.cpp:501:    scanptr->Ah = Ah;
.//SVD/JPEG/jcparam.cpp:502:    scanptr->Al = Al;
.//SVD/JPEG/jcparam.cpp:516:    scanptr->comps_in_scan = ncomps;
.//SVD/JPEG/jcparam.cpp:518:      scanptr->component_index[ci] = ci;
.//SVD/JPEG/jcparam.cpp:519:    scanptr->Ss = scanptr->Se = 0;
.//SVD/JPEG/jcparam.cpp:520:    scanptr->Ah = Ah;
.//SVD/JPEG/jcparam.cpp:521:    scanptr->Al = Al;
.//SVD/JPEG/jcparam.cpp:532: * Create a recommended progressive-JPEG script.
.//SVD/JPEG/jcparam.cpp:533: * cinfo->num_components and cinfo->jpeg_color_space must be correct.
.//SVD/JPEG/jcparam.cpp:539:  int ncomps = cinfo->num_components;
.//SVD/JPEG/jcparam.cpp:544:  if (cinfo->global_state != CSTATE_START)
.//SVD/JPEG/jcparam.cpp:545:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jcparam.cpp:548:  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {
.//SVD/JPEG/jcparam.cpp:552:    /* All-purpose script for other color spaces. */
.//SVD/JPEG/jcparam.cpp:563:   * object, we try to re-use previously allocated space, and we allocate
.//SVD/JPEG/jcparam.cpp:566:  if (cinfo->script_space == NULL || cinfo->script_space_size < nscans) {
.//SVD/JPEG/jcparam.cpp:567:    cinfo->script_space_size = MAX(nscans, 10);
.//SVD/JPEG/jcparam.cpp:568:    cinfo->script_space = (jpeg_scan_info *)
.//SVD/JPEG/jcparam.cpp:569:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//SVD/JPEG/jcparam.cpp:570:			cinfo->script_space_size * SIZEOF(jpeg_scan_info));
.//SVD/JPEG/jcparam.cpp:572:  scanptr = cinfo->script_space;
.//SVD/JPEG/jcparam.cpp:573:  cinfo->scan_info = scanptr;
.//SVD/JPEG/jcparam.cpp:574:  cinfo->num_scans = nscans;
.//SVD/JPEG/jcparam.cpp:576:  if (ncomps == 3 && cinfo->jpeg_color_space == JCS_YCbCr) {
.//SVD/JPEG/jcparam.cpp:597:    /* All-purpose script for other color spaces. */
.//SVD/JPEG/jcphuff.cpp:4: * Copyright (C) 1995-1997, Thomas G. Lane.
.//SVD/JPEG/jcphuff.cpp:11: * currently does not allow multiple-scan files to be written with output
.//SVD/JPEG/jcphuff.cpp:30:  /* Bit-level coding status.
.//SVD/JPEG/jcphuff.cpp:31:   * next_output_byte/free_in_buffer are local copies of cinfo->dest fields.
.//SVD/JPEG/jcphuff.cpp:35:  INT32 put_buffer;		/* current bit-accumulation buffer */
.//SVD/JPEG/jcphuff.cpp:50:  int next_restart_num;		/* next restart number to write (0-7) */
.//SVD/JPEG/jcphuff.cpp:64:/* MAX_CORR_BITS is the number of bits the AC refinement correction-bit
.//SVD/JPEG/jcphuff.cpp:81:	 (ishift_temp >> (shft)) | ((~0) << (16-(shft))) : \
.//SVD/JPEG/jcphuff.cpp:102: * Initialize for a Huffman-compressed scan using progressive JPEG.
.//SVD/JPEG/jcphuff.cpp:108:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jcphuff.cpp:113:  entropy->cinfo = cinfo;
.//SVD/JPEG/jcphuff.cpp:114:  entropy->gather_statistics = gather_statistics;
.//SVD/JPEG/jcphuff.cpp:116:  is_DC_band = (cinfo->Ss == 0);
.//SVD/JPEG/jcphuff.cpp:121:  if (cinfo->Ah == 0) {
.//SVD/JPEG/jcphuff.cpp:123:      entropy->pub.encode_mcu = encode_mcu_DC_first;
.//SVD/JPEG/jcphuff.cpp:125:      entropy->pub.encode_mcu = encode_mcu_AC_first;
.//SVD/JPEG/jcphuff.cpp:128:      entropy->pub.encode_mcu = encode_mcu_DC_refine;
.//SVD/JPEG/jcphuff.cpp:130:      entropy->pub.encode_mcu = encode_mcu_AC_refine;
.//SVD/JPEG/jcphuff.cpp:132:      if (entropy->bit_buffer == NULL)
.//SVD/JPEG/jcphuff.cpp:133:	entropy->bit_buffer = (char *)
.//SVD/JPEG/jcphuff.cpp:134:	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcphuff.cpp:139:    entropy->pub.finish_pass = finish_pass_gather_phuff;
.//SVD/JPEG/jcphuff.cpp:141:    entropy->pub.finish_pass = finish_pass_phuff;
.//SVD/JPEG/jcphuff.cpp:143:  /* Only DC coefficients may be interleaved, so cinfo->comps_in_scan = 1
.//SVD/JPEG/jcphuff.cpp:146:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jcphuff.cpp:147:    compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jcphuff.cpp:149:    entropy->last_dc_val[ci] = 0;
.//SVD/JPEG/jcphuff.cpp:152:      if (cinfo->Ah != 0)	/* DC refinement needs no table */
.//SVD/JPEG/jcphuff.cpp:154:      tbl = compptr->dc_tbl_no;
.//SVD/JPEG/jcphuff.cpp:156:      entropy->ac_tbl_no = tbl = compptr->ac_tbl_no;
.//SVD/JPEG/jcphuff.cpp:165:      if (entropy->count_ptrs[tbl] == NULL)
.//SVD/JPEG/jcphuff.cpp:166:	entropy->count_ptrs[tbl] = (long *)
.//SVD/JPEG/jcphuff.cpp:167:	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcphuff.cpp:169:      MEMZERO(entropy->count_ptrs[tbl], 257 * SIZEOF(long));
.//SVD/JPEG/jcphuff.cpp:174:			      & entropy->derived_tbls[tbl]);
.//SVD/JPEG/jcphuff.cpp:179:  entropy->EOBRUN = 0;
.//SVD/JPEG/jcphuff.cpp:180:  entropy->BE = 0;
.//SVD/JPEG/jcphuff.cpp:183:  entropy->put_buffer = 0;
.//SVD/JPEG/jcphuff.cpp:184:  entropy->put_bits = 0;
.//SVD/JPEG/jcphuff.cpp:187:  entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jcphuff.cpp:188:  entropy->next_restart_num = 0;
.//SVD/JPEG/jcphuff.cpp:194: * that is, entropy->gather_statistics == FALSE.
.//SVD/JPEG/jcphuff.cpp:199:	{ *(entropy)->next_output_byte++ = (JOCTET) (val);  \
.//SVD/JPEG/jcphuff.cpp:200:	  if (--(entropy)->free_in_buffer == 0)  \
.//SVD/JPEG/jcphuff.cpp:208:  struct jpeg_destination_mgr * dest = entropy->cinfo->dest;
.//SVD/JPEG/jcphuff.cpp:210:  if (! (*dest->empty_output_buffer) (entropy->cinfo))
.//SVD/JPEG/jcphuff.cpp:211:    ERREXIT(entropy->cinfo, JERR_CANT_SUSPEND);
.//SVD/JPEG/jcphuff.cpp:213:  entropy->next_output_byte = dest->next_output_byte;
.//SVD/JPEG/jcphuff.cpp:214:  entropy->free_in_buffer = dest->free_in_buffer;
.//SVD/JPEG/jcphuff.cpp:221: * left-justified in this part.  At most 16 bits can be passed to emit_bits
.//SVD/JPEG/jcphuff.cpp:233:  register int put_bits = entropy->put_bits;
.//SVD/JPEG/jcphuff.cpp:237:    ERREXIT(entropy->cinfo, JERR_HUFF_MISSING_CODE);
.//SVD/JPEG/jcphuff.cpp:239:  if (entropy->gather_statistics)
.//SVD/JPEG/jcphuff.cpp:242:  put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
.//SVD/JPEG/jcphuff.cpp:246:  put_buffer <<= 24 - put_bits; /* align incoming bits */
.//SVD/JPEG/jcphuff.cpp:248:  put_buffer |= entropy->put_buffer; /* and merge with old buffer contents */
.//SVD/JPEG/jcphuff.cpp:258:    put_bits -= 8;
.//SVD/JPEG/jcphuff.cpp:261:  entropy->put_buffer = put_buffer; /* update variables */
.//SVD/JPEG/jcphuff.cpp:262:  entropy->put_bits = put_bits;
.//SVD/JPEG/jcphuff.cpp:270:  entropy->put_buffer = 0;     /* and reset bit-buffer to empty */
.//SVD/JPEG/jcphuff.cpp:271:  entropy->put_bits = 0;
.//SVD/JPEG/jcphuff.cpp:283:  if (entropy->gather_statistics)
.//SVD/JPEG/jcphuff.cpp:284:    entropy->count_ptrs[tbl_no][symbol]++;
.//SVD/JPEG/jcphuff.cpp:286:    c_derived_tbl * tbl = entropy->derived_tbls[tbl_no];
.//SVD/JPEG/jcphuff.cpp:287:    emit_bits(entropy, tbl->ehufco[symbol], tbl->ehufsi[symbol]);
.//SVD/JPEG/jcphuff.cpp:300:  if (entropy->gather_statistics)
.//SVD/JPEG/jcphuff.cpp:306:    nbits--;
.//SVD/JPEG/jcphuff.cpp:320:  if (entropy->EOBRUN > 0) {	/* if there is any pending EOBRUN */
.//SVD/JPEG/jcphuff.cpp:321:    temp = entropy->EOBRUN;
.//SVD/JPEG/jcphuff.cpp:325:    /* safety check: shouldn't happen given limited correction-bit buffer */
.//SVD/JPEG/jcphuff.cpp:327:      ERREXIT(entropy->cinfo, JERR_HUFF_MISSING_CODE);
.//SVD/JPEG/jcphuff.cpp:329:    emit_symbol(entropy, entropy->ac_tbl_no, nbits << 4);
.//SVD/JPEG/jcphuff.cpp:331:      emit_bits(entropy, entropy->EOBRUN, nbits);
.//SVD/JPEG/jcphuff.cpp:333:    entropy->EOBRUN = 0;
.//SVD/JPEG/jcphuff.cpp:336:    emit_buffered_bits(entropy, entropy->bit_buffer, entropy->BE);
.//SVD/JPEG/jcphuff.cpp:337:    entropy->BE = 0;
.//SVD/JPEG/jcphuff.cpp:353:  if (! entropy->gather_statistics) {
.//SVD/JPEG/jcphuff.cpp:359:  if (entropy->cinfo->Ss == 0) {
.//SVD/JPEG/jcphuff.cpp:360:    /* Re-initialize DC predictions to 0 */
.//SVD/JPEG/jcphuff.cpp:361:    for (ci = 0; ci < entropy->cinfo->comps_in_scan; ci++)
.//SVD/JPEG/jcphuff.cpp:362:      entropy->last_dc_val[ci] = 0;
.//SVD/JPEG/jcphuff.cpp:364:    /* Re-initialize all AC-related fields to 0 */
.//SVD/JPEG/jcphuff.cpp:365:    entropy->EOBRUN = 0;
.//SVD/JPEG/jcphuff.cpp:366:    entropy->BE = 0;
.//SVD/JPEG/jcphuff.cpp:379:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jcphuff.cpp:383:  int Al = cinfo->Al;
.//SVD/JPEG/jcphuff.cpp:388:  entropy->next_output_byte = cinfo->dest->next_output_byte;
.//SVD/JPEG/jcphuff.cpp:389:  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
.//SVD/JPEG/jcphuff.cpp:392:  if (cinfo->restart_interval)
.//SVD/JPEG/jcphuff.cpp:393:    if (entropy->restarts_to_go == 0)
.//SVD/JPEG/jcphuff.cpp:394:      emit_restart(entropy, entropy->next_restart_num);
.//SVD/JPEG/jcphuff.cpp:397:  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//SVD/JPEG/jcphuff.cpp:399:    ci = cinfo->MCU_membership[blkn];
.//SVD/JPEG/jcphuff.cpp:400:    compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jcphuff.cpp:407:    /* DC differences are figured on the point-transformed values. */
.//SVD/JPEG/jcphuff.cpp:408:    temp = temp2 - entropy->last_dc_val[ci];
.//SVD/JPEG/jcphuff.cpp:409:    entropy->last_dc_val[ci] = temp2;
.//SVD/JPEG/jcphuff.cpp:414:      temp = -temp;		/* temp is abs value of input */
.//SVD/JPEG/jcphuff.cpp:417:      temp2--;
.//SVD/JPEG/jcphuff.cpp:426:    /* Check for out-of-range coefficient values.
.//SVD/JPEG/jcphuff.cpp:432:    /* Count/emit the Huffman-coded symbol for the number of bits */
.//SVD/JPEG/jcphuff.cpp:433:    emit_symbol(entropy, compptr->dc_tbl_no, nbits);
.//SVD/JPEG/jcphuff.cpp:441:  cinfo->dest->next_output_byte = entropy->next_output_byte;
.//SVD/JPEG/jcphuff.cpp:442:  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
.//SVD/JPEG/jcphuff.cpp:444:  /* Update restart-interval state too */
.//SVD/JPEG/jcphuff.cpp:445:  if (cinfo->restart_interval) {
.//SVD/JPEG/jcphuff.cpp:446:    if (entropy->restarts_to_go == 0) {
.//SVD/JPEG/jcphuff.cpp:447:      entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jcphuff.cpp:448:      entropy->next_restart_num++;
.//SVD/JPEG/jcphuff.cpp:449:      entropy->next_restart_num &= 7;
.//SVD/JPEG/jcphuff.cpp:451:    entropy->restarts_to_go--;
.//SVD/JPEG/jcphuff.cpp:466:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jcphuff.cpp:470:  int Se = cinfo->Se;
.//SVD/JPEG/jcphuff.cpp:471:  int Al = cinfo->Al;
.//SVD/JPEG/jcphuff.cpp:474:  entropy->next_output_byte = cinfo->dest->next_output_byte;
.//SVD/JPEG/jcphuff.cpp:475:  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
.//SVD/JPEG/jcphuff.cpp:478:  if (cinfo->restart_interval)
.//SVD/JPEG/jcphuff.cpp:479:    if (entropy->restarts_to_go == 0)
.//SVD/JPEG/jcphuff.cpp:480:      emit_restart(entropy, entropy->next_restart_num);
.//SVD/JPEG/jcphuff.cpp:489:  for (k = cinfo->Ss; k <= Se; k++) {
.//SVD/JPEG/jcphuff.cpp:500:      temp = -temp;		/* temp is abs value of input */
.//SVD/JPEG/jcphuff.cpp:515:    if (entropy->EOBRUN > 0)
.//SVD/JPEG/jcphuff.cpp:517:    /* if run length > 15, must emit special run-length-16 codes (0xF0) */
.//SVD/JPEG/jcphuff.cpp:519:      emit_symbol(entropy, entropy->ac_tbl_no, 0xF0);
.//SVD/JPEG/jcphuff.cpp:520:      r -= 16;
.//SVD/JPEG/jcphuff.cpp:527:    /* Check for out-of-range coefficient values */
.//SVD/JPEG/jcphuff.cpp:532:    emit_symbol(entropy, entropy->ac_tbl_no, (r << 4) + nbits);
.//SVD/JPEG/jcphuff.cpp:542:    entropy->EOBRUN++;		/* count an EOB */
.//SVD/JPEG/jcphuff.cpp:543:    if (entropy->EOBRUN == 0x7FFF)
.//SVD/JPEG/jcphuff.cpp:547:  cinfo->dest->next_output_byte = entropy->next_output_byte;
.//SVD/JPEG/jcphuff.cpp:548:  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
.//SVD/JPEG/jcphuff.cpp:550:  /* Update restart-interval state too */
.//SVD/JPEG/jcphuff.cpp:551:  if (cinfo->restart_interval) {
.//SVD/JPEG/jcphuff.cpp:552:    if (entropy->restarts_to_go == 0) {
.//SVD/JPEG/jcphuff.cpp:553:      entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jcphuff.cpp:554:      entropy->next_restart_num++;
.//SVD/JPEG/jcphuff.cpp:555:      entropy->next_restart_num &= 7;
.//SVD/JPEG/jcphuff.cpp:557:    entropy->restarts_to_go--;
.//SVD/JPEG/jcphuff.cpp:566: * Note: we assume such scans can be multi-component, although the spec
.//SVD/JPEG/jcphuff.cpp:573:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jcphuff.cpp:576:  int Al = cinfo->Al;
.//SVD/JPEG/jcphuff.cpp:579:  entropy->next_output_byte = cinfo->dest->next_output_byte;
.//SVD/JPEG/jcphuff.cpp:580:  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
.//SVD/JPEG/jcphuff.cpp:583:  if (cinfo->restart_interval)
.//SVD/JPEG/jcphuff.cpp:584:    if (entropy->restarts_to_go == 0)
.//SVD/JPEG/jcphuff.cpp:585:      emit_restart(entropy, entropy->next_restart_num);
.//SVD/JPEG/jcphuff.cpp:588:  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//SVD/JPEG/jcphuff.cpp:596:  cinfo->dest->next_output_byte = entropy->next_output_byte;
.//SVD/JPEG/jcphuff.cpp:597:  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
.//SVD/JPEG/jcphuff.cpp:599:  /* Update restart-interval state too */
.//SVD/JPEG/jcphuff.cpp:600:  if (cinfo->restart_interval) {
.//SVD/JPEG/jcphuff.cpp:601:    if (entropy->restarts_to_go == 0) {
.//SVD/JPEG/jcphuff.cpp:602:      entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jcphuff.cpp:603:      entropy->next_restart_num++;
.//SVD/JPEG/jcphuff.cpp:604:      entropy->next_restart_num &= 7;
.//SVD/JPEG/jcphuff.cpp:606:    entropy->restarts_to_go--;
.//SVD/JPEG/jcphuff.cpp:620:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jcphuff.cpp:626:  int Se = cinfo->Se;
.//SVD/JPEG/jcphuff.cpp:627:  int Al = cinfo->Al;
.//SVD/JPEG/jcphuff.cpp:631:  entropy->next_output_byte = cinfo->dest->next_output_byte;
.//SVD/JPEG/jcphuff.cpp:632:  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
.//SVD/JPEG/jcphuff.cpp:635:  if (cinfo->restart_interval)
.//SVD/JPEG/jcphuff.cpp:636:    if (entropy->restarts_to_go == 0)
.//SVD/JPEG/jcphuff.cpp:637:      emit_restart(entropy, entropy->next_restart_num);
.//SVD/JPEG/jcphuff.cpp:642:  /* It is convenient to make a pre-pass to determine the transformed
.//SVD/JPEG/jcphuff.cpp:646:  for (k = cinfo->Ss; k <= Se; k++) {
.//SVD/JPEG/jcphuff.cpp:653:      temp = -temp;		/* temp is abs value of input */
.//SVD/JPEG/jcphuff.cpp:657:      EOB = k;			/* EOB = index of last newly-nonzero coef */
.//SVD/JPEG/jcphuff.cpp:664:  BR_buffer = entropy->bit_buffer + entropy->BE; /* Append bits to buffer */
.//SVD/JPEG/jcphuff.cpp:666:  for (k = cinfo->Ss; k <= Se; k++) {
.//SVD/JPEG/jcphuff.cpp:677:      emit_symbol(entropy, entropy->ac_tbl_no, 0xF0);
.//SVD/JPEG/jcphuff.cpp:678:      r -= 16;
.//SVD/JPEG/jcphuff.cpp:681:      BR_buffer = entropy->bit_buffer; /* BE bits are gone now */
.//SVD/JPEG/jcphuff.cpp:700:    emit_symbol(entropy, entropy->ac_tbl_no, (r << 4) + 1);
.//SVD/JPEG/jcphuff.cpp:702:    /* Emit output bit for newly-nonzero coef */
.//SVD/JPEG/jcphuff.cpp:708:    BR_buffer = entropy->bit_buffer; /* BE bits are gone now */
.//SVD/JPEG/jcphuff.cpp:714:    entropy->EOBRUN++;		/* count an EOB */
.//SVD/JPEG/jcphuff.cpp:715:    entropy->BE += BR;		/* concat my correction bits to older ones */
.//SVD/JPEG/jcphuff.cpp:720:    if (entropy->EOBRUN == 0x7FFF || entropy->BE > (MAX_CORR_BITS-DCTSIZE2+1))
.//SVD/JPEG/jcphuff.cpp:724:  cinfo->dest->next_output_byte = entropy->next_output_byte;
.//SVD/JPEG/jcphuff.cpp:725:  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
.//SVD/JPEG/jcphuff.cpp:727:  /* Update restart-interval state too */
.//SVD/JPEG/jcphuff.cpp:728:  if (cinfo->restart_interval) {
.//SVD/JPEG/jcphuff.cpp:729:    if (entropy->restarts_to_go == 0) {
.//SVD/JPEG/jcphuff.cpp:730:      entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jcphuff.cpp:731:      entropy->next_restart_num++;
.//SVD/JPEG/jcphuff.cpp:732:      entropy->next_restart_num &= 7;
.//SVD/JPEG/jcphuff.cpp:734:    entropy->restarts_to_go--;
.//SVD/JPEG/jcphuff.cpp:742: * Finish up at the end of a Huffman-compressed progressive scan.
.//SVD/JPEG/jcphuff.cpp:748:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jcphuff.cpp:750:  entropy->next_output_byte = cinfo->dest->next_output_byte;
.//SVD/JPEG/jcphuff.cpp:751:  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
.//SVD/JPEG/jcphuff.cpp:757:  cinfo->dest->next_output_byte = entropy->next_output_byte;
.//SVD/JPEG/jcphuff.cpp:758:  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
.//SVD/JPEG/jcphuff.cpp:763: * Finish up a statistics-gathering pass and create the new Huffman tables.
.//SVD/JPEG/jcphuff.cpp:769:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jcphuff.cpp:779:  is_DC_band = (cinfo->Ss == 0);
.//SVD/JPEG/jcphuff.cpp:786:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jcphuff.cpp:787:    compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jcphuff.cpp:789:      if (cinfo->Ah != 0)	/* DC refinement needs no table */
.//SVD/JPEG/jcphuff.cpp:791:      tbl = compptr->dc_tbl_no;
.//SVD/JPEG/jcphuff.cpp:793:      tbl = compptr->ac_tbl_no;
.//SVD/JPEG/jcphuff.cpp:797:        htblptr = & cinfo->dc_huff_tbl_ptrs[tbl];
.//SVD/JPEG/jcphuff.cpp:799:        htblptr = & cinfo->ac_huff_tbl_ptrs[tbl];
.//SVD/JPEG/jcphuff.cpp:802:      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->count_ptrs[tbl]);
.//SVD/JPEG/jcphuff.cpp:820:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcphuff.cpp:822:  cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
.//SVD/JPEG/jcphuff.cpp:823:  entropy->pub.start_pass = start_pass_phuff;
.//SVD/JPEG/jcphuff.cpp:827:    entropy->derived_tbls[i] = NULL;
.//SVD/JPEG/jcphuff.cpp:828:    entropy->count_ptrs[i] = NULL;
.//SVD/JPEG/jcphuff.cpp:830:  entropy->bit_buffer = NULL;	/* needed only in AC refinement scan */
.//SVD/JPEG/jcprepct.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jcprepct.cpp:24: * or other more-complex downsampling procedures.  The code to support
.//SVD/JPEG/jcprepct.cpp:33: * For the simple (no-context-row) case, we just need to buffer one
.//SVD/JPEG/jcprepct.cpp:56:  /* Downsampling input buffer.  This buffer holds color-converted data
.//SVD/JPEG/jcprepct.cpp:80:  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
.//SVD/JPEG/jcprepct.cpp:85:  /* Initialize total-height counter for detecting bottom of image */
.//SVD/JPEG/jcprepct.cpp:86:  prep->rows_to_go = cinfo->image_height;
.//SVD/JPEG/jcprepct.cpp:88:  prep->next_buf_row = 0;
.//SVD/JPEG/jcprepct.cpp:91:   * These aren't used in non-context mode, so we needn't test which mode.
.//SVD/JPEG/jcprepct.cpp:93:  prep->this_row_group = 0;
.//SVD/JPEG/jcprepct.cpp:95:  prep->next_buf_stop = 2 * cinfo->max_v_samp_factor;
.//SVD/JPEG/jcprepct.cpp:112:    jcopy_sample_rows(image_data, input_rows-1, image_data, row,
.//SVD/JPEG/jcprepct.cpp:119: * Process some data in the simple no-context case.
.//SVD/JPEG/jcprepct.cpp:134:  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
.//SVD/JPEG/jcprepct.cpp:142:    inrows = in_rows_avail - *in_row_ctr;
.//SVD/JPEG/jcprepct.cpp:143:    numrows = cinfo->max_v_samp_factor - prep->next_buf_row;
.//SVD/JPEG/jcprepct.cpp:145:    (*cinfo->cconvert->color_convert) (cinfo, input_buf + *in_row_ctr,
.//SVD/JPEG/jcprepct.cpp:146:				       prep->color_buf,
.//SVD/JPEG/jcprepct.cpp:147:				       (JDIMENSION) prep->next_buf_row,
.//SVD/JPEG/jcprepct.cpp:150:    prep->next_buf_row += numrows;
.//SVD/JPEG/jcprepct.cpp:151:    prep->rows_to_go -= numrows;
.//SVD/JPEG/jcprepct.cpp:153:    if (prep->rows_to_go == 0 &&
.//SVD/JPEG/jcprepct.cpp:154:	prep->next_buf_row < cinfo->max_v_samp_factor) {
.//SVD/JPEG/jcprepct.cpp:155:      for (ci = 0; ci < cinfo->num_components; ci++) {
.//SVD/JPEG/jcprepct.cpp:156:	expand_bottom_edge(prep->color_buf[ci], cinfo->image_width,
.//SVD/JPEG/jcprepct.cpp:157:			   prep->next_buf_row, cinfo->max_v_samp_factor);
.//SVD/JPEG/jcprepct.cpp:159:      prep->next_buf_row = cinfo->max_v_samp_factor;
.//SVD/JPEG/jcprepct.cpp:162:    if (prep->next_buf_row == cinfo->max_v_samp_factor) {
.//SVD/JPEG/jcprepct.cpp:163:      (*cinfo->downsample->downsample) (cinfo,
.//SVD/JPEG/jcprepct.cpp:164:					prep->color_buf, (JDIMENSION) 0,
.//SVD/JPEG/jcprepct.cpp:166:      prep->next_buf_row = 0;
.//SVD/JPEG/jcprepct.cpp:170:     * Note we assume the caller is providing a one-iMCU-height output buffer!
.//SVD/JPEG/jcprepct.cpp:172:    if (prep->rows_to_go == 0 &&
.//SVD/JPEG/jcprepct.cpp:174:      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcprepct.cpp:177:			   compptr->width_in_blocks * DCTSIZE,
.//SVD/JPEG/jcprepct.cpp:178:			   (int) (*out_row_group_ctr * compptr->v_samp_factor),
.//SVD/JPEG/jcprepct.cpp:179:			   (int) (out_row_groups_avail * compptr->v_samp_factor));
.//SVD/JPEG/jcprepct.cpp:201:  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
.//SVD/JPEG/jcprepct.cpp:203:  int buf_height = cinfo->max_v_samp_factor * 3;
.//SVD/JPEG/jcprepct.cpp:209:      inrows = in_rows_avail - *in_row_ctr;
.//SVD/JPEG/jcprepct.cpp:210:      numrows = prep->next_buf_stop - prep->next_buf_row;
.//SVD/JPEG/jcprepct.cpp:212:      (*cinfo->cconvert->color_convert) (cinfo, input_buf + *in_row_ctr,
.//SVD/JPEG/jcprepct.cpp:213:					 prep->color_buf,
.//SVD/JPEG/jcprepct.cpp:214:					 (JDIMENSION) prep->next_buf_row,
.//SVD/JPEG/jcprepct.cpp:217:      if (prep->rows_to_go == cinfo->image_height) {
.//SVD/JPEG/jcprepct.cpp:218:	for (ci = 0; ci < cinfo->num_components; ci++) {
.//SVD/JPEG/jcprepct.cpp:220:	  for (row = 1; row <= cinfo->max_v_samp_factor; row++) {
.//SVD/JPEG/jcprepct.cpp:221:	    jcopy_sample_rows(prep->color_buf[ci], 0,
.//SVD/JPEG/jcprepct.cpp:222:			      prep->color_buf[ci], -row,
.//SVD/JPEG/jcprepct.cpp:223:			      1, cinfo->image_width);
.//SVD/JPEG/jcprepct.cpp:228:      prep->next_buf_row += numrows;
.//SVD/JPEG/jcprepct.cpp:229:      prep->rows_to_go -= numrows;
.//SVD/JPEG/jcprepct.cpp:232:      if (prep->rows_to_go != 0)
.//SVD/JPEG/jcprepct.cpp:235:      if (prep->next_buf_row < prep->next_buf_stop) {
.//SVD/JPEG/jcprepct.cpp:236:	for (ci = 0; ci < cinfo->num_components; ci++) {
.//SVD/JPEG/jcprepct.cpp:237:	  expand_bottom_edge(prep->color_buf[ci], cinfo->image_width,
.//SVD/JPEG/jcprepct.cpp:238:			     prep->next_buf_row, prep->next_buf_stop);
.//SVD/JPEG/jcprepct.cpp:240:	prep->next_buf_row = prep->next_buf_stop;
.//SVD/JPEG/jcprepct.cpp:244:    if (prep->next_buf_row == prep->next_buf_stop) {
.//SVD/JPEG/jcprepct.cpp:245:      (*cinfo->downsample->downsample) (cinfo,
.//SVD/JPEG/jcprepct.cpp:246:					prep->color_buf,
.//SVD/JPEG/jcprepct.cpp:247:					(JDIMENSION) prep->this_row_group,
.//SVD/JPEG/jcprepct.cpp:251:      prep->this_row_group += cinfo->max_v_samp_factor;
.//SVD/JPEG/jcprepct.cpp:252:      if (prep->this_row_group >= buf_height)
.//SVD/JPEG/jcprepct.cpp:253:	prep->this_row_group = 0;
.//SVD/JPEG/jcprepct.cpp:254:      if (prep->next_buf_row >= buf_height)
.//SVD/JPEG/jcprepct.cpp:255:	prep->next_buf_row = 0;
.//SVD/JPEG/jcprepct.cpp:256:      prep->next_buf_stop = prep->next_buf_row + cinfo->max_v_samp_factor;
.//SVD/JPEG/jcprepct.cpp:263: * Create the wrapped-around downsampling input buffer needed for context mode.
.//SVD/JPEG/jcprepct.cpp:269:  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
.//SVD/JPEG/jcprepct.cpp:270:  int rgroup_height = cinfo->max_v_samp_factor;
.//SVD/JPEG/jcprepct.cpp:279:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcprepct.cpp:280:				(cinfo->num_components * 5 * rgroup_height) *
.//SVD/JPEG/jcprepct.cpp:283:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcprepct.cpp:286:     * We make the buffer wide enough to allow the downsampler to edge-expand
.//SVD/JPEG/jcprepct.cpp:289:    true_buffer = (*cinfo->mem->alloc_sarray)
.//SVD/JPEG/jcprepct.cpp:291:       (JDIMENSION) (((long) compptr->width_in_blocks * DCTSIZE *
.//SVD/JPEG/jcprepct.cpp:292:		      cinfo->max_h_samp_factor) / compptr->h_samp_factor),
.//SVD/JPEG/jcprepct.cpp:302:    prep->color_buf[ci] = fake_buffer + rgroup_height;
.//SVD/JPEG/jcprepct.cpp:325:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcprepct.cpp:327:  cinfo->prep = (struct jpeg_c_prep_controller *) prep;
.//SVD/JPEG/jcprepct.cpp:328:  prep->pub.start_pass = start_pass_prep;
.//SVD/JPEG/jcprepct.cpp:331:   * We make the buffer wide enough to allow the downsampler to edge-expand
.//SVD/JPEG/jcprepct.cpp:334:  if (cinfo->downsample->need_context_rows) {
.//SVD/JPEG/jcprepct.cpp:337:    prep->pub.pre_process_data = pre_process_context;
.//SVD/JPEG/jcprepct.cpp:344:    prep->pub.pre_process_data = pre_process_data;
.//SVD/JPEG/jcprepct.cpp:345:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcprepct.cpp:347:      prep->color_buf[ci] = (*cinfo->mem->alloc_sarray)
.//SVD/JPEG/jcprepct.cpp:349:	 (JDIMENSION) (((long) compptr->width_in_blocks * DCTSIZE *
.//SVD/JPEG/jcprepct.cpp:350:			cinfo->max_h_samp_factor) / compptr->h_samp_factor),
.//SVD/JPEG/jcprepct.cpp:351:	 (JDIMENSION) cinfo->max_v_samp_factor);
.//SVD/JPEG/jcsample.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//SVD/JPEG/jcsample.cpp:15: * The downsampler is responsible for edge-expansion of its output data
.//SVD/JPEG/jcsample.cpp:23: * one row group's worth of pixels above and below the passed-in data;
.//SVD/JPEG/jcsample.cpp:29: *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.
.//SVD/JPEG/jcsample.cpp:32: * pixels covered by the output pixel.  The hi-falutin sampling literature
.//SVD/JPEG/jcsample.cpp:39: * A simple input-smoothing capability is provided.  This is mainly intended
.//SVD/JPEG/jcsample.cpp:40: * for cleaning up color-dithered GIF input files (if you find it inadequate,
.//SVD/JPEG/jcsample.cpp:43: * eight neighbors.  P's weight is 1-8*SF and each neighbor's weight is SF,
.//SVD/JPEG/jcsample.cpp:94:  int numcols = (int) (output_cols - input_cols);
.//SVD/JPEG/jcsample.cpp:99:      pixval = ptr[-1];		/* don't need GETJSAMPLE() here */
.//SVD/JPEG/jcsample.cpp:100:      for (count = numcols; count > 0; count--)
.//SVD/JPEG/jcsample.cpp:118:  my_downsample_ptr downsample = (my_downsample_ptr) cinfo->downsample;
.//SVD/JPEG/jcsample.cpp:123:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcsample.cpp:126:    out_ptr = output_buf[ci] + (out_row_group_index * compptr->v_samp_factor);
.//SVD/JPEG/jcsample.cpp:127:    (*downsample->methods[ci]) (cinfo, compptr, in_ptr, out_ptr);
.//SVD/JPEG/jcsample.cpp:145:  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
.//SVD/JPEG/jcsample.cpp:149:  h_expand = cinfo->max_h_samp_factor / compptr->h_samp_factor;
.//SVD/JPEG/jcsample.cpp:150:  v_expand = cinfo->max_v_samp_factor / compptr->v_samp_factor;
.//SVD/JPEG/jcsample.cpp:155:   * by the standard loop.  Special-casing padded output would be more
.//SVD/JPEG/jcsample.cpp:158:  expand_right_edge(input_data, cinfo->max_v_samp_factor,
.//SVD/JPEG/jcsample.cpp:159:		    cinfo->image_width, output_cols * h_expand);
.//SVD/JPEG/jcsample.cpp:162:  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
.//SVD/JPEG/jcsample.cpp:182: * This version handles the special case of a full-size component,
.//SVD/JPEG/jcsample.cpp:192:		    cinfo->max_v_samp_factor, cinfo->image_width);
.//SVD/JPEG/jcsample.cpp:193:  /* Edge-expand */
.//SVD/JPEG/jcsample.cpp:194:  expand_right_edge(output_data, cinfo->max_v_samp_factor,
.//SVD/JPEG/jcsample.cpp:195:		    cinfo->image_width, compptr->width_in_blocks * DCTSIZE);
.//SVD/JPEG/jcsample.cpp:217:  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
.//SVD/JPEG/jcsample.cpp:222:   * by the standard loop.  Special-casing padded output would be more
.//SVD/JPEG/jcsample.cpp:225:  expand_right_edge(input_data, cinfo->max_v_samp_factor,
.//SVD/JPEG/jcsample.cpp:226:		    cinfo->image_width, output_cols * 2);
.//SVD/JPEG/jcsample.cpp:228:  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
.//SVD/JPEG/jcsample.cpp:254:  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
.//SVD/JPEG/jcsample.cpp:259:   * by the standard loop.  Special-casing padded output would be more
.//SVD/JPEG/jcsample.cpp:262:  expand_right_edge(input_data, cinfo->max_v_samp_factor,
.//SVD/JPEG/jcsample.cpp:263:		    cinfo->image_width, output_cols * 2);
.//SVD/JPEG/jcsample.cpp:266:  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
.//SVD/JPEG/jcsample.cpp:297:  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
.//SVD/JPEG/jcsample.cpp:302:   * by the standard loop.  Special-casing padded output would be more
.//SVD/JPEG/jcsample.cpp:305:  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
.//SVD/JPEG/jcsample.cpp:306:		    cinfo->image_width, output_cols * 2);
.//SVD/JPEG/jcsample.cpp:311:   * (1-8*SF) to its own smoothed image and a fraction SF to each of the three
.//SVD/JPEG/jcsample.cpp:312:   * other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final
.//SVD/JPEG/jcsample.cpp:313:   * output.  The four corner-adjacent neighbor pixels contribute a fraction
.//SVD/JPEG/jcsample.cpp:315:   * eight edge-adjacent neighbors contribute SF to each of two smoothed
.//SVD/JPEG/jcsample.cpp:321:  memberscale = 16384 - cinfo->smoothing_factor * 80; /* scaled (1-5*SF)/4 */
.//SVD/JPEG/jcsample.cpp:322:  neighscale = cinfo->smoothing_factor * 16; /* scaled SF/4 */
.//SVD/JPEG/jcsample.cpp:325:  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
.//SVD/JPEG/jcsample.cpp:329:    above_ptr = input_data[inrow-1];
.//SVD/JPEG/jcsample.cpp:332:    /* Special case for first column: pretend column -1 is same as column 0 */
.//SVD/JPEG/jcsample.cpp:346:    for (colctr = output_cols - 2; colctr > 0; colctr--) {
.//SVD/JPEG/jcsample.cpp:350:      /* sum of edge-neighbor pixels */
.//SVD/JPEG/jcsample.cpp:353:		 GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[2]) +
.//SVD/JPEG/jcsample.cpp:354:		 GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[2]);
.//SVD/JPEG/jcsample.cpp:355:      /* The edge-neighbors count twice as much as corner-neighbors */
.//SVD/JPEG/jcsample.cpp:357:      /* Add in the corner-neighbors */
.//SVD/JPEG/jcsample.cpp:358:      neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[2]) +
.//SVD/JPEG/jcsample.cpp:359:		  GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[2]);
.//SVD/JPEG/jcsample.cpp:372:	       GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[1]) +
.//SVD/JPEG/jcsample.cpp:373:	       GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[1]);
.//SVD/JPEG/jcsample.cpp:375:    neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[1]) +
.//SVD/JPEG/jcsample.cpp:376:		GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[1]);
.//SVD/JPEG/jcsample.cpp:387: * This version handles the special case of a full-size component,
.//SVD/JPEG/jcsample.cpp:397:  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
.//SVD/JPEG/jcsample.cpp:403:   * by the standard loop.  Special-casing padded output would be more
.//SVD/JPEG/jcsample.cpp:406:  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
.//SVD/JPEG/jcsample.cpp:407:		    cinfo->image_width, output_cols);
.//SVD/JPEG/jcsample.cpp:410:   * smoothed pixel, while the main pixel contributes (1-8*SF).  In order
.//SVD/JPEG/jcsample.cpp:415:  memberscale = 65536L - cinfo->smoothing_factor * 512L; /* scaled 1-8*SF */
.//SVD/JPEG/jcsample.cpp:416:  neighscale = cinfo->smoothing_factor * 64; /* scaled SF */
.//SVD/JPEG/jcsample.cpp:418:  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
.//SVD/JPEG/jcsample.cpp:421:    above_ptr = input_data[outrow-1];
.//SVD/JPEG/jcsample.cpp:430:    neighsum = colsum + (colsum - membersum) + nextcolsum;
.//SVD/JPEG/jcsample.cpp:435:    for (colctr = output_cols - 2; colctr > 0; colctr--) {
.//SVD/JPEG/jcsample.cpp:440:      neighsum = lastcolsum + (colsum - membersum) + nextcolsum;
.//SVD/JPEG/jcsample.cpp:448:    neighsum = lastcolsum + (colsum - membersum) + colsum;
.//SVD/JPEG/jcsample.cpp:472:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jcsample.cpp:474:  cinfo->downsample = (struct jpeg_downsampler *) downsample;
.//SVD/JPEG/jcsample.cpp:475:  downsample->pub.start_pass = start_pass_downsample;
.//SVD/JPEG/jcsample.cpp:476:  downsample->pub.downsample = sep_downsample;
.//SVD/JPEG/jcsample.cpp:477:  downsample->pub.need_context_rows = FALSE;
.//SVD/JPEG/jcsample.cpp:479:  if (cinfo->CCIR601_sampling)
.//SVD/JPEG/jcsample.cpp:483:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jcsample.cpp:485:    if (compptr->h_samp_factor == cinfo->max_h_samp_factor &&
.//SVD/JPEG/jcsample.cpp:486:	compptr->v_samp_factor == cinfo->max_v_samp_factor) {
.//SVD/JPEG/jcsample.cpp:488:      if (cinfo->smoothing_factor) {
.//SVD/JPEG/jcsample.cpp:489:	downsample->methods[ci] = fullsize_smooth_downsample;
.//SVD/JPEG/jcsample.cpp:490:	downsample->pub.need_context_rows = TRUE;
.//SVD/JPEG/jcsample.cpp:493:	downsample->methods[ci] = fullsize_downsample;
.//SVD/JPEG/jcsample.cpp:494:    } else if (compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&
.//SVD/JPEG/jcsample.cpp:495:	       compptr->v_samp_factor == cinfo->max_v_samp_factor) {
.//SVD/JPEG/jcsample.cpp:497:      downsample->methods[ci] = h2v1_downsample;
.//SVD/JPEG/jcsample.cpp:498:    } else if (compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&
.//SVD/JPEG/jcsample.cpp:499:	       compptr->v_samp_factor * 2 == cinfo->max_v_samp_factor) {
.//SVD/JPEG/jcsample.cpp:501:      if (cinfo->smoothing_factor) {
.//SVD/JPEG/jcsample.cpp:502:	downsample->methods[ci] = h2v2_smooth_downsample;
.//SVD/JPEG/jcsample.cpp:503:	downsample->pub.need_context_rows = TRUE;
.//SVD/JPEG/jcsample.cpp:506:	downsample->methods[ci] = h2v2_downsample;
.//SVD/JPEG/jcsample.cpp:507:    } else if ((cinfo->max_h_samp_factor % compptr->h_samp_factor) == 0 &&
.//SVD/JPEG/jcsample.cpp:508:	       (cinfo->max_v_samp_factor % compptr->v_samp_factor) == 0) {
.//SVD/JPEG/jcsample.cpp:510:      downsample->methods[ci] = int_downsample;
.//SVD/JPEG/jcsample.cpp:516:  if (cinfo->smoothing_factor && !smoothok)
.//SVD/JPEG/jctrans.cpp:4: * Copyright (C) 1995-1998, Thomas G. Lane.
.//SVD/JPEG/jctrans.cpp:26: * Compression initialization for writing raw-coefficient data.
.//SVD/JPEG/jctrans.cpp:30: * The number of passed virtual arrays must match cinfo->num_components.
.//SVD/JPEG/jctrans.cpp:40:  if (cinfo->global_state != CSTATE_START)
.//SVD/JPEG/jctrans.cpp:41:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jctrans.cpp:45:  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
.//SVD/JPEG/jctrans.cpp:46:  (*cinfo->dest->init_destination) (cinfo);
.//SVD/JPEG/jctrans.cpp:50:  cinfo->next_scanline = 0;	/* so jpeg_write_marker works */
.//SVD/JPEG/jctrans.cpp:51:  cinfo->global_state = CSTATE_WRCOEFS;
.//SVD/JPEG/jctrans.cpp:72:  if (dstinfo->global_state != CSTATE_START)
.//SVD/JPEG/jctrans.cpp:73:    ERREXIT1(dstinfo, JERR_BAD_STATE, dstinfo->global_state);
.//SVD/JPEG/jctrans.cpp:75:  dstinfo->image_width = srcinfo->image_width;
.//SVD/JPEG/jctrans.cpp:76:  dstinfo->image_height = srcinfo->image_height;
.//SVD/JPEG/jctrans.cpp:77:  dstinfo->input_components = srcinfo->num_components;
.//SVD/JPEG/jctrans.cpp:78:  dstinfo->in_color_space = srcinfo->jpeg_color_space;
.//SVD/JPEG/jctrans.cpp:84:  jpeg_set_colorspace(dstinfo, srcinfo->jpeg_color_space);
.//SVD/JPEG/jctrans.cpp:85:  dstinfo->data_precision = srcinfo->data_precision;
.//SVD/JPEG/jctrans.cpp:86:  dstinfo->CCIR601_sampling = srcinfo->CCIR601_sampling;
.//SVD/JPEG/jctrans.cpp:89:    if (srcinfo->quant_tbl_ptrs[tblno] != NULL) {
.//SVD/JPEG/jctrans.cpp:90:      qtblptr = & dstinfo->quant_tbl_ptrs[tblno];
.//SVD/JPEG/jctrans.cpp:93:      MEMCOPY((*qtblptr)->quantval,
.//SVD/JPEG/jctrans.cpp:94:	      srcinfo->quant_tbl_ptrs[tblno]->quantval,
.//SVD/JPEG/jctrans.cpp:95:	      SIZEOF((*qtblptr)->quantval));
.//SVD/JPEG/jctrans.cpp:96:      (*qtblptr)->sent_table = FALSE;
.//SVD/JPEG/jctrans.cpp:99:  /* Copy the source's per-component info.
.//SVD/JPEG/jctrans.cpp:102:  dstinfo->num_components = srcinfo->num_components;
.//SVD/JPEG/jctrans.cpp:103:  if (dstinfo->num_components < 1 || dstinfo->num_components > MAX_COMPONENTS)
.//SVD/JPEG/jctrans.cpp:104:    ERREXIT2(dstinfo, JERR_COMPONENT_COUNT, dstinfo->num_components,
.//SVD/JPEG/jctrans.cpp:106:  for (ci = 0, incomp = srcinfo->comp_info, outcomp = dstinfo->comp_info;
.//SVD/JPEG/jctrans.cpp:107:       ci < dstinfo->num_components; ci++, incomp++, outcomp++) {
.//SVD/JPEG/jctrans.cpp:108:    outcomp->component_id = incomp->component_id;
.//SVD/JPEG/jctrans.cpp:109:    outcomp->h_samp_factor = incomp->h_samp_factor;
.//SVD/JPEG/jctrans.cpp:110:    outcomp->v_samp_factor = incomp->v_samp_factor;
.//SVD/JPEG/jctrans.cpp:111:    outcomp->quant_tbl_no = incomp->quant_tbl_no;
.//SVD/JPEG/jctrans.cpp:113:     * slot.  If not, the input file re-used this qtable slot.
.//SVD/JPEG/jctrans.cpp:116:    tblno = outcomp->quant_tbl_no;
.//SVD/JPEG/jctrans.cpp:118:	srcinfo->quant_tbl_ptrs[tblno] == NULL)
.//SVD/JPEG/jctrans.cpp:120:    slot_quant = srcinfo->quant_tbl_ptrs[tblno];
.//SVD/JPEG/jctrans.cpp:121:    c_quant = incomp->quant_table;
.//SVD/JPEG/jctrans.cpp:124:	if (c_quant->quantval[coefi] != slot_quant->quantval[coefi])
.//SVD/JPEG/jctrans.cpp:140:  if (srcinfo->saw_JFIF_marker) {
.//SVD/JPEG/jctrans.cpp:141:    if (srcinfo->JFIF_major_version == 1) {
.//SVD/JPEG/jctrans.cpp:142:      dstinfo->JFIF_major_version = srcinfo->JFIF_major_version;
.//SVD/JPEG/jctrans.cpp:143:      dstinfo->JFIF_minor_version = srcinfo->JFIF_minor_version;
.//SVD/JPEG/jctrans.cpp:145:    dstinfo->density_unit = srcinfo->density_unit;
.//SVD/JPEG/jctrans.cpp:146:    dstinfo->X_density = srcinfo->X_density;
.//SVD/JPEG/jctrans.cpp:147:    dstinfo->Y_density = srcinfo->Y_density;
.//SVD/JPEG/jctrans.cpp:164:  cinfo->input_components = 1;
.//SVD/JPEG/jctrans.cpp:169:  if (cinfo->arith_code) {
.//SVD/JPEG/jctrans.cpp:172:    if (cinfo->progressive_mode) {
.//SVD/JPEG/jctrans.cpp:188:  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
.//SVD/JPEG/jctrans.cpp:194:  (*cinfo->marker->write_file_header) (cinfo);
.//SVD/JPEG/jctrans.cpp:202: * dummy padding blocks on-the-fly rather than expecting them to be present
.//SVD/JPEG/jctrans.cpp:228:/* Reset within-iMCU-row counters for a new row */
.//SVD/JPEG/jctrans.cpp:230:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jctrans.cpp:236:  if (cinfo->comps_in_scan > 1) {
.//SVD/JPEG/jctrans.cpp:237:    coef->MCU_rows_per_iMCU_row = 1;
.//SVD/JPEG/jctrans.cpp:239:    if (coef->iMCU_row_num < (cinfo->total_iMCU_rows-1))
.//SVD/JPEG/jctrans.cpp:240:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
.//SVD/JPEG/jctrans.cpp:242:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
.//SVD/JPEG/jctrans.cpp:245:  coef->mcu_ctr = 0;
.//SVD/JPEG/jctrans.cpp:246:  coef->MCU_vert_offset = 0;
.//SVD/JPEG/jctrans.cpp:257:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jctrans.cpp:262:  coef->iMCU_row_num = 0;
.//SVD/JPEG/jctrans.cpp:280:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jctrans.cpp:282:  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
.//SVD/JPEG/jctrans.cpp:283:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//SVD/JPEG/jctrans.cpp:292:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jctrans.cpp:293:    compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jctrans.cpp:294:    buffer[ci] = (*cinfo->mem->access_virt_barray)
.//SVD/JPEG/jctrans.cpp:295:      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
.//SVD/JPEG/jctrans.cpp:296:       coef->iMCU_row_num * compptr->v_samp_factor,
.//SVD/JPEG/jctrans.cpp:297:       (JDIMENSION) compptr->v_samp_factor, FALSE);
.//SVD/JPEG/jctrans.cpp:301:  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
.//SVD/JPEG/jctrans.cpp:303:    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;
.//SVD/JPEG/jctrans.cpp:307:      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jctrans.cpp:308:	compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jctrans.cpp:309:	start_col = MCU_col_num * compptr->MCU_width;
.//SVD/JPEG/jctrans.cpp:310:	blockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
.//SVD/JPEG/jctrans.cpp:311:						: compptr->last_col_width;
.//SVD/JPEG/jctrans.cpp:312:	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
.//SVD/JPEG/jctrans.cpp:313:	  if (coef->iMCU_row_num < last_iMCU_row ||
.//SVD/JPEG/jctrans.cpp:314:	      yindex+yoffset < compptr->last_row_height) {
.//SVD/JPEG/jctrans.cpp:329:	  for (; xindex < compptr->MCU_width; xindex++) {
.//SVD/JPEG/jctrans.cpp:330:	    MCU_buffer[blkn] = coef->dummy_buffer[blkn];
.//SVD/JPEG/jctrans.cpp:331:	    MCU_buffer[blkn][0][0] = MCU_buffer[blkn-1][0][0];
.//SVD/JPEG/jctrans.cpp:337:      if (! (*cinfo->entropy->encode_mcu) (cinfo, MCU_buffer)) {
.//SVD/JPEG/jctrans.cpp:339:	coef->MCU_vert_offset = yoffset;
.//SVD/JPEG/jctrans.cpp:340:	coef->mcu_ctr = MCU_col_num;
.//SVD/JPEG/jctrans.cpp:345:    coef->mcu_ctr = 0;
.//SVD/JPEG/jctrans.cpp:348:  coef->iMCU_row_num++;
.//SVD/JPEG/jctrans.cpp:371:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jctrans.cpp:373:  cinfo->coef = (struct jpeg_c_coef_controller *) coef;
.//SVD/JPEG/jctrans.cpp:374:  coef->pub.start_pass = start_pass_coef;
.//SVD/JPEG/jctrans.cpp:375:  coef->pub.compress_data = compress_output;
.//SVD/JPEG/jctrans.cpp:378:  coef->whole_image = coef_arrays;
.//SVD/JPEG/jctrans.cpp:380:  /* Allocate and pre-zero space for dummy DCT blocks. */
.//SVD/JPEG/jctrans.cpp:382:    (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jctrans.cpp:386:    coef->dummy_buffer[i] = buffer + i;
.//SVD/JPEG/jdapimin.cpp:4:* Copyright (C) 1994-1998, Thomas G. Lane.
.//SVD/JPEG/jdapimin.cpp:10:* needed in either the normal full-decompression case or the
.//SVD/JPEG/jdapimin.cpp:11:* transcoding-only case.
.//SVD/JPEG/jdapimin.cpp:35:	cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
.//SVD/JPEG/jdapimin.cpp:49:		struct jpeg_error_mgr * err = cinfo->err;
.//SVD/JPEG/jdapimin.cpp:50:		void * client_data = cinfo->client_data; /* ignore Purify complaint here */
.//SVD/JPEG/jdapimin.cpp:52:		cinfo->err = err;
.//SVD/JPEG/jdapimin.cpp:53:		cinfo->client_data = client_data;
.//SVD/JPEG/jdapimin.cpp:55:	cinfo->is_decompressor = TRUE;
.//SVD/JPEG/jdapimin.cpp:61:	cinfo->progress = NULL;
.//SVD/JPEG/jdapimin.cpp:62:	cinfo->src = NULL;
.//SVD/JPEG/jdapimin.cpp:65:		cinfo->quant_tbl_ptrs[i] = NULL;
.//SVD/JPEG/jdapimin.cpp:68:		cinfo->dc_huff_tbl_ptrs[i] = NULL;
.//SVD/JPEG/jdapimin.cpp:69:		cinfo->ac_huff_tbl_ptrs[i] = NULL;
.//SVD/JPEG/jdapimin.cpp:75:	cinfo->marker_list = NULL;
.//SVD/JPEG/jdapimin.cpp:82:	cinfo->global_state = DSTATE_START;
.//SVD/JPEG/jdapimin.cpp:119:	switch (cinfo->num_components) {
.//SVD/JPEG/jdapimin.cpp:121:		cinfo->jpeg_color_space = JCS_GRAYSCALE;
.//SVD/JPEG/jdapimin.cpp:122:		cinfo->out_color_space = JCS_GRAYSCALE;
.//SVD/JPEG/jdapimin.cpp:126:		if (cinfo->saw_JFIF_marker) {
.//SVD/JPEG/jdapimin.cpp:127:			cinfo->jpeg_color_space = JCS_YCbCr; /* JFIF implies YCbCr */
.//SVD/JPEG/jdapimin.cpp:128:		} else if (cinfo->saw_Adobe_marker) {
.//SVD/JPEG/jdapimin.cpp:129:			switch (cinfo->Adobe_transform) {
.//SVD/JPEG/jdapimin.cpp:131:				cinfo->jpeg_color_space = JCS_RGB;
.//SVD/JPEG/jdapimin.cpp:134:				cinfo->jpeg_color_space = JCS_YCbCr;
.//SVD/JPEG/jdapimin.cpp:137:				WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
.//SVD/JPEG/jdapimin.cpp:138:				cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
.//SVD/JPEG/jdapimin.cpp:143:			int cid0 = cinfo->comp_info[0].component_id;
.//SVD/JPEG/jdapimin.cpp:144:			int cid1 = cinfo->comp_info[1].component_id;
.//SVD/JPEG/jdapimin.cpp:145:			int cid2 = cinfo->comp_info[2].component_id;
.//SVD/JPEG/jdapimin.cpp:148:				cinfo->jpeg_color_space = JCS_YCbCr; /* assume JFIF w/out marker */
.//SVD/JPEG/jdapimin.cpp:150:				cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
.//SVD/JPEG/jdapimin.cpp:153:				cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
.//SVD/JPEG/jdapimin.cpp:157:		cinfo->out_color_space = JCS_RGB;
.//SVD/JPEG/jdapimin.cpp:161:				if (cinfo->saw_Adobe_marker) {
.//SVD/JPEG/jdapimin.cpp:162:					switch (cinfo->Adobe_transform) {
.//SVD/JPEG/jdapimin.cpp:164:						cinfo->jpeg_color_space = JCS_CMYK;
.//SVD/JPEG/jdapimin.cpp:167:						cinfo->jpeg_color_space = JCS_YCCK;
.//SVD/JPEG/jdapimin.cpp:170:						WARNMS1(cinfo, JWRN_ADOBE_XFORM, cinfo->Adobe_transform);
.//SVD/JPEG/jdapimin.cpp:171:						cinfo->jpeg_color_space = JCS_YCCK; /* assume it's YCCK */
.//SVD/JPEG/jdapimin.cpp:176:					cinfo->jpeg_color_space = JCS_CMYK;
.//SVD/JPEG/jdapimin.cpp:178:				cinfo->out_color_space = JCS_CMYK;
.//SVD/JPEG/jdapimin.cpp:182:						cinfo->jpeg_color_space = JCS_UNKNOWN;
.//SVD/JPEG/jdapimin.cpp:183:						cinfo->out_color_space = JCS_UNKNOWN;
.//SVD/JPEG/jdapimin.cpp:188:	cinfo->scale_num = 1;		/* 1:1 scaling */
.//SVD/JPEG/jdapimin.cpp:189:	cinfo->scale_denom = 1;
.//SVD/JPEG/jdapimin.cpp:190:	cinfo->output_gamma = 1.0;
.//SVD/JPEG/jdapimin.cpp:191:	cinfo->buffered_image = FALSE;
.//SVD/JPEG/jdapimin.cpp:192:	cinfo->raw_data_out = FALSE;
.//SVD/JPEG/jdapimin.cpp:193:	cinfo->dct_method = JDCT_DEFAULT;
.//SVD/JPEG/jdapimin.cpp:194:	cinfo->do_fancy_upsampling = TRUE;
.//SVD/JPEG/jdapimin.cpp:195:	cinfo->do_block_smoothing = TRUE;
.//SVD/JPEG/jdapimin.cpp:196:	cinfo->quantize_colors = FALSE;
.//SVD/JPEG/jdapimin.cpp:198:	cinfo->dither_mode = JDITHER_FS;
.//SVD/JPEG/jdapimin.cpp:200:	cinfo->two_pass_quantize = TRUE;
.//SVD/JPEG/jdapimin.cpp:202:	cinfo->two_pass_quantize = FALSE;
.//SVD/JPEG/jdapimin.cpp:204:	cinfo->desired_number_of_colors = 256;
.//SVD/JPEG/jdapimin.cpp:205:	cinfo->colormap = NULL;
.//SVD/JPEG/jdapimin.cpp:206:	/* Initialize for no mode change in buffered-image mode. */
.//SVD/JPEG/jdapimin.cpp:207:	cinfo->enable_1pass_quant = FALSE;
.//SVD/JPEG/jdapimin.cpp:208:	cinfo->enable_external_quant = FALSE;
.//SVD/JPEG/jdapimin.cpp:209:	cinfo->enable_2pass_quant = FALSE;
.//SVD/JPEG/jdapimin.cpp:227:* re-use the JPEG object to read the abbreviated image datastream(s).
.//SVD/JPEG/jdapimin.cpp:231:* should load more source data and then re-call jpeg_read_header to resume
.//SVD/JPEG/jdapimin.cpp:233:* If a non-suspending data source is used and require_image is TRUE, then the
.//SVD/JPEG/jdapimin.cpp:245:	if (cinfo->global_state != DSTATE_START &&
.//SVD/JPEG/jdapimin.cpp:246:		cinfo->global_state != DSTATE_INHEADER)
.//SVD/JPEG/jdapimin.cpp:247:		ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdapimin.cpp:280:* of critical state-transition actions, namely initial setup and
.//SVD/JPEG/jdapimin.cpp:281:* transition from header scanning to ready-for-start_decompress.
.//SVD/JPEG/jdapimin.cpp:292:	switch (cinfo->global_state) {
.//SVD/JPEG/jdapimin.cpp:294:		/* Start-of-datastream actions: reset appropriate modules */
.//SVD/JPEG/jdapimin.cpp:295:		(*cinfo->inputctl->reset_input_controller) (cinfo);
.//SVD/JPEG/jdapimin.cpp:297:		(*cinfo->src->init_source) (cinfo);
.//SVD/JPEG/jdapimin.cpp:298:		cinfo->global_state = DSTATE_INHEADER;
.//SVD/JPEG/jdapimin.cpp:301:		retcode = (*cinfo->inputctl->consume_input) (cinfo);
.//SVD/JPEG/jdapimin.cpp:306:			cinfo->global_state = DSTATE_READY;
.//SVD/JPEG/jdapimin.cpp:320:		retcode = (*cinfo->inputctl->consume_input) (cinfo);
.//SVD/JPEG/jdapimin.cpp:323:		ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdapimin.cpp:337:	if (cinfo->global_state < DSTATE_START ||
.//SVD/JPEG/jdapimin.cpp:338:		cinfo->global_state > DSTATE_STOPPING)
.//SVD/JPEG/jdapimin.cpp:339:		ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdapimin.cpp:340:	return cinfo->inputctl->eoi_reached;
.//SVD/JPEG/jdapimin.cpp:352:	if (cinfo->global_state < DSTATE_READY ||
.//SVD/JPEG/jdapimin.cpp:353:		cinfo->global_state > DSTATE_STOPPING)
.//SVD/JPEG/jdapimin.cpp:354:		ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdapimin.cpp:355:	return cinfo->inputctl->has_multiple_scans;
.//SVD/JPEG/jdapimin.cpp:370:	if ((cinfo->global_state == DSTATE_SCANNING ||
.//SVD/JPEG/jdapimin.cpp:371:		cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
.//SVD/JPEG/jdapimin.cpp:372:		/* Terminate final pass of non-buffered mode */
.//SVD/JPEG/jdapimin.cpp:373:		if (cinfo->output_scanline < cinfo->output_height)
.//SVD/JPEG/jdapimin.cpp:375:		(*cinfo->master->finish_output_pass) (cinfo);
.//SVD/JPEG/jdapimin.cpp:376:		cinfo->global_state = DSTATE_STOPPING;
.//SVD/JPEG/jdapimin.cpp:377:	} else if (cinfo->global_state == DSTATE_BUFIMAGE) {
.//SVD/JPEG/jdapimin.cpp:378:		/* Finishing after a buffered-image operation */
.//SVD/JPEG/jdapimin.cpp:379:		cinfo->global_state = DSTATE_STOPPING;
.//SVD/JPEG/jdapimin.cpp:380:	} else if (cinfo->global_state != DSTATE_STOPPING) {
.//SVD/JPEG/jdapimin.cpp:382:		ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdapimin.cpp:385:	while (! cinfo->inputctl->eoi_reached) {
.//SVD/JPEG/jdapimin.cpp:386:		if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
.//SVD/JPEG/jdapimin.cpp:390:	(*cinfo->src->term_source) (cinfo);
.//SVD/JPEG/jdapistd.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jdapistd.cpp:10: * used in the normal full-decompression case.  They are not used by a
.//SVD/JPEG/jdapistd.cpp:11: * transcoding-only application.  Note that if an application links in
.//SVD/JPEG/jdapistd.cpp:40:  if (cinfo->global_state == DSTATE_READY) {
.//SVD/JPEG/jdapistd.cpp:43:    if (cinfo->buffered_image) {
.//SVD/JPEG/jdapistd.cpp:45:      cinfo->global_state = DSTATE_BUFIMAGE;
.//SVD/JPEG/jdapistd.cpp:48:    cinfo->global_state = DSTATE_PRELOAD;
.//SVD/JPEG/jdapistd.cpp:50:  if (cinfo->global_state == DSTATE_PRELOAD) {
.//SVD/JPEG/jdapistd.cpp:52:    if (cinfo->inputctl->has_multiple_scans) {
.//SVD/JPEG/jdapistd.cpp:57:	if (cinfo->progress != NULL)
.//SVD/JPEG/jdapistd.cpp:58:	  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//SVD/JPEG/jdapistd.cpp:60:	retcode = (*cinfo->inputctl->consume_input) (cinfo);
.//SVD/JPEG/jdapistd.cpp:66:	if (cinfo->progress != NULL &&
.//SVD/JPEG/jdapistd.cpp:68:	  if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
.//SVD/JPEG/jdapistd.cpp:70:	    cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
.//SVD/JPEG/jdapistd.cpp:78:    cinfo->output_scan_number = cinfo->input_scan_number;
.//SVD/JPEG/jdapistd.cpp:79:  } else if (cinfo->global_state != DSTATE_PRESCAN)
.//SVD/JPEG/jdapistd.cpp:80:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdapistd.cpp:97:  if (cinfo->global_state != DSTATE_PRESCAN) {
.//SVD/JPEG/jdapistd.cpp:99:    (*cinfo->master->prepare_for_output_pass) (cinfo);
.//SVD/JPEG/jdapistd.cpp:100:    cinfo->output_scanline = 0;
.//SVD/JPEG/jdapistd.cpp:101:    cinfo->global_state = DSTATE_PRESCAN;
.//SVD/JPEG/jdapistd.cpp:104:  while (cinfo->master->is_dummy_pass) {
.//SVD/JPEG/jdapistd.cpp:107:    while (cinfo->output_scanline < cinfo->output_height) {
.//SVD/JPEG/jdapistd.cpp:110:      if (cinfo->progress != NULL) {
.//SVD/JPEG/jdapistd.cpp:111:	cinfo->progress->pass_counter = (long) cinfo->output_scanline;
.//SVD/JPEG/jdapistd.cpp:112:	cinfo->progress->pass_limit = (long) cinfo->output_height;
.//SVD/JPEG/jdapistd.cpp:113:	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//SVD/JPEG/jdapistd.cpp:116:      last_scanline = cinfo->output_scanline;
.//SVD/JPEG/jdapistd.cpp:117:      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,
.//SVD/JPEG/jdapistd.cpp:118:				    &cinfo->output_scanline, (JDIMENSION) 0);
.//SVD/JPEG/jdapistd.cpp:119:      if (cinfo->output_scanline == last_scanline)
.//SVD/JPEG/jdapistd.cpp:123:    (*cinfo->master->finish_output_pass) (cinfo);
.//SVD/JPEG/jdapistd.cpp:124:    (*cinfo->master->prepare_for_output_pass) (cinfo);
.//SVD/JPEG/jdapistd.cpp:125:    cinfo->output_scanline = 0;
.//SVD/JPEG/jdapistd.cpp:133:  cinfo->global_state = cinfo->raw_data_out ? DSTATE_RAW_OK : DSTATE_SCANNING;
.//SVD/JPEG/jdapistd.cpp:157:  if (cinfo->global_state != DSTATE_SCANNING)
.//SVD/JPEG/jdapistd.cpp:158:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdapistd.cpp:159:  if (cinfo->output_scanline >= cinfo->output_height) {
.//SVD/JPEG/jdapistd.cpp:165:  if (cinfo->progress != NULL) {
.//SVD/JPEG/jdapistd.cpp:166:    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
.//SVD/JPEG/jdapistd.cpp:167:    cinfo->progress->pass_limit = (long) cinfo->output_height;
.//SVD/JPEG/jdapistd.cpp:168:    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//SVD/JPEG/jdapistd.cpp:173:  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);
.//SVD/JPEG/jdapistd.cpp:174:  cinfo->output_scanline += row_ctr;
.//SVD/JPEG/jdapistd.cpp:190:  if (cinfo->global_state != DSTATE_RAW_OK)
.//SVD/JPEG/jdapistd.cpp:191:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdapistd.cpp:192:  if (cinfo->output_scanline >= cinfo->output_height) {
.//SVD/JPEG/jdapistd.cpp:198:  if (cinfo->progress != NULL) {
.//SVD/JPEG/jdapistd.cpp:199:    cinfo->progress->pass_counter = (long) cinfo->output_scanline;
.//SVD/JPEG/jdapistd.cpp:200:    cinfo->progress->pass_limit = (long) cinfo->output_height;
.//SVD/JPEG/jdapistd.cpp:201:    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//SVD/JPEG/jdapistd.cpp:205:  lines_per_iMCU_row = cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size;
.//SVD/JPEG/jdapistd.cpp:210:  if (! (*cinfo->coef->decompress_data) (cinfo, data))
.//SVD/JPEG/jdapistd.cpp:214:  cinfo->output_scanline += lines_per_iMCU_row;
.//SVD/JPEG/jdapistd.cpp:219:/* Additional entry points for buffered-image mode. */
.//SVD/JPEG/jdapistd.cpp:224: * Initialize for an output pass in buffered-image mode.
.//SVD/JPEG/jdapistd.cpp:230:  if (cinfo->global_state != DSTATE_BUFIMAGE &&
.//SVD/JPEG/jdapistd.cpp:231:      cinfo->global_state != DSTATE_PRESCAN)
.//SVD/JPEG/jdapistd.cpp:232:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdapistd.cpp:236:  if (cinfo->inputctl->eoi_reached &&
.//SVD/JPEG/jdapistd.cpp:237:      scan_number > cinfo->input_scan_number)
.//SVD/JPEG/jdapistd.cpp:238:    scan_number = cinfo->input_scan_number;
.//SVD/JPEG/jdapistd.cpp:239:  cinfo->output_scan_number = scan_number;
.//SVD/JPEG/jdapistd.cpp:246: * Finish up after an output pass in buffered-image mode.
.//SVD/JPEG/jdapistd.cpp:255:  if ((cinfo->global_state == DSTATE_SCANNING ||
.//SVD/JPEG/jdapistd.cpp:256:       cinfo->global_state == DSTATE_RAW_OK) && cinfo->buffered_image) {
.//SVD/JPEG/jdapistd.cpp:259:    (*cinfo->master->finish_output_pass) (cinfo);
.//SVD/JPEG/jdapistd.cpp:260:    cinfo->global_state = DSTATE_BUFPOST;
.//SVD/JPEG/jdapistd.cpp:261:  } else if (cinfo->global_state != DSTATE_BUFPOST) {
.//SVD/JPEG/jdapistd.cpp:263:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdapistd.cpp:266:  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
.//SVD/JPEG/jdapistd.cpp:267:	 ! cinfo->inputctl->eoi_reached) {
.//SVD/JPEG/jdapistd.cpp:268:    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
.//SVD/JPEG/jdapistd.cpp:271:  cinfo->global_state = DSTATE_BUFIMAGE;
.//SVD/JPEG/jdatadst.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jdatadst.cpp:13: * JOCTETs into 8-bit-wide elements on external storage.  If char is wider
.//SVD/JPEG/jdatadst.cpp:38: * Initialize destination --- called by jpeg_start_compress
.//SVD/JPEG/jdatadst.cpp:45:  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
.//SVD/JPEG/jdatadst.cpp:47:  /* Allocate the output buffer --- it will be released when done with image */
.//SVD/JPEG/jdatadst.cpp:48:  dest->buffer = (JOCTET *)
.//SVD/JPEG/jdatadst.cpp:49:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdatadst.cpp:52:  dest->pub.next_output_byte = dest->buffer;
.//SVD/JPEG/jdatadst.cpp:53:  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;
.//SVD/JPEG/jdatadst.cpp:58: * Empty the output buffer --- called whenever buffer fills up.
.//SVD/JPEG/jdatadst.cpp:71: * suspension --- see the documentation.
.//SVD/JPEG/jdatadst.cpp:83:  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
.//SVD/JPEG/jdatadst.cpp:85:  if (JFWRITE(dest->outfile, dest->buffer, OUTPUT_BUF_SIZE) !=
.//SVD/JPEG/jdatadst.cpp:89:  dest->pub.next_output_byte = dest->buffer;
.//SVD/JPEG/jdatadst.cpp:90:  dest->pub.free_in_buffer = OUTPUT_BUF_SIZE;
.//SVD/JPEG/jdatadst.cpp:97: * Terminate destination --- called by jpeg_finish_compress
.//SVD/JPEG/jdatadst.cpp:108:  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
.//SVD/JPEG/jdatadst.cpp:109:  size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;
.//SVD/JPEG/jdatadst.cpp:113:    if (JFWRITE(dest->outfile, dest->buffer, datacount) != datacount)
.//SVD/JPEG/jdatadst.cpp:116:  fflush(dest->outfile);
.//SVD/JPEG/jdatadst.cpp:118:  if (ferror(dest->outfile))
.//SVD/JPEG/jdatadst.cpp:135:   * can be written to the same file without re-executing jpeg_stdio_dest.
.//SVD/JPEG/jdatadst.cpp:140:  if (cinfo->dest == NULL) {	/* first time for this JPEG object? */
.//SVD/JPEG/jdatadst.cpp:141:    cinfo->dest = (struct jpeg_destination_mgr *)
.//SVD/JPEG/jdatadst.cpp:142:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//SVD/JPEG/jdatadst.cpp:146:  dest = (my_dest_ptr) cinfo->dest;
.//SVD/JPEG/jdatadst.cpp:147:  dest->pub.init_destination = init_destination;
.//SVD/JPEG/jdatadst.cpp:148:  dest->pub.empty_output_buffer = empty_output_buffer;
.//SVD/JPEG/jdatadst.cpp:149:  dest->pub.term_destination = term_destination;
.//SVD/JPEG/jdatadst.cpp:150:  dest->outfile = outfile;
.//SVD/JPEG/jdatasrc.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jdatasrc.cpp:13: * JOCTETs from 8-bit-wide elements on external storage.  If char is wider
.//SVD/JPEG/jdatasrc.cpp:39: * Initialize source --- called by jpeg_read_header
.//SVD/JPEG/jdatasrc.cpp:46:  my_src_ptr src = (my_src_ptr) cinfo->src;
.//SVD/JPEG/jdatasrc.cpp:48:  /* We reset the empty-input-file flag for each image,
.//SVD/JPEG/jdatasrc.cpp:52:  src->start_of_file = TRUE;
.//SVD/JPEG/jdatasrc.cpp:57: * Fill the input buffer --- called whenever buffer is emptied.
.//SVD/JPEG/jdatasrc.cpp:68: * fake EOI marker is the best course of action --- this will allow the
.//SVD/JPEG/jdatasrc.cpp:79: * that there are substantial restrictions on the use of suspension --- see
.//SVD/JPEG/jdatasrc.cpp:92:  my_src_ptr src = (my_src_ptr) cinfo->src;
.//SVD/JPEG/jdatasrc.cpp:95:  nbytes = JFREAD(src->infile, src->buffer, INPUT_BUF_SIZE);
.//SVD/JPEG/jdatasrc.cpp:98:    if (src->start_of_file)	/* Treat empty input file as fatal error */
.//SVD/JPEG/jdatasrc.cpp:102:    src->buffer[0] = (JOCTET) 0xFF;
.//SVD/JPEG/jdatasrc.cpp:103:    src->buffer[1] = (JOCTET) JPEG_EOI;
.//SVD/JPEG/jdatasrc.cpp:107:  src->pub.next_input_byte = src->buffer;
.//SVD/JPEG/jdatasrc.cpp:108:  src->pub.bytes_in_buffer = nbytes;
.//SVD/JPEG/jdatasrc.cpp:109:  src->start_of_file = FALSE;
.//SVD/JPEG/jdatasrc.cpp:116: * Skip data --- used to skip over a potentially large amount of
.//SVD/JPEG/jdatasrc.cpp:119: * Writers of suspendable-input applications must note that skip_input_data
.//SVD/JPEG/jdatasrc.cpp:130:  my_src_ptr src = (my_src_ptr) cinfo->src;
.//SVD/JPEG/jdatasrc.cpp:134:   * any trouble anyway --- large skips are infrequent.
.//SVD/JPEG/jdatasrc.cpp:137:    while (num_bytes > (long) src->pub.bytes_in_buffer) {
.//SVD/JPEG/jdatasrc.cpp:138:      num_bytes -= (long) src->pub.bytes_in_buffer;
.//SVD/JPEG/jdatasrc.cpp:144:    src->pub.next_input_byte += (size_t) num_bytes;
.//SVD/JPEG/jdatasrc.cpp:145:    src->pub.bytes_in_buffer -= (size_t) num_bytes;
.//SVD/JPEG/jdatasrc.cpp:160: * Terminate source --- called by jpeg_finish_decompress
.//SVD/JPEG/jdatasrc.cpp:161: * after all data has been read.  Often a no-op.
.//SVD/JPEG/jdatasrc.cpp:193:  if (cinfo->src == NULL) {	/* first time for this JPEG object? */
.//SVD/JPEG/jdatasrc.cpp:194:    cinfo->src = (struct jpeg_source_mgr *)
.//SVD/JPEG/jdatasrc.cpp:195:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//SVD/JPEG/jdatasrc.cpp:197:    src = (my_src_ptr) cinfo->src;
.//SVD/JPEG/jdatasrc.cpp:198:    src->buffer = (JOCTET *)
.//SVD/JPEG/jdatasrc.cpp:199:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//SVD/JPEG/jdatasrc.cpp:203:  src = (my_src_ptr) cinfo->src;
.//SVD/JPEG/jdatasrc.cpp:204:  src->pub.init_source = init_source;
.//SVD/JPEG/jdatasrc.cpp:205:  src->pub.fill_input_buffer = fill_input_buffer;
.//SVD/JPEG/jdatasrc.cpp:206:  src->pub.skip_input_data = skip_input_data;
.//SVD/JPEG/jdatasrc.cpp:207:  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
.//SVD/JPEG/jdatasrc.cpp:208:  src->pub.term_source = term_source;
.//SVD/JPEG/jdatasrc.cpp:209:  src->infile = infile;
.//SVD/JPEG/jdatasrc.cpp:210:  src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
.//SVD/JPEG/jdatasrc.cpp:211:  src->pub.next_input_byte = NULL; /* until buffer loaded */
.//SVD/JPEG/jdcoefct.cpp:4: * Copyright (C) 1994-1997, Thomas G. Lane.
.//SVD/JPEG/jdcoefct.cpp:10: * The coefficient buffer lies between entropy decoding and inverse-DCT steps.
.//SVD/JPEG/jdcoefct.cpp:12: * In buffered-image mode, this controller is the interface between
.//SVD/JPEG/jdcoefct.cpp:13: * input-oriented processing and output-oriented processing.
.//SVD/JPEG/jdcoefct.cpp:32:  /* cinfo->input_iMCU_row is also used for this. */
.//SVD/JPEG/jdcoefct.cpp:37:  /* The output side's location is represented by cinfo->output_iMCU_row. */
.//SVD/JPEG/jdcoefct.cpp:39:  /* In single-pass modes, it's sufficient to buffer just one MCU.
.//SVD/JPEG/jdcoefct.cpp:45:   * In multi-pass modes, this array points to the current MCU's blocks
.//SVD/JPEG/jdcoefct.cpp:51:  /* In multi-pass modes, we need a virtual block array for each component. */
.//SVD/JPEG/jdcoefct.cpp:80:/* Reset within-iMCU-row counters for a new row (input side) */
.//SVD/JPEG/jdcoefct.cpp:82:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jdcoefct.cpp:88:  if (cinfo->comps_in_scan > 1) {
.//SVD/JPEG/jdcoefct.cpp:89:    coef->MCU_rows_per_iMCU_row = 1;
.//SVD/JPEG/jdcoefct.cpp:91:    if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
.//SVD/JPEG/jdcoefct.cpp:92:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
.//SVD/JPEG/jdcoefct.cpp:94:      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
.//SVD/JPEG/jdcoefct.cpp:97:  coef->MCU_ctr = 0;
.//SVD/JPEG/jdcoefct.cpp:98:  coef->MCU_vert_offset = 0;
.//SVD/JPEG/jdcoefct.cpp:109:  cinfo->input_iMCU_row = 0;
.//SVD/JPEG/jdcoefct.cpp:122:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jdcoefct.cpp:125:  if (coef->pub.coef_arrays != NULL) {
.//SVD/JPEG/jdcoefct.cpp:126:    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
.//SVD/JPEG/jdcoefct.cpp:127:      coef->pub.decompress_data = decompress_smooth_data;
.//SVD/JPEG/jdcoefct.cpp:129:      coef->pub.decompress_data = decompress_data;
.//SVD/JPEG/jdcoefct.cpp:132:  cinfo->output_iMCU_row = 0;
.//SVD/JPEG/jdcoefct.cpp:137: * Decompress and return some data in the single-pass case.
.//SVD/JPEG/jdcoefct.cpp:139: * Input and output must run in lockstep since we have only a one-MCU buffer.
.//SVD/JPEG/jdcoefct.cpp:149:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jdcoefct.cpp:151:  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
.//SVD/JPEG/jdcoefct.cpp:152:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//SVD/JPEG/jdcoefct.cpp:160:  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
.//SVD/JPEG/jdcoefct.cpp:162:    for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
.//SVD/JPEG/jdcoefct.cpp:165:      jzero_far((void FAR *) coef->MCU_buffer[0],
.//SVD/JPEG/jdcoefct.cpp:166:		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
.//SVD/JPEG/jdcoefct.cpp:167:      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
.//SVD/JPEG/jdcoefct.cpp:169:	coef->MCU_vert_offset = yoffset;
.//SVD/JPEG/jdcoefct.cpp:170:	coef->MCU_ctr = MCU_col_num;
.//SVD/JPEG/jdcoefct.cpp:179:      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jdcoefct.cpp:180:	compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jdcoefct.cpp:182:	if (! compptr->component_needed) {
.//SVD/JPEG/jdcoefct.cpp:183:	  blkn += compptr->MCU_blocks;
.//SVD/JPEG/jdcoefct.cpp:186:	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
.//SVD/JPEG/jdcoefct.cpp:187:	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
.//SVD/JPEG/jdcoefct.cpp:188:						    : compptr->last_col_width;
.//SVD/JPEG/jdcoefct.cpp:189:	output_ptr = output_buf[compptr->component_index] +
.//SVD/JPEG/jdcoefct.cpp:190:	  yoffset * compptr->DCT_scaled_size;
.//SVD/JPEG/jdcoefct.cpp:191:	start_col = MCU_col_num * compptr->MCU_sample_width;
.//SVD/JPEG/jdcoefct.cpp:192:	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
.//SVD/JPEG/jdcoefct.cpp:193:	  if (cinfo->input_iMCU_row < last_iMCU_row ||
.//SVD/JPEG/jdcoefct.cpp:194:	      yoffset+yindex < compptr->last_row_height) {
.//SVD/JPEG/jdcoefct.cpp:198:			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
.//SVD/JPEG/jdcoefct.cpp:200:	      output_col += compptr->DCT_scaled_size;
.//SVD/JPEG/jdcoefct.cpp:203:	  blkn += compptr->MCU_width;
.//SVD/JPEG/jdcoefct.cpp:204:	  output_ptr += compptr->DCT_scaled_size;
.//SVD/JPEG/jdcoefct.cpp:209:    coef->MCU_ctr = 0;
.//SVD/JPEG/jdcoefct.cpp:212:  cinfo->output_iMCU_row++;
.//SVD/JPEG/jdcoefct.cpp:213:  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
.//SVD/JPEG/jdcoefct.cpp:218:  (*cinfo->inputctl->finish_input_pass) (cinfo);
.//SVD/JPEG/jdcoefct.cpp:224: * Dummy consume-input routine for single-pass operation.
.//SVD/JPEG/jdcoefct.cpp:237: * Consume input data and store it in the full-image coefficient buffer.
.//SVD/JPEG/jdcoefct.cpp:246:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jdcoefct.cpp:255:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jdcoefct.cpp:256:    compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jdcoefct.cpp:257:    buffer[ci] = (*cinfo->mem->access_virt_barray)
.//SVD/JPEG/jdcoefct.cpp:258:      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
.//SVD/JPEG/jdcoefct.cpp:259:       cinfo->input_iMCU_row * compptr->v_samp_factor,
.//SVD/JPEG/jdcoefct.cpp:260:       (JDIMENSION) compptr->v_samp_factor, TRUE);
.//SVD/JPEG/jdcoefct.cpp:263:     * because we requested a pre-zeroed array.
.//SVD/JPEG/jdcoefct.cpp:268:  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
.//SVD/JPEG/jdcoefct.cpp:270:    for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
.//SVD/JPEG/jdcoefct.cpp:274:      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jdcoefct.cpp:275:	compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jdcoefct.cpp:276:	start_col = MCU_col_num * compptr->MCU_width;
.//SVD/JPEG/jdcoefct.cpp:277:	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
.//SVD/JPEG/jdcoefct.cpp:279:	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
.//SVD/JPEG/jdcoefct.cpp:280:	    coef->MCU_buffer[blkn++] = buffer_ptr++;
.//SVD/JPEG/jdcoefct.cpp:285:      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
.//SVD/JPEG/jdcoefct.cpp:287:	coef->MCU_vert_offset = yoffset;
.//SVD/JPEG/jdcoefct.cpp:288:	coef->MCU_ctr = MCU_col_num;
.//SVD/JPEG/jdcoefct.cpp:293:    coef->MCU_ctr = 0;
.//SVD/JPEG/jdcoefct.cpp:296:  if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
.//SVD/JPEG/jdcoefct.cpp:301:  (*cinfo->inputctl->finish_input_pass) (cinfo);
.//SVD/JPEG/jdcoefct.cpp:307: * Decompress and return some data in the multi-pass case.
.//SVD/JPEG/jdcoefct.cpp:317:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jdcoefct.cpp:318:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//SVD/JPEG/jdcoefct.cpp:329:  while (cinfo->input_scan_number < cinfo->output_scan_number ||
.//SVD/JPEG/jdcoefct.cpp:330:	 (cinfo->input_scan_number == cinfo->output_scan_number &&
.//SVD/JPEG/jdcoefct.cpp:331:	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
.//SVD/JPEG/jdcoefct.cpp:332:    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
.//SVD/JPEG/jdcoefct.cpp:337:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdcoefct.cpp:340:    if (! compptr->component_needed)
.//SVD/JPEG/jdcoefct.cpp:343:    buffer = (*cinfo->mem->access_virt_barray)
.//SVD/JPEG/jdcoefct.cpp:344:      ((j_common_ptr) cinfo, coef->whole_image[ci],
.//SVD/JPEG/jdcoefct.cpp:345:       cinfo->output_iMCU_row * compptr->v_samp_factor,
.//SVD/JPEG/jdcoefct.cpp:346:       (JDIMENSION) compptr->v_samp_factor, FALSE);
.//SVD/JPEG/jdcoefct.cpp:347:    /* Count non-dummy DCT block rows in this iMCU row. */
.//SVD/JPEG/jdcoefct.cpp:348:    if (cinfo->output_iMCU_row < last_iMCU_row)
.//SVD/JPEG/jdcoefct.cpp:349:      block_rows = compptr->v_samp_factor;
.//SVD/JPEG/jdcoefct.cpp:351:      /* NB: can't use last_row_height here; it is input-side-dependent! */
.//SVD/JPEG/jdcoefct.cpp:352:      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
.//SVD/JPEG/jdcoefct.cpp:353:      if (block_rows == 0) block_rows = compptr->v_samp_factor;
.//SVD/JPEG/jdcoefct.cpp:355:    inverse_DCT = cinfo->idct->inverse_DCT[ci];
.//SVD/JPEG/jdcoefct.cpp:361:      for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
.//SVD/JPEG/jdcoefct.cpp:365:	output_col += compptr->DCT_scaled_size;
.//SVD/JPEG/jdcoefct.cpp:367:      output_ptr += compptr->DCT_scaled_size;
.//SVD/JPEG/jdcoefct.cpp:371:  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
.//SVD/JPEG/jdcoefct.cpp:389:/* Natural-order array positions of the first 5 zigzag-order coefficients */
.//SVD/JPEG/jdcoefct.cpp:407:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jdcoefct.cpp:415:  if (! cinfo->progressive_mode || cinfo->coef_bits == NULL)
.//SVD/JPEG/jdcoefct.cpp:419:  if (coef->coef_bits_latch == NULL)
.//SVD/JPEG/jdcoefct.cpp:420:    coef->coef_bits_latch = (int *)
.//SVD/JPEG/jdcoefct.cpp:421:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdcoefct.cpp:422:				  cinfo->num_components *
.//SVD/JPEG/jdcoefct.cpp:424:  coef_bits_latch = coef->coef_bits_latch;
.//SVD/JPEG/jdcoefct.cpp:426:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdcoefct.cpp:429:    if ((qtable = compptr->quant_table) == NULL)
.//SVD/JPEG/jdcoefct.cpp:431:    /* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
.//SVD/JPEG/jdcoefct.cpp:432:    if (qtable->quantval[0] == 0 ||
.//SVD/JPEG/jdcoefct.cpp:433:	qtable->quantval[Q01_POS] == 0 ||
.//SVD/JPEG/jdcoefct.cpp:434:	qtable->quantval[Q10_POS] == 0 ||
.//SVD/JPEG/jdcoefct.cpp:435:	qtable->quantval[Q20_POS] == 0 ||
.//SVD/JPEG/jdcoefct.cpp:436:	qtable->quantval[Q11_POS] == 0 ||
.//SVD/JPEG/jdcoefct.cpp:437:	qtable->quantval[Q02_POS] == 0)
.//SVD/JPEG/jdcoefct.cpp:440:    coef_bits = cinfo->coef_bits[ci];
.//SVD/JPEG/jdcoefct.cpp:463:  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
.//SVD/JPEG/jdcoefct.cpp:464:  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
.//SVD/JPEG/jdcoefct.cpp:482:  while (cinfo->input_scan_number <= cinfo->output_scan_number &&
.//SVD/JPEG/jdcoefct.cpp:483:	 ! cinfo->inputctl->eoi_reached) {
.//SVD/JPEG/jdcoefct.cpp:484:    if (cinfo->input_scan_number == cinfo->output_scan_number) {
.//SVD/JPEG/jdcoefct.cpp:490:      JDIMENSION delta = (cinfo->Ss == 0) ? 1 : 0;
.//SVD/JPEG/jdcoefct.cpp:491:      if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)
.//SVD/JPEG/jdcoefct.cpp:494:    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
.//SVD/JPEG/jdcoefct.cpp:499:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdcoefct.cpp:502:    if (! compptr->component_needed)
.//SVD/JPEG/jdcoefct.cpp:504:    /* Count non-dummy DCT block rows in this iMCU row. */
.//SVD/JPEG/jdcoefct.cpp:505:    if (cinfo->output_iMCU_row < last_iMCU_row) {
.//SVD/JPEG/jdcoefct.cpp:506:      block_rows = compptr->v_samp_factor;
.//SVD/JPEG/jdcoefct.cpp:510:      /* NB: can't use last_row_height here; it is input-side-dependent! */
.//SVD/JPEG/jdcoefct.cpp:511:      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
.//SVD/JPEG/jdcoefct.cpp:512:      if (block_rows == 0) block_rows = compptr->v_samp_factor;
.//SVD/JPEG/jdcoefct.cpp:517:    if (cinfo->output_iMCU_row > 0) {
.//SVD/JPEG/jdcoefct.cpp:518:      access_rows += compptr->v_samp_factor; /* prior iMCU row too */
.//SVD/JPEG/jdcoefct.cpp:519:      buffer = (*cinfo->mem->access_virt_barray)
.//SVD/JPEG/jdcoefct.cpp:520:	((j_common_ptr) cinfo, coef->whole_image[ci],
.//SVD/JPEG/jdcoefct.cpp:521:	 (cinfo->output_iMCU_row - 1) * compptr->v_samp_factor,
.//SVD/JPEG/jdcoefct.cpp:523:      buffer += compptr->v_samp_factor;	/* point to current iMCU row */
.//SVD/JPEG/jdcoefct.cpp:526:      buffer = (*cinfo->mem->access_virt_barray)
.//SVD/JPEG/jdcoefct.cpp:527:	((j_common_ptr) cinfo, coef->whole_image[ci],
.//SVD/JPEG/jdcoefct.cpp:531:    /* Fetch component-dependent info */
.//SVD/JPEG/jdcoefct.cpp:532:    coef_bits = coef->coef_bits_latch + (ci * SAVED_COEFS);
.//SVD/JPEG/jdcoefct.cpp:533:    quanttbl = compptr->quant_table;
.//SVD/JPEG/jdcoefct.cpp:534:    Q00 = quanttbl->quantval[0];
.//SVD/JPEG/jdcoefct.cpp:535:    Q01 = quanttbl->quantval[Q01_POS];
.//SVD/JPEG/jdcoefct.cpp:536:    Q10 = quanttbl->quantval[Q10_POS];
.//SVD/JPEG/jdcoefct.cpp:537:    Q20 = quanttbl->quantval[Q20_POS];
.//SVD/JPEG/jdcoefct.cpp:538:    Q11 = quanttbl->quantval[Q11_POS];
.//SVD/JPEG/jdcoefct.cpp:539:    Q02 = quanttbl->quantval[Q02_POS];
.//SVD/JPEG/jdcoefct.cpp:540:    inverse_DCT = cinfo->idct->inverse_DCT[ci];
.//SVD/JPEG/jdcoefct.cpp:548:	prev_block_row = buffer[block_row-1];
.//SVD/JPEG/jdcoefct.cpp:549:      if (last_row && block_row == block_rows-1)
.//SVD/JPEG/jdcoefct.cpp:553:      /* We fetch the surrounding DC values using a sliding-register approach.
.//SVD/JPEG/jdcoefct.cpp:560:      last_block_column = compptr->width_in_blocks - 1;
.//SVD/JPEG/jdcoefct.cpp:576:	  num = 36 * Q00 * (DC4 - DC6);
.//SVD/JPEG/jdcoefct.cpp:580:	      pred = (1<<Al)-1;
.//SVD/JPEG/jdcoefct.cpp:582:	    pred = (int) (((Q01<<7) - num) / (Q01<<8));
.//SVD/JPEG/jdcoefct.cpp:584:	      pred = (1<<Al)-1;
.//SVD/JPEG/jdcoefct.cpp:585:	    pred = -pred;
.//SVD/JPEG/jdcoefct.cpp:591:	  num = 36 * Q00 * (DC2 - DC8);
.//SVD/JPEG/jdcoefct.cpp:595:	      pred = (1<<Al)-1;
.//SVD/JPEG/jdcoefct.cpp:597:	    pred = (int) (((Q10<<7) - num) / (Q10<<8));
.//SVD/JPEG/jdcoefct.cpp:599:	      pred = (1<<Al)-1;
.//SVD/JPEG/jdcoefct.cpp:600:	    pred = -pred;
.//SVD/JPEG/jdcoefct.cpp:606:	  num = 9 * Q00 * (DC2 + DC8 - 2*DC5);
.//SVD/JPEG/jdcoefct.cpp:610:	      pred = (1<<Al)-1;
.//SVD/JPEG/jdcoefct.cpp:612:	    pred = (int) (((Q20<<7) - num) / (Q20<<8));
.//SVD/JPEG/jdcoefct.cpp:614:	      pred = (1<<Al)-1;
.//SVD/JPEG/jdcoefct.cpp:615:	    pred = -pred;
.//SVD/JPEG/jdcoefct.cpp:621:	  num = 5 * Q00 * (DC1 - DC3 - DC7 + DC9);
.//SVD/JPEG/jdcoefct.cpp:625:	      pred = (1<<Al)-1;
.//SVD/JPEG/jdcoefct.cpp:627:	    pred = (int) (((Q11<<7) - num) / (Q11<<8));
.//SVD/JPEG/jdcoefct.cpp:629:	      pred = (1<<Al)-1;
.//SVD/JPEG/jdcoefct.cpp:630:	    pred = -pred;
.//SVD/JPEG/jdcoefct.cpp:636:	  num = 9 * Q00 * (DC4 + DC6 - 2*DC5);
.//SVD/JPEG/jdcoefct.cpp:640:	      pred = (1<<Al)-1;
.//SVD/JPEG/jdcoefct.cpp:642:	    pred = (int) (((Q02<<7) - num) / (Q02<<8));
.//SVD/JPEG/jdcoefct.cpp:644:	      pred = (1<<Al)-1;
.//SVD/JPEG/jdcoefct.cpp:645:	    pred = -pred;
.//SVD/JPEG/jdcoefct.cpp:657:	output_col += compptr->DCT_scaled_size;
.//SVD/JPEG/jdcoefct.cpp:659:      output_ptr += compptr->DCT_scaled_size;
.//SVD/JPEG/jdcoefct.cpp:663:  if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
.//SVD/JPEG/jdcoefct.cpp:681:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdcoefct.cpp:683:  cinfo->coef = (struct jpeg_d_coef_controller *) coef;
.//SVD/JPEG/jdcoefct.cpp:684:  coef->pub.start_input_pass = start_input_pass;
.//SVD/JPEG/jdcoefct.cpp:685:  coef->pub.start_output_pass = start_output_pass;
.//SVD/JPEG/jdcoefct.cpp:687:  coef->coef_bits_latch = NULL;
.//SVD/JPEG/jdcoefct.cpp:693:    /* Allocate a full-image virtual array for each component, */
.//SVD/JPEG/jdcoefct.cpp:695:    /* Note we ask for a pre-zeroed array. */
.//SVD/JPEG/jdcoefct.cpp:699:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdcoefct.cpp:701:      access_rows = compptr->v_samp_factor;
.//SVD/JPEG/jdcoefct.cpp:704:      if (cinfo->progressive_mode)
.//SVD/JPEG/jdcoefct.cpp:707:      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
.//SVD/JPEG/jdcoefct.cpp:709:	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
.//SVD/JPEG/jdcoefct.cpp:710:				(long) compptr->h_samp_factor),
.//SVD/JPEG/jdcoefct.cpp:711:	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
.//SVD/JPEG/jdcoefct.cpp:712:				(long) compptr->v_samp_factor),
.//SVD/JPEG/jdcoefct.cpp:715:    coef->pub.consume_data = consume_data;
.//SVD/JPEG/jdcoefct.cpp:716:    coef->pub.decompress_data = decompress_data;
.//SVD/JPEG/jdcoefct.cpp:717:    coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
.//SVD/JPEG/jdcoefct.cpp:722:    /* We only need a single-MCU buffer. */
.//SVD/JPEG/jdcoefct.cpp:727:      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdcoefct.cpp:730:      coef->MCU_buffer[i] = buffer + i;
.//SVD/JPEG/jdcoefct.cpp:732:    coef->pub.consume_data = dummy_consume_data;
.//SVD/JPEG/jdcoefct.cpp:733:    coef->pub.decompress_data = decompress_onepass;
.//SVD/JPEG/jdcoefct.cpp:734:    coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
.//SVD/JPEG/jdcolor.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jdcolor.cpp:21:  /* Private state for YCC->RGB conversion */
.//SVD/JPEG/jdcolor.cpp:31:/**************** YCbCr -> RGB conversion: most common case **************/
.//SVD/JPEG/jdcolor.cpp:34: * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
.//SVD/JPEG/jdcolor.cpp:35: * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
.//SVD/JPEG/jdcolor.cpp:38: *	G = Y - 0.34414 * Cb - 0.71414 * Cr
.//SVD/JPEG/jdcolor.cpp:41: * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
.//SVD/JPEG/jdcolor.cpp:43: * To avoid floating-point arithmetic, we represent the fractional constants
.//SVD/JPEG/jdcolor.cpp:51: * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
.//SVD/JPEG/jdcolor.cpp:52: * for 12-bit samples it is still acceptable.  It's not very reasonable for
.//SVD/JPEG/jdcolor.cpp:53: * 16-bit samples, but if you want lossless storage you shouldn't be changing
.//SVD/JPEG/jdcolor.cpp:60:#define SCALEBITS	16	/* speediest right-shift on some machines */
.//SVD/JPEG/jdcolor.cpp:61:#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
.//SVD/JPEG/jdcolor.cpp:66: * Initialize tables for YCC->RGB colorspace conversion.
.//SVD/JPEG/jdcolor.cpp:72:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//SVD/JPEG/jdcolor.cpp:77:  cconvert->Cr_r_tab = (int *)
.//SVD/JPEG/jdcolor.cpp:78:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdcolor.cpp:80:  cconvert->Cb_b_tab = (int *)
.//SVD/JPEG/jdcolor.cpp:81:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdcolor.cpp:83:  cconvert->Cr_g_tab = (INT32 *)
.//SVD/JPEG/jdcolor.cpp:84:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdcolor.cpp:86:  cconvert->Cb_g_tab = (INT32 *)
.//SVD/JPEG/jdcolor.cpp:87:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdcolor.cpp:90:  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
.//SVD/JPEG/jdcolor.cpp:92:    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
.//SVD/JPEG/jdcolor.cpp:94:    cconvert->Cr_r_tab[i] = (int)
.//SVD/JPEG/jdcolor.cpp:97:    cconvert->Cb_b_tab[i] = (int)
.//SVD/JPEG/jdcolor.cpp:99:    /* Cr=>G value is scaled-up -0.71414 * x */
.//SVD/JPEG/jdcolor.cpp:100:    cconvert->Cr_g_tab[i] = (- FIX(0.71414)) * x;
.//SVD/JPEG/jdcolor.cpp:101:    /* Cb=>G value is scaled-up -0.34414 * x */
.//SVD/JPEG/jdcolor.cpp:103:    cconvert->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
.//SVD/JPEG/jdcolor.cpp:111: * Note that we change from noninterleaved, one-plane-per-component format
.//SVD/JPEG/jdcolor.cpp:112: * to interleaved-pixel format.  The output buffer is therefore three times
.//SVD/JPEG/jdcolor.cpp:124:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//SVD/JPEG/jdcolor.cpp:129:  JDIMENSION num_cols = cinfo->output_width;
.//SVD/JPEG/jdcolor.cpp:131:  register JSAMPLE * range_limit = cinfo->sample_range_limit;
.//SVD/JPEG/jdcolor.cpp:132:  register int * Crrtab = cconvert->Cr_r_tab;
.//SVD/JPEG/jdcolor.cpp:133:  register int * Cbbtab = cconvert->Cb_b_tab;
.//SVD/JPEG/jdcolor.cpp:134:  register INT32 * Crgtab = cconvert->Cr_g_tab;
.//SVD/JPEG/jdcolor.cpp:135:  register INT32 * Cbgtab = cconvert->Cb_g_tab;
.//SVD/JPEG/jdcolor.cpp:138:  while (--num_rows >= 0) {
.//SVD/JPEG/jdcolor.cpp:148:      /* Range-limiting is essential due to noise introduced by DCT losses. */
.//SVD/JPEG/jdcolor.cpp:160:/**************** Cases other than YCbCr -> RGB **************/
.//SVD/JPEG/jdcolor.cpp:165: * converting from separate-planes to interleaved representation.
.//SVD/JPEG/jdcolor.cpp:175:  register int num_components = cinfo->num_components;
.//SVD/JPEG/jdcolor.cpp:176:  JDIMENSION num_cols = cinfo->output_width;
.//SVD/JPEG/jdcolor.cpp:179:  while (--num_rows >= 0) {
.//SVD/JPEG/jdcolor.cpp:183:      for (count = num_cols; count > 0; count--) {
.//SVD/JPEG/jdcolor.cpp:196: * This also works for YCbCr -> grayscale conversion, in which
.//SVD/JPEG/jdcolor.cpp:206:		    num_rows, cinfo->output_width);
.//SVD/JPEG/jdcolor.cpp:223:  JDIMENSION num_cols = cinfo->output_width;
.//SVD/JPEG/jdcolor.cpp:225:  while (--num_rows >= 0) {
.//SVD/JPEG/jdcolor.cpp:238: * Adobe-style YCCK->CMYK conversion.
.//SVD/JPEG/jdcolor.cpp:239: * We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
.//SVD/JPEG/jdcolor.cpp:249:  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
.//SVD/JPEG/jdcolor.cpp:254:  JDIMENSION num_cols = cinfo->output_width;
.//SVD/JPEG/jdcolor.cpp:256:  register JSAMPLE * range_limit = cinfo->sample_range_limit;
.//SVD/JPEG/jdcolor.cpp:257:  register int * Crrtab = cconvert->Cr_r_tab;
.//SVD/JPEG/jdcolor.cpp:258:  register int * Cbbtab = cconvert->Cb_b_tab;
.//SVD/JPEG/jdcolor.cpp:259:  register INT32 * Crgtab = cconvert->Cr_g_tab;
.//SVD/JPEG/jdcolor.cpp:260:  register INT32 * Cbgtab = cconvert->Cb_g_tab;
.//SVD/JPEG/jdcolor.cpp:263:  while (--num_rows >= 0) {
.//SVD/JPEG/jdcolor.cpp:274:      /* Range-limiting is essential due to noise introduced by DCT losses. */
.//SVD/JPEG/jdcolor.cpp:275:      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
.//SVD/JPEG/jdcolor.cpp:276:      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
.//SVD/JPEG/jdcolor.cpp:279:      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];	/* blue */
.//SVD/JPEG/jdcolor.cpp:310:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdcolor.cpp:312:  cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
.//SVD/JPEG/jdcolor.cpp:313:  cconvert->pub.start_pass = start_pass_dcolor;
.//SVD/JPEG/jdcolor.cpp:316:  switch (cinfo->jpeg_color_space) {
.//SVD/JPEG/jdcolor.cpp:318:    if (cinfo->num_components != 1)
.//SVD/JPEG/jdcolor.cpp:324:    if (cinfo->num_components != 3)
.//SVD/JPEG/jdcolor.cpp:330:    if (cinfo->num_components != 4)
.//SVD/JPEG/jdcolor.cpp:335:    if (cinfo->num_components < 1)
.//SVD/JPEG/jdcolor.cpp:345:  switch (cinfo->out_color_space) {
.//SVD/JPEG/jdcolor.cpp:347:    cinfo->out_color_components = 1;
.//SVD/JPEG/jdcolor.cpp:348:    if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
.//SVD/JPEG/jdcolor.cpp:349:	cinfo->jpeg_color_space == JCS_YCbCr) {
.//SVD/JPEG/jdcolor.cpp:350:      cconvert->pub.color_convert = grayscale_convert;
.//SVD/JPEG/jdcolor.cpp:351:      /* For color->grayscale conversion, only the Y (0) component is needed */
.//SVD/JPEG/jdcolor.cpp:352:      for (ci = 1; ci < cinfo->num_components; ci++)
.//SVD/JPEG/jdcolor.cpp:353:	cinfo->comp_info[ci].component_needed = FALSE;
.//SVD/JPEG/jdcolor.cpp:359:    cinfo->out_color_components = RGB_PIXELSIZE;
.//SVD/JPEG/jdcolor.cpp:360:    if (cinfo->jpeg_color_space == JCS_YCbCr) {
.//SVD/JPEG/jdcolor.cpp:361:      cconvert->pub.color_convert = ycc_rgb_convert;
.//SVD/JPEG/jdcolor.cpp:363:    } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {
.//SVD/JPEG/jdcolor.cpp:364:      cconvert->pub.color_convert = gray_rgb_convert;
.//SVD/JPEG/jdcolor.cpp:365:    } else if (cinfo->jpeg_color_space == JCS_RGB && RGB_PIXELSIZE == 3) {
.//SVD/JPEG/jdcolor.cpp:366:      cconvert->pub.color_convert = null_convert;
.//SVD/JPEG/jdcolor.cpp:372:    cinfo->out_color_components = 4;
.//SVD/JPEG/jdcolor.cpp:373:    if (cinfo->jpeg_color_space == JCS_YCCK) {
.//SVD/JPEG/jdcolor.cpp:374:      cconvert->pub.color_convert = ycck_cmyk_convert;
.//SVD/JPEG/jdcolor.cpp:376:    } else if (cinfo->jpeg_color_space == JCS_CMYK) {
.//SVD/JPEG/jdcolor.cpp:377:      cconvert->pub.color_convert = null_convert;
.//SVD/JPEG/jdcolor.cpp:384:    if (cinfo->out_color_space == cinfo->jpeg_color_space) {
.//SVD/JPEG/jdcolor.cpp:385:      cinfo->out_color_components = cinfo->num_components;
.//SVD/JPEG/jdcolor.cpp:386:      cconvert->pub.color_convert = null_convert;
.//SVD/JPEG/jdcolor.cpp:387:    } else			/* unsupported non-null conversion */
.//SVD/JPEG/jdcolor.cpp:392:  if (cinfo->quantize_colors)
.//SVD/JPEG/jdcolor.cpp:393:    cinfo->output_components = 1; /* single colormapped output component */
.//SVD/JPEG/jdcolor.cpp:395:    cinfo->output_components = cinfo->out_color_components;
.//SVD/JPEG/jdct.h:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jdct.h:12: * machine-dependent tuning (e.g., assembly coding).
.//SVD/JPEG/jdct.h:18: * the DCT is to be performed in-place in that buffer.  Type DCTELEM is int
.//SVD/JPEG/jdct.h:19: * for 8-bit samples, INT32 for 12-bit samples.  (NOTE: Floating-point DCT
.//SVD/JPEG/jdct.h:21: * The DCT inputs are expected to be signed (range +-CENTERJSAMPLE).
.//SVD/JPEG/jdct.h:23: * have a range of +-8K for 8-bit data, +-128K for 12-bit data.  This
.//SVD/JPEG/jdct.h:25: * work in floating-point ones.
.//SVD/JPEG/jdct.h:43: * pointed to by compptr->dct_table.  The output data is to be placed into the
.//SVD/JPEG/jdct.h:68: * Each IDCT routine is responsible for range-limiting its results and
.//SVD/JPEG/jdct.h:71: * range-limiting step is required.  We use a mask-and-table-lookup method
.//SVD/JPEG/jdct.h:76:#define IDCT_range_limit(cinfo)  ((cinfo)->sample_range_limit + CENTERJSAMPLE)
.//SVD/JPEG/jdct.h:81:/* Short forms of external names for systems with brain-damaged linkers. */
.//SVD/JPEG/jdct.h:122: * Macros for handling fixed-point arithmetic; these are used by many
.//SVD/JPEG/jdct.h:136: * thus causing a lot of useless floating-point operations at run time.
.//SVD/JPEG/jdct.h:146:#define DESCALE(x,n)  RIGHT_SHIFT((x) + (ONE << ((n)-1)), n)
.//SVD/JPEG/jdct.h:150: * 16 bits wide, so that a 16x16->32 bit multiply can be used instead of a
.//SVD/JPEG/jdct.h:152: * Unfortunately there is no way to specify a 16x16->32 multiply portably
.//SVD/JPEG/jddctmgr.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jddctmgr.cpp:8: * This file contains the inverse-DCT management logic.
.//SVD/JPEG/jddctmgr.cpp:28: * decode files that reuse Q-table slots.)
.//SVD/JPEG/jddctmgr.cpp:29: * When we are ready to make an output pass, the saved Q-table is converted
.//SVD/JPEG/jddctmgr.cpp:31: * The multiplier table contents are IDCT-method-dependent.  To support
.//SVD/JPEG/jddctmgr.cpp:34: * In buffered-image mode, the first output pass may occur before any data
.//SVD/JPEG/jddctmgr.cpp:35: * has been seen for some components, and thus before their Q-tables have
.//SVD/JPEG/jddctmgr.cpp:47:   * is currently set up for, or -1 if it's not yet set up.
.//SVD/JPEG/jddctmgr.cpp:49:   * per-component comp_info structures.
.//SVD/JPEG/jddctmgr.cpp:70:/* The current scaled-IDCT routines require ISLOW-style multiplier tables,
.//SVD/JPEG/jddctmgr.cpp:91:  my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
.//SVD/JPEG/jddctmgr.cpp:98:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jddctmgr.cpp:101:    switch (compptr->DCT_scaled_size) {
.//SVD/JPEG/jddctmgr.cpp:105:      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
.//SVD/JPEG/jddctmgr.cpp:109:      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
.//SVD/JPEG/jddctmgr.cpp:113:      method = JDCT_ISLOW;	/* jidctred uses islow-style table */
.//SVD/JPEG/jddctmgr.cpp:117:      switch (cinfo->dct_method) {
.//SVD/JPEG/jddctmgr.cpp:142:      ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->DCT_scaled_size);
.//SVD/JPEG/jddctmgr.cpp:145:    idct->pub.inverse_DCT[ci] = method_ptr;
.//SVD/JPEG/jddctmgr.cpp:150:     * multiplier table all-zero; we'll be reading zeroes from the
.//SVD/JPEG/jddctmgr.cpp:153:    if (! compptr->component_needed || idct->cur_method[ci] == method)
.//SVD/JPEG/jddctmgr.cpp:155:    qtbl = compptr->quant_table;
.//SVD/JPEG/jddctmgr.cpp:158:    idct->cur_method[ci] = method;
.//SVD/JPEG/jddctmgr.cpp:166:	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
.//SVD/JPEG/jddctmgr.cpp:168:	  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];
.//SVD/JPEG/jddctmgr.cpp:183:	IFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;
.//SVD/JPEG/jddctmgr.cpp:200:	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
.//SVD/JPEG/jddctmgr.cpp:202:		    CONST_BITS-IFAST_SCALE_BITS);
.//SVD/JPEG/jddctmgr.cpp:215:	FLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;
.//SVD/JPEG/jddctmgr.cpp:226:	      ((double) qtbl->quantval[i] *
.//SVD/JPEG/jddctmgr.cpp:254:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jddctmgr.cpp:256:  cinfo->idct = (struct jpeg_inverse_dct *) idct;
.//SVD/JPEG/jddctmgr.cpp:257:  idct->pub.start_pass = start_pass;
.//SVD/JPEG/jddctmgr.cpp:259:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jddctmgr.cpp:261:    /* Allocate and pre-zero a multiplier table for each component */
.//SVD/JPEG/jddctmgr.cpp:262:    compptr->dct_table =
.//SVD/JPEG/jddctmgr.cpp:263:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jddctmgr.cpp:265:    MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
.//SVD/JPEG/jddctmgr.cpp:267:    idct->cur_method[ci] = -1;
.//SVD/JPEG/jdhuff.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jdhuff.cpp:82: * Initialize for a Huffman-compressed scan.
.//SVD/JPEG/jdhuff.cpp:88:  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jdhuff.cpp:96:  if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
.//SVD/JPEG/jdhuff.cpp:97:      cinfo->Ah != 0 || cinfo->Al != 0)
.//SVD/JPEG/jdhuff.cpp:100:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jdhuff.cpp:101:    compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jdhuff.cpp:102:    dctbl = compptr->dc_tbl_no;
.//SVD/JPEG/jdhuff.cpp:103:    actbl = compptr->ac_tbl_no;
.//SVD/JPEG/jdhuff.cpp:107:			    & entropy->dc_derived_tbls[dctbl]);
.//SVD/JPEG/jdhuff.cpp:109:			    & entropy->ac_derived_tbls[actbl]);
.//SVD/JPEG/jdhuff.cpp:111:    entropy->saved.last_dc_val[ci] = 0;
.//SVD/JPEG/jdhuff.cpp:115:  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//SVD/JPEG/jdhuff.cpp:116:    ci = cinfo->MCU_membership[blkn];
.//SVD/JPEG/jdhuff.cpp:117:    compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jdhuff.cpp:119:    entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
.//SVD/JPEG/jdhuff.cpp:120:    entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
.//SVD/JPEG/jdhuff.cpp:122:    if (compptr->component_needed) {
.//SVD/JPEG/jdhuff.cpp:123:      entropy->dc_needed[blkn] = TRUE;
.//SVD/JPEG/jdhuff.cpp:124:      /* we don't need the ACs if producing a 1/8th-size image */
.//SVD/JPEG/jdhuff.cpp:125:      entropy->ac_needed[blkn] = (compptr->DCT_scaled_size > 1);
.//SVD/JPEG/jdhuff.cpp:127:      entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
.//SVD/JPEG/jdhuff.cpp:132:  entropy->bitstate.bits_left = 0;
.//SVD/JPEG/jdhuff.cpp:133:  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
.//SVD/JPEG/jdhuff.cpp:134:  entropy->pub.insufficient_data = FALSE;
.//SVD/JPEG/jdhuff.cpp:137:  entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jdhuff.cpp:160:  /* Note that huffsize[] and huffcode[] are filled in code-length order,
.//SVD/JPEG/jdhuff.cpp:161:   * paralleling the order of the symbols themselves in htbl->huffval[].
.//SVD/JPEG/jdhuff.cpp:168:    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
.//SVD/JPEG/jdhuff.cpp:175:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdhuff.cpp:178:  dtbl->pub = htbl;		/* fill in back link */
.//SVD/JPEG/jdhuff.cpp:184:    i = (int) htbl->bits[l];
.//SVD/JPEG/jdhuff.cpp:187:    while (i--)
.//SVD/JPEG/jdhuff.cpp:213:  /* Figure F.15: generate decoding tables for bit-sequential decoding */
.//SVD/JPEG/jdhuff.cpp:217:    if (htbl->bits[l]) {
.//SVD/JPEG/jdhuff.cpp:221:      dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
.//SVD/JPEG/jdhuff.cpp:222:      p += htbl->bits[l];
.//SVD/JPEG/jdhuff.cpp:223:      dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
.//SVD/JPEG/jdhuff.cpp:225:      dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
.//SVD/JPEG/jdhuff.cpp:228:  dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
.//SVD/JPEG/jdhuff.cpp:237:  MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
.//SVD/JPEG/jdhuff.cpp:241:    for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
.//SVD/JPEG/jdhuff.cpp:243:      /* Generate left-justified code followed by all possible bit sequences */
.//SVD/JPEG/jdhuff.cpp:244:      lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
.//SVD/JPEG/jdhuff.cpp:245:      for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
.//SVD/JPEG/jdhuff.cpp:246:	dtbl->look_nbits[lookbits] = l;
.//SVD/JPEG/jdhuff.cpp:247:	dtbl->look_sym[lookbits] = htbl->huffval[p];
.//SVD/JPEG/jdhuff.cpp:261:      int sym = htbl->huffval[i];
.//SVD/JPEG/jdhuff.cpp:270: * Out-of-line code for bit fetching (shared with jdphuff.c).
.//SVD/JPEG/jdhuff.cpp:275: * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width
.//SVD/JPEG/jdhuff.cpp:277: * buffer could be used.)  However, on some machines 32-bit shifts are
.//SVD/JPEG/jdhuff.cpp:287:#define MIN_GET_BITS  (BIT_BUF_SIZE-7)
.//SVD/JPEG/jdhuff.cpp:298:  register const JOCTET * next_input_byte = state->next_input_byte;
.//SVD/JPEG/jdhuff.cpp:299:  register size_t bytes_in_buffer = state->bytes_in_buffer;
.//SVD/JPEG/jdhuff.cpp:300:  j_decompress_ptr cinfo = state->cinfo;
.//SVD/JPEG/jdhuff.cpp:306:  if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
.//SVD/JPEG/jdhuff.cpp:312:	if (! (*cinfo->src->fill_input_buffer) (cinfo))
.//SVD/JPEG/jdhuff.cpp:314:	next_input_byte = cinfo->src->next_input_byte;
.//SVD/JPEG/jdhuff.cpp:315:	bytes_in_buffer = cinfo->src->bytes_in_buffer;
.//SVD/JPEG/jdhuff.cpp:317:      bytes_in_buffer--;
.//SVD/JPEG/jdhuff.cpp:329:	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
.//SVD/JPEG/jdhuff.cpp:331:	    next_input_byte = cinfo->src->next_input_byte;
.//SVD/JPEG/jdhuff.cpp:332:	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
.//SVD/JPEG/jdhuff.cpp:334:	  bytes_in_buffer--;
.//SVD/JPEG/jdhuff.cpp:350:	  cinfo->unread_marker = c;
.//SVD/JPEG/jdhuff.cpp:367:      /* Uh-oh.  Report corrupted data to user and stuff zeroes into
.//SVD/JPEG/jdhuff.cpp:372:      if (! cinfo->entropy->insufficient_data) {
.//SVD/JPEG/jdhuff.cpp:374:	cinfo->entropy->insufficient_data = TRUE;
.//SVD/JPEG/jdhuff.cpp:377:      get_buffer <<= MIN_GET_BITS - bits_left;
.//SVD/JPEG/jdhuff.cpp:383:  state->next_input_byte = next_input_byte;
.//SVD/JPEG/jdhuff.cpp:384:  state->bytes_in_buffer = bytes_in_buffer;
.//SVD/JPEG/jdhuff.cpp:385:  state->get_buffer = get_buffer;
.//SVD/JPEG/jdhuff.cpp:386:  state->bits_left = bits_left;
.//SVD/JPEG/jdhuff.cpp:393: * Out-of-line code for Huffman code decoding.
.//SVD/JPEG/jdhuff.cpp:408:  CHECK_BIT_BUFFER(*state, l, return -1);
.//SVD/JPEG/jdhuff.cpp:414:  while (code > htbl->maxcode[l]) {
.//SVD/JPEG/jdhuff.cpp:416:    CHECK_BIT_BUFFER(*state, 1, return -1);
.//SVD/JPEG/jdhuff.cpp:422:  state->get_buffer = get_buffer;
.//SVD/JPEG/jdhuff.cpp:423:  state->bits_left = bits_left;
.//SVD/JPEG/jdhuff.cpp:428:    WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
.//SVD/JPEG/jdhuff.cpp:432:  return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
.//SVD/JPEG/jdhuff.cpp:443:#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))
.//SVD/JPEG/jdhuff.cpp:449:static const int extend_test[16] =   /* entry n is 2**(n-1) */
.//SVD/JPEG/jdhuff.cpp:453:static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
.//SVD/JPEG/jdhuff.cpp:454:  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
.//SVD/JPEG/jdhuff.cpp:455:    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
.//SVD/JPEG/jdhuff.cpp:456:    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
.//SVD/JPEG/jdhuff.cpp:457:    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };
.//SVD/JPEG/jdhuff.cpp:470:  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jdhuff.cpp:475:  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
.//SVD/JPEG/jdhuff.cpp:476:  entropy->bitstate.bits_left = 0;
.//SVD/JPEG/jdhuff.cpp:479:  if (! (*cinfo->marker->read_restart_marker) (cinfo))
.//SVD/JPEG/jdhuff.cpp:482:  /* Re-initialize DC predictions to 0 */
.//SVD/JPEG/jdhuff.cpp:483:  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
.//SVD/JPEG/jdhuff.cpp:484:    entropy->saved.last_dc_val[ci] = 0;
.//SVD/JPEG/jdhuff.cpp:487:  entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jdhuff.cpp:489:  /* Reset out-of-data flag, unless read_restart_marker left us smack up
.//SVD/JPEG/jdhuff.cpp:494:  if (cinfo->unread_marker == 0)
.//SVD/JPEG/jdhuff.cpp:495:    entropy->pub.insufficient_data = FALSE;
.//SVD/JPEG/jdhuff.cpp:502: * Decode and return one MCU's worth of Huffman-compressed coefficients.
.//SVD/JPEG/jdhuff.cpp:513: * this module, since we'll just re-assign them on the next call.)
.//SVD/JPEG/jdhuff.cpp:519:  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jdhuff.cpp:525:  if (cinfo->restart_interval) {
.//SVD/JPEG/jdhuff.cpp:526:    if (entropy->restarts_to_go == 0)
.//SVD/JPEG/jdhuff.cpp:534:  if (! entropy->pub.insufficient_data) {
.//SVD/JPEG/jdhuff.cpp:537:    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
.//SVD/JPEG/jdhuff.cpp:538:    ASSIGN_STATE(state, entropy->saved);
.//SVD/JPEG/jdhuff.cpp:542:    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//SVD/JPEG/jdhuff.cpp:544:      d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
.//SVD/JPEG/jdhuff.cpp:545:      d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
.//SVD/JPEG/jdhuff.cpp:558:      if (entropy->dc_needed[blkn]) {
.//SVD/JPEG/jdhuff.cpp:560:	int ci = cinfo->MCU_membership[blkn];
.//SVD/JPEG/jdhuff.cpp:567:      if (entropy->ac_needed[blkn]) {
.//SVD/JPEG/jdhuff.cpp:619:    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
.//SVD/JPEG/jdhuff.cpp:620:    ASSIGN_STATE(entropy->saved, state);
.//SVD/JPEG/jdhuff.cpp:623:  /* Account for restart interval (no-op if not using restarts) */
.//SVD/JPEG/jdhuff.cpp:624:  entropy->restarts_to_go--;
.//SVD/JPEG/jdhuff.cpp:641:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdhuff.cpp:643:  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
.//SVD/JPEG/jdhuff.cpp:644:  entropy->pub.start_pass = start_pass_huff_decoder;
.//SVD/JPEG/jdhuff.cpp:645:  entropy->pub.decode_mcu = decode_mcu;
.//SVD/JPEG/jdhuff.cpp:649:    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
.//SVD/JPEG/jdhuff.h:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jdhuff.h:13:/* Short forms of external names for systems with brain-damaged linkers. */
.//SVD/JPEG/jdhuff.h:28:  INT32 maxcode[18];		/* largest code of length k (-1 if none) */
.//SVD/JPEG/jdhuff.h:55: * Fetching the next N bits from the input stream is a time-critical operation
.//SVD/JPEG/jdhuff.h:57: * macros and out-of-line subroutines.  Note that N (the number of bits
.//SVD/JPEG/jdhuff.h:61: * If get_buffer already contains enough bits, they are fetched in-line
.//SVD/JPEG/jdhuff.h:68: * at least the requested number of bits --- dummy zeroes are inserted if
.//SVD/JPEG/jdhuff.h:72:typedef INT32 bit_buf_type;	/* type of bit-extraction buffer */
.//SVD/JPEG/jdhuff.h:79: * because not all machines measure sizeof in 8-bit bytes.
.//SVD/JPEG/jdhuff.h:83:  bit_buf_type get_buffer;	/* current bit-extraction buffer */
.//SVD/JPEG/jdhuff.h:92:  /* Bit input buffer --- note these values are kept in register variables,
.//SVD/JPEG/jdhuff.h:95:  bit_buf_type get_buffer;	/* current bit-extraction buffer */
.//SVD/JPEG/jdhuff.h:109:	br_state.next_input_byte = cinfop->src->next_input_byte; \
.//SVD/JPEG/jdhuff.h:110:	br_state.bytes_in_buffer = cinfop->src->bytes_in_buffer; \
.//SVD/JPEG/jdhuff.h:115:	cinfop->src->next_input_byte = br_state.next_input_byte; \
.//SVD/JPEG/jdhuff.h:116:	cinfop->src->bytes_in_buffer = br_state.bytes_in_buffer; \
.//SVD/JPEG/jdhuff.h:121: * These macros provide the in-line portion of bit fetching.
.//SVD/JPEG/jdhuff.h:145:	(((int) (get_buffer >> (bits_left -= (nbits)))) & ((1<<(nbits))-1))
.//SVD/JPEG/jdhuff.h:148:	(((int) (get_buffer >> (bits_left -  (nbits)))) & ((1<<(nbits))-1))
.//SVD/JPEG/jdhuff.h:151:	(bits_left -= (nbits))
.//SVD/JPEG/jdhuff.h:160: * Code for extracting next Huffman-coded symbol from input bit stream.
.//SVD/JPEG/jdhuff.h:161: * Again, this is time-critical and we make the main paths be macros.
.//SVD/JPEG/jdhuff.h:173: * 3. jpeg_huff_decode returns -1 if forced to suspend.
.//SVD/JPEG/jdhuff.h:186:  if ((nb = htbl->look_nbits[look]) != 0) { \
.//SVD/JPEG/jdhuff.h:188:    result = htbl->look_sym[look]; \
.//SVD/JPEG/jdhuff.h:198:/* Out-of-line case for Huffman code fetching */
.//SVD/JPEG/jdinput.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jdinput.cpp:46:  if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
.//SVD/JPEG/jdinput.cpp:47:      (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
.//SVD/JPEG/jdinput.cpp:50:  /* For now, precision must match compiled-in value... */
.//SVD/JPEG/jdinput.cpp:51:  if (cinfo->data_precision != BITS_IN_JSAMPLE)
.//SVD/JPEG/jdinput.cpp:52:    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
.//SVD/JPEG/jdinput.cpp:55:  if (cinfo->num_components > MAX_COMPONENTS)
.//SVD/JPEG/jdinput.cpp:56:    ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
.//SVD/JPEG/jdinput.cpp:60:  cinfo->max_h_samp_factor = 1;
.//SVD/JPEG/jdinput.cpp:61:  cinfo->max_v_samp_factor = 1;
.//SVD/JPEG/jdinput.cpp:62:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdinput.cpp:64:    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
.//SVD/JPEG/jdinput.cpp:65:	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
.//SVD/JPEG/jdinput.cpp:67:    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
.//SVD/JPEG/jdinput.cpp:68:				   compptr->h_samp_factor);
.//SVD/JPEG/jdinput.cpp:69:    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
.//SVD/JPEG/jdinput.cpp:70:				   compptr->v_samp_factor);
.//SVD/JPEG/jdinput.cpp:77:  cinfo->min_DCT_scaled_size = DCTSIZE;
.//SVD/JPEG/jdinput.cpp:80:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdinput.cpp:82:    compptr->DCT_scaled_size = DCTSIZE;
.//SVD/JPEG/jdinput.cpp:84:    compptr->width_in_blocks = (JDIMENSION)
.//SVD/JPEG/jdinput.cpp:85:      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
.//SVD/JPEG/jdinput.cpp:86:		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
.//SVD/JPEG/jdinput.cpp:87:    compptr->height_in_blocks = (JDIMENSION)
.//SVD/JPEG/jdinput.cpp:88:      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
.//SVD/JPEG/jdinput.cpp:89:		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
.//SVD/JPEG/jdinput.cpp:95:    compptr->downsampled_width = (JDIMENSION)
.//SVD/JPEG/jdinput.cpp:96:      jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
.//SVD/JPEG/jdinput.cpp:97:		    (long) cinfo->max_h_samp_factor);
.//SVD/JPEG/jdinput.cpp:98:    compptr->downsampled_height = (JDIMENSION)
.//SVD/JPEG/jdinput.cpp:99:      jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
.//SVD/JPEG/jdinput.cpp:100:		    (long) cinfo->max_v_samp_factor);
.//SVD/JPEG/jdinput.cpp:102:    compptr->component_needed = TRUE;
.//SVD/JPEG/jdinput.cpp:104:    compptr->quant_table = NULL;
.//SVD/JPEG/jdinput.cpp:108:  cinfo->total_iMCU_rows = (JDIMENSION)
.//SVD/JPEG/jdinput.cpp:109:    jdiv_round_up((long) cinfo->image_height,
.//SVD/JPEG/jdinput.cpp:110:		  (long) (cinfo->max_v_samp_factor*DCTSIZE));
.//SVD/JPEG/jdinput.cpp:113:  if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
.//SVD/JPEG/jdinput.cpp:114:    cinfo->inputctl->has_multiple_scans = TRUE;
.//SVD/JPEG/jdinput.cpp:116:    cinfo->inputctl->has_multiple_scans = FALSE;
.//SVD/JPEG/jdinput.cpp:123:/* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
.//SVD/JPEG/jdinput.cpp:128:  if (cinfo->comps_in_scan == 1) {
.//SVD/JPEG/jdinput.cpp:130:    /* Noninterleaved (single-component) scan */
.//SVD/JPEG/jdinput.cpp:131:    compptr = cinfo->cur_comp_info[0];
.//SVD/JPEG/jdinput.cpp:134:    cinfo->MCUs_per_row = compptr->width_in_blocks;
.//SVD/JPEG/jdinput.cpp:135:    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
.//SVD/JPEG/jdinput.cpp:138:    compptr->MCU_width = 1;
.//SVD/JPEG/jdinput.cpp:139:    compptr->MCU_height = 1;
.//SVD/JPEG/jdinput.cpp:140:    compptr->MCU_blocks = 1;
.//SVD/JPEG/jdinput.cpp:141:    compptr->MCU_sample_width = compptr->DCT_scaled_size;
.//SVD/JPEG/jdinput.cpp:142:    compptr->last_col_width = 1;
.//SVD/JPEG/jdinput.cpp:146:    tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
.//SVD/JPEG/jdinput.cpp:147:    if (tmp == 0) tmp = compptr->v_samp_factor;
.//SVD/JPEG/jdinput.cpp:148:    compptr->last_row_height = tmp;
.//SVD/JPEG/jdinput.cpp:151:    cinfo->blocks_in_MCU = 1;
.//SVD/JPEG/jdinput.cpp:152:    cinfo->MCU_membership[0] = 0;
.//SVD/JPEG/jdinput.cpp:156:    /* Interleaved (multi-component) scan */
.//SVD/JPEG/jdinput.cpp:157:    if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
.//SVD/JPEG/jdinput.cpp:158:      ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
.//SVD/JPEG/jdinput.cpp:162:    cinfo->MCUs_per_row = (JDIMENSION)
.//SVD/JPEG/jdinput.cpp:163:      jdiv_round_up((long) cinfo->image_width,
.//SVD/JPEG/jdinput.cpp:164:		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
.//SVD/JPEG/jdinput.cpp:165:    cinfo->MCU_rows_in_scan = (JDIMENSION)
.//SVD/JPEG/jdinput.cpp:166:      jdiv_round_up((long) cinfo->image_height,
.//SVD/JPEG/jdinput.cpp:167:		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
.//SVD/JPEG/jdinput.cpp:169:    cinfo->blocks_in_MCU = 0;
.//SVD/JPEG/jdinput.cpp:171:    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jdinput.cpp:172:      compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jdinput.cpp:174:      compptr->MCU_width = compptr->h_samp_factor;
.//SVD/JPEG/jdinput.cpp:175:      compptr->MCU_height = compptr->v_samp_factor;
.//SVD/JPEG/jdinput.cpp:176:      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
.//SVD/JPEG/jdinput.cpp:177:      compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
.//SVD/JPEG/jdinput.cpp:178:      /* Figure number of non-dummy blocks in last MCU column & row */
.//SVD/JPEG/jdinput.cpp:179:      tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
.//SVD/JPEG/jdinput.cpp:180:      if (tmp == 0) tmp = compptr->MCU_width;
.//SVD/JPEG/jdinput.cpp:181:      compptr->last_col_width = tmp;
.//SVD/JPEG/jdinput.cpp:182:      tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
.//SVD/JPEG/jdinput.cpp:183:      if (tmp == 0) tmp = compptr->MCU_height;
.//SVD/JPEG/jdinput.cpp:184:      compptr->last_row_height = tmp;
.//SVD/JPEG/jdinput.cpp:186:      mcublks = compptr->MCU_blocks;
.//SVD/JPEG/jdinput.cpp:187:      if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
.//SVD/JPEG/jdinput.cpp:189:      while (mcublks-- > 0) {
.//SVD/JPEG/jdinput.cpp:190:	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
.//SVD/JPEG/jdinput.cpp:199: * Save away a copy of the Q-table referenced by each component present
.//SVD/JPEG/jdinput.cpp:202: * In a multiple-scan JPEG file, the encoder could assign different components
.//SVD/JPEG/jdinput.cpp:203: * the same Q-table slot number, but change table definitions between scans
.//SVD/JPEG/jdinput.cpp:204: * so that each component uses a different Q-table.  (The IJG encoder is not
.//SVD/JPEG/jdinput.cpp:210: * The JPEG spec prohibits the encoder from changing the contents of a Q-table
.//SVD/JPEG/jdinput.cpp:212: * anyway, this decoder will simply use the Q-table values that were current
.//SVD/JPEG/jdinput.cpp:216: * not at the current Q-table slots.
.//SVD/JPEG/jdinput.cpp:226:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jdinput.cpp:227:    compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jdinput.cpp:228:    /* No work if we already saved Q-table for this component */
.//SVD/JPEG/jdinput.cpp:229:    if (compptr->quant_table != NULL)
.//SVD/JPEG/jdinput.cpp:232:    qtblno = compptr->quant_tbl_no;
.//SVD/JPEG/jdinput.cpp:234:	cinfo->quant_tbl_ptrs[qtblno] == NULL)
.//SVD/JPEG/jdinput.cpp:238:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdinput.cpp:240:    MEMCOPY(qtbl, cinfo->quant_tbl_ptrs[qtblno], SIZEOF(JQUANT_TBL));
.//SVD/JPEG/jdinput.cpp:241:    compptr->quant_table = qtbl;
.//SVD/JPEG/jdinput.cpp:258:  (*cinfo->entropy->start_pass) (cinfo);
.//SVD/JPEG/jdinput.cpp:259:  (*cinfo->coef->start_input_pass) (cinfo);
.//SVD/JPEG/jdinput.cpp:260:  cinfo->inputctl->consume_input = cinfo->coef->consume_data;
.//SVD/JPEG/jdinput.cpp:265: * Finish up after inputting a compressed-data scan.
.//SVD/JPEG/jdinput.cpp:273:  cinfo->inputctl->consume_input = consume_markers;
.//SVD/JPEG/jdinput.cpp:278: * Read JPEG markers before, between, or after compressed-data scans.
.//SVD/JPEG/jdinput.cpp:284: * we are reading a compressed data segment or inter-segment markers.
.//SVD/JPEG/jdinput.cpp:290:  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
.//SVD/JPEG/jdinput.cpp:293:  if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
.//SVD/JPEG/jdinput.cpp:296:  val = (*cinfo->marker->read_markers) (cinfo);
.//SVD/JPEG/jdinput.cpp:300:    if (inputctl->inheaders) {	/* 1st SOS */
.//SVD/JPEG/jdinput.cpp:302:      inputctl->inheaders = FALSE;
.//SVD/JPEG/jdinput.cpp:308:      if (! inputctl->pub.has_multiple_scans)
.//SVD/JPEG/jdinput.cpp:314:    inputctl->pub.eoi_reached = TRUE;
.//SVD/JPEG/jdinput.cpp:315:    if (inputctl->inheaders) {	/* Tables-only datastream, apparently */
.//SVD/JPEG/jdinput.cpp:316:      if (cinfo->marker->saw_SOF)
.//SVD/JPEG/jdinput.cpp:322:      if (cinfo->output_scan_number > cinfo->input_scan_number)
.//SVD/JPEG/jdinput.cpp:323:	cinfo->output_scan_number = cinfo->input_scan_number;
.//SVD/JPEG/jdinput.cpp:341:  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
.//SVD/JPEG/jdinput.cpp:343:  inputctl->pub.consume_input = consume_markers;
.//SVD/JPEG/jdinput.cpp:344:  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
.//SVD/JPEG/jdinput.cpp:345:  inputctl->pub.eoi_reached = FALSE;
.//SVD/JPEG/jdinput.cpp:346:  inputctl->inheaders = TRUE;
.//SVD/JPEG/jdinput.cpp:348:  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
.//SVD/JPEG/jdinput.cpp:349:  (*cinfo->marker->reset_marker_reader) (cinfo);
.//SVD/JPEG/jdinput.cpp:350:  /* Reset progression state -- would be cleaner if entropy decoder did this */
.//SVD/JPEG/jdinput.cpp:351:  cinfo->coef_bits = NULL;
.//SVD/JPEG/jdinput.cpp:367:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//SVD/JPEG/jdinput.cpp:369:  cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
.//SVD/JPEG/jdinput.cpp:371:  inputctl->pub.consume_input = consume_markers;
.//SVD/JPEG/jdinput.cpp:372:  inputctl->pub.reset_input_controller = reset_input_controller;
.//SVD/JPEG/jdinput.cpp:373:  inputctl->pub.start_input_pass = start_input_pass;
.//SVD/JPEG/jdinput.cpp:374:  inputctl->pub.finish_input_pass = finish_input_pass;
.//SVD/JPEG/jdinput.cpp:378:  inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
.//SVD/JPEG/jdinput.cpp:379:  inputctl->pub.eoi_reached = FALSE;
.//SVD/JPEG/jdinput.cpp:380:  inputctl->inheaders = TRUE;
.//SVD/JPEG/jdmainct.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jdmainct.cpp:10: * post-processor; it holds downsampled data in the JPEG colorspace.
.//SVD/JPEG/jdmainct.cpp:12: * Note that this code is bypassed in raw-data mode, since the application
.//SVD/JPEG/jdmainct.cpp:22: * In the current system design, the main buffer need never be a full-image
.//SVD/JPEG/jdmainct.cpp:23: * buffer; any full-height buffers will be found inside the coefficient or
.//SVD/JPEG/jdmainct.cpp:72: * can't be processed until we have another row group for its below-context,
.//SVD/JPEG/jdmainct.cpp:73: * and so we have to save the next-to-last group too for its above-context.)
.//SVD/JPEG/jdmainct.cpp:81: *                   M+1                          M-1
.//SVD/JPEG/jdmainct.cpp:82: * master pointer --> 0         master pointer --> 0
.//SVD/JPEG/jdmainct.cpp:85: *                   M-3                          M-3
.//SVD/JPEG/jdmainct.cpp:86: *                   M-2                           M
.//SVD/JPEG/jdmainct.cpp:87: *                   M-1                          M+1
.//SVD/JPEG/jdmainct.cpp:88: *                    M                           M-2
.//SVD/JPEG/jdmainct.cpp:89: *                   M+1                          M-1
.//SVD/JPEG/jdmainct.cpp:92: * row groups of the previous iMCU row remain un-overwritten in the workspace.
.//SVD/JPEG/jdmainct.cpp:107: * be worth providing --- if someone wants a 1/8th-size preview, they probably
.//SVD/JPEG/jdmainct.cpp:108: * want it quick and dirty, so a context-free upsampler is sufficient.
.//SVD/JPEG/jdmainct.cpp:125:  /* These are the master pointers to the funny-order pointer lists. */
.//SVD/JPEG/jdmainct.cpp:162:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//SVD/JPEG/jdmainct.cpp:164:  int M = cinfo->min_DCT_scaled_size;
.//SVD/JPEG/jdmainct.cpp:168:  /* Get top-level space for component array pointers.
.//SVD/JPEG/jdmainct.cpp:171:  main->xbuffer[0] = (JSAMPIMAGE)
.//SVD/JPEG/jdmainct.cpp:172:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmainct.cpp:173:				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
.//SVD/JPEG/jdmainct.cpp:174:  main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;
.//SVD/JPEG/jdmainct.cpp:176:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdmainct.cpp:178:    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
.//SVD/JPEG/jdmainct.cpp:179:      cinfo->min_DCT_scaled_size; /* height of a row group of component */
.//SVD/JPEG/jdmainct.cpp:180:    /* Get space for pointer lists --- M+4 row groups in each list.
.//SVD/JPEG/jdmainct.cpp:184:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmainct.cpp:187:    main->xbuffer[0][ci] = xbuf;
.//SVD/JPEG/jdmainct.cpp:189:    main->xbuffer[1][ci] = xbuf;
.//SVD/JPEG/jdmainct.cpp:197: * The actual workspace is already allocated (in main->buffer),
.//SVD/JPEG/jdmainct.cpp:203:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//SVD/JPEG/jdmainct.cpp:205:  int M = cinfo->min_DCT_scaled_size;
.//SVD/JPEG/jdmainct.cpp:209:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdmainct.cpp:211:    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
.//SVD/JPEG/jdmainct.cpp:212:      cinfo->min_DCT_scaled_size; /* height of a row group of component */
.//SVD/JPEG/jdmainct.cpp:213:    xbuf0 = main->xbuffer[0][ci];
.//SVD/JPEG/jdmainct.cpp:214:    xbuf1 = main->xbuffer[1][ci];
.//SVD/JPEG/jdmainct.cpp:215:    /* First copy the workspace pointers as-is */
.//SVD/JPEG/jdmainct.cpp:216:    buf = main->buffer[ci];
.//SVD/JPEG/jdmainct.cpp:222:      xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
.//SVD/JPEG/jdmainct.cpp:223:      xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
.//SVD/JPEG/jdmainct.cpp:231:      xbuf0[i - rgroup] = xbuf0[0];
.//SVD/JPEG/jdmainct.cpp:240: * This changes the pointer list state from top-of-image to the normal state.
.//SVD/JPEG/jdmainct.cpp:243:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//SVD/JPEG/jdmainct.cpp:245:  int M = cinfo->min_DCT_scaled_size;
.//SVD/JPEG/jdmainct.cpp:249:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdmainct.cpp:251:    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
.//SVD/JPEG/jdmainct.cpp:252:      cinfo->min_DCT_scaled_size; /* height of a row group of component */
.//SVD/JPEG/jdmainct.cpp:253:    xbuf0 = main->xbuffer[0][ci];
.//SVD/JPEG/jdmainct.cpp:254:    xbuf1 = main->xbuffer[1][ci];
.//SVD/JPEG/jdmainct.cpp:256:      xbuf0[i - rgroup] = xbuf0[rgroup*(M+1) + i];
.//SVD/JPEG/jdmainct.cpp:257:      xbuf1[i - rgroup] = xbuf1[rgroup*(M+1) + i];
.//SVD/JPEG/jdmainct.cpp:272:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//SVD/JPEG/jdmainct.cpp:277:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdmainct.cpp:280:    iMCUheight = compptr->v_samp_factor * compptr->DCT_scaled_size;
.//SVD/JPEG/jdmainct.cpp:281:    rgroup = iMCUheight / cinfo->min_DCT_scaled_size;
.//SVD/JPEG/jdmainct.cpp:283:    rows_left = (int) (compptr->downsampled_height % (JDIMENSION) iMCUheight);
.//SVD/JPEG/jdmainct.cpp:289:      main->rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);
.//SVD/JPEG/jdmainct.cpp:294:    xbuf = main->xbuffer[main->whichptr][ci];
.//SVD/JPEG/jdmainct.cpp:296:      xbuf[rows_left + i] = xbuf[rows_left-1];
.//SVD/JPEG/jdmainct.cpp:309:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//SVD/JPEG/jdmainct.cpp:313:    if (cinfo->upsample->need_context_rows) {
.//SVD/JPEG/jdmainct.cpp:314:      main->pub.process_data = process_data_context_main;
.//SVD/JPEG/jdmainct.cpp:316:      main->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
.//SVD/JPEG/jdmainct.cpp:317:      main->context_state = CTX_PREPARE_FOR_IMCU;
.//SVD/JPEG/jdmainct.cpp:318:      main->iMCU_row_ctr = 0;
.//SVD/JPEG/jdmainct.cpp:321:      main->pub.process_data = process_data_simple_main;
.//SVD/JPEG/jdmainct.cpp:323:    main->buffer_full = FALSE;	/* Mark buffer empty */
.//SVD/JPEG/jdmainct.cpp:324:    main->rowgroup_ctr = 0;
.//SVD/JPEG/jdmainct.cpp:328:    /* For last pass of 2-pass quantization, just crank the postprocessor */
.//SVD/JPEG/jdmainct.cpp:329:    main->pub.process_data = process_data_crank_post;
.//SVD/JPEG/jdmainct.cpp:349:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//SVD/JPEG/jdmainct.cpp:353:  if (! main->buffer_full) {
.//SVD/JPEG/jdmainct.cpp:354:    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
.//SVD/JPEG/jdmainct.cpp:356:    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
.//SVD/JPEG/jdmainct.cpp:360:  rowgroups_avail = (JDIMENSION) cinfo->min_DCT_scaled_size;
.//SVD/JPEG/jdmainct.cpp:367:  (*cinfo->post->post_process_data) (cinfo, main->buffer,
.//SVD/JPEG/jdmainct.cpp:368:				     &main->rowgroup_ctr, rowgroups_avail,
.//SVD/JPEG/jdmainct.cpp:372:  if (main->rowgroup_ctr >= rowgroups_avail) {
.//SVD/JPEG/jdmainct.cpp:373:    main->buffer_full = FALSE;
.//SVD/JPEG/jdmainct.cpp:374:    main->rowgroup_ctr = 0;
.//SVD/JPEG/jdmainct.cpp:389:  my_main_ptr main = (my_main_ptr) cinfo->main;
.//SVD/JPEG/jdmainct.cpp:392:  if (! main->buffer_full) {
.//SVD/JPEG/jdmainct.cpp:393:    if (! (*cinfo->coef->decompress_data) (cinfo,
.//SVD/JPEG/jdmainct.cpp:394:					   main->xbuffer[main->whichptr]))
.//SVD/JPEG/jdmainct.cpp:396:    main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
.//SVD/JPEG/jdmainct.cpp:397:    main->iMCU_row_ctr++;	/* count rows received */
.//SVD/JPEG/jdmainct.cpp:405:  switch (main->context_state) {
.//SVD/JPEG/jdmainct.cpp:408:    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
.//SVD/JPEG/jdmainct.cpp:409:			&main->rowgroup_ctr, main->rowgroups_avail,
.//SVD/JPEG/jdmainct.cpp:411:    if (main->rowgroup_ctr < main->rowgroups_avail)
.//SVD/JPEG/jdmainct.cpp:413:    main->context_state = CTX_PREPARE_FOR_IMCU;
.//SVD/JPEG/jdmainct.cpp:418:    /* Prepare to process first M-1 row groups of this iMCU row */
.//SVD/JPEG/jdmainct.cpp:419:    main->rowgroup_ctr = 0;
.//SVD/JPEG/jdmainct.cpp:420:    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size - 1);
.//SVD/JPEG/jdmainct.cpp:424:    if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
.//SVD/JPEG/jdmainct.cpp:426:    main->context_state = CTX_PROCESS_IMCU;
.//SVD/JPEG/jdmainct.cpp:430:    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
.//SVD/JPEG/jdmainct.cpp:431:			&main->rowgroup_ctr, main->rowgroups_avail,
.//SVD/JPEG/jdmainct.cpp:433:    if (main->rowgroup_ctr < main->rowgroups_avail)
.//SVD/JPEG/jdmainct.cpp:436:    if (main->iMCU_row_ctr == 1)
.//SVD/JPEG/jdmainct.cpp:439:    main->whichptr ^= 1;	/* 0=>1 or 1=>0 */
.//SVD/JPEG/jdmainct.cpp:440:    main->buffer_full = FALSE;
.//SVD/JPEG/jdmainct.cpp:443:    main->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_scaled_size + 1);
.//SVD/JPEG/jdmainct.cpp:444:    main->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size + 2);
.//SVD/JPEG/jdmainct.cpp:445:    main->context_state = CTX_POSTPONED_ROW;
.//SVD/JPEG/jdmainct.cpp:452: * Final pass of two-pass quantization: just call the postprocessor.
.//SVD/JPEG/jdmainct.cpp:463:  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
.//SVD/JPEG/jdmainct.cpp:483:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmainct.cpp:485:  cinfo->main = (struct jpeg_d_main_controller *) main;
.//SVD/JPEG/jdmainct.cpp:486:  main->pub.start_pass = start_pass_main;
.//SVD/JPEG/jdmainct.cpp:494:  if (cinfo->upsample->need_context_rows) {
.//SVD/JPEG/jdmainct.cpp:495:    if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
.//SVD/JPEG/jdmainct.cpp:498:    ngroups = cinfo->min_DCT_scaled_size + 2;
.//SVD/JPEG/jdmainct.cpp:500:    ngroups = cinfo->min_DCT_scaled_size;
.//SVD/JPEG/jdmainct.cpp:503:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdmainct.cpp:505:    rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
.//SVD/JPEG/jdmainct.cpp:506:      cinfo->min_DCT_scaled_size; /* height of a row group of component */
.//SVD/JPEG/jdmainct.cpp:507:    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
.//SVD/JPEG/jdmainct.cpp:509:			 compptr->width_in_blocks * compptr->DCT_scaled_size,
.//SVD/JPEG/jdmarker.cpp:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//SVD/JPEG/jdmarker.cpp:93:  /* Application-overridable marker processing methods */
.//SVD/JPEG/jdmarker.cpp:113: * At all times, cinfo->src->next_input_byte and ->bytes_in_buffer reflect
.//SVD/JPEG/jdmarker.cpp:120:	struct jpeg_source_mgr * datasrc = (cinfo)->src;  \
.//SVD/JPEG/jdmarker.cpp:121:	const JOCTET * next_input_byte = datasrc->next_input_byte;  \
.//SVD/JPEG/jdmarker.cpp:122:	size_t bytes_in_buffer = datasrc->bytes_in_buffer
.//SVD/JPEG/jdmarker.cpp:124:/* Unload the local copies --- do this only at a restart boundary */
.//SVD/JPEG/jdmarker.cpp:126:	( datasrc->next_input_byte = next_input_byte,  \
.//SVD/JPEG/jdmarker.cpp:127:	  datasrc->bytes_in_buffer = bytes_in_buffer )
.//SVD/JPEG/jdmarker.cpp:129:/* Reload the local copies --- used only in MAKE_BYTE_AVAIL */
.//SVD/JPEG/jdmarker.cpp:131:	( next_input_byte = datasrc->next_input_byte,  \
.//SVD/JPEG/jdmarker.cpp:132:	  bytes_in_buffer = datasrc->bytes_in_buffer )
.//SVD/JPEG/jdmarker.cpp:140:	  if (! (*datasrc->fill_input_buffer) (cinfo))  \
.//SVD/JPEG/jdmarker.cpp:150:		  bytes_in_buffer--; \
.//SVD/JPEG/jdmarker.cpp:153:/* As above, but read two bytes interpreted as an unsigned 16-bit integer.
.//SVD/JPEG/jdmarker.cpp:158:		  bytes_in_buffer--; \
.//SVD/JPEG/jdmarker.cpp:161:		  bytes_in_buffer--; \
.//SVD/JPEG/jdmarker.cpp:169: *   in cinfo->unread_marker; input restart point is just after the marker.
.//SVD/JPEG/jdmarker.cpp:186: * On resumption, cinfo->unread_marker still contains the marker code,
.//SVD/JPEG/jdmarker.cpp:204:  if (cinfo->marker->saw_SOI)
.//SVD/JPEG/jdmarker.cpp:210:    cinfo->arith_dc_L[i] = 0;
.//SVD/JPEG/jdmarker.cpp:211:    cinfo->arith_dc_U[i] = 1;
.//SVD/JPEG/jdmarker.cpp:212:    cinfo->arith_ac_K[i] = 5;
.//SVD/JPEG/jdmarker.cpp:214:  cinfo->restart_interval = 0;
.//SVD/JPEG/jdmarker.cpp:218:  cinfo->jpeg_color_space = JCS_UNKNOWN;
.//SVD/JPEG/jdmarker.cpp:219:  cinfo->CCIR601_sampling = FALSE; /* Assume non-CCIR sampling??? */
.//SVD/JPEG/jdmarker.cpp:221:  cinfo->saw_JFIF_marker = FALSE;
.//SVD/JPEG/jdmarker.cpp:222:  cinfo->JFIF_major_version = 1; /* set default JFIF APP0 values */
.//SVD/JPEG/jdmarker.cpp:223:  cinfo->JFIF_minor_version = 1;
.//SVD/JPEG/jdmarker.cpp:224:  cinfo->density_unit = 0;
.//SVD/JPEG/jdmarker.cpp:225:  cinfo->X_density = 1;
.//SVD/JPEG/jdmarker.cpp:226:  cinfo->Y_density = 1;
.//SVD/JPEG/jdmarker.cpp:227:  cinfo->saw_Adobe_marker = FALSE;
.//SVD/JPEG/jdmarker.cpp:228:  cinfo->Adobe_transform = 0;
.//SVD/JPEG/jdmarker.cpp:230:  cinfo->marker->saw_SOI = TRUE;
.//SVD/JPEG/jdmarker.cpp:245:  cinfo->progressive_mode = is_prog;
.//SVD/JPEG/jdmarker.cpp:246:  cinfo->arith_code = is_arith;
.//SVD/JPEG/jdmarker.cpp:250:  INPUT_BYTE(cinfo, cinfo->data_precision, return FALSE);
.//SVD/JPEG/jdmarker.cpp:251:  INPUT_2BYTES(cinfo, cinfo->image_height, return FALSE);
.//SVD/JPEG/jdmarker.cpp:252:  INPUT_2BYTES(cinfo, cinfo->image_width, return FALSE);
.//SVD/JPEG/jdmarker.cpp:253:  INPUT_BYTE(cinfo, cinfo->num_components, return FALSE);
.//SVD/JPEG/jdmarker.cpp:255:  length -= 8;
.//SVD/JPEG/jdmarker.cpp:257:  TRACEMS4(cinfo, 1, JTRC_SOF, cinfo->unread_marker,
.//SVD/JPEG/jdmarker.cpp:258:	   (int) cinfo->image_width, (int) cinfo->image_height,
.//SVD/JPEG/jdmarker.cpp:259:	   cinfo->num_components);
.//SVD/JPEG/jdmarker.cpp:261:  if (cinfo->marker->saw_SOF)
.//SVD/JPEG/jdmarker.cpp:267:  if (cinfo->image_height <= 0 || cinfo->image_width <= 0
.//SVD/JPEG/jdmarker.cpp:268:      || cinfo->num_components <= 0)
.//SVD/JPEG/jdmarker.cpp:271:  if (length != (cinfo->num_components * 3))
.//SVD/JPEG/jdmarker.cpp:274:  if (cinfo->comp_info == NULL)	/* do only once, even if suspend */
.//SVD/JPEG/jdmarker.cpp:275:    cinfo->comp_info = (jpeg_component_info *) (*cinfo->mem->alloc_small)
.//SVD/JPEG/jdmarker.cpp:277:			 cinfo->num_components * SIZEOF(jpeg_component_info));
.//SVD/JPEG/jdmarker.cpp:279:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdmarker.cpp:281:    compptr->component_index = ci;
.//SVD/JPEG/jdmarker.cpp:282:    INPUT_BYTE(cinfo, compptr->component_id, return FALSE);
.//SVD/JPEG/jdmarker.cpp:284:    compptr->h_samp_factor = (c >> 4) & 15;
.//SVD/JPEG/jdmarker.cpp:285:    compptr->v_samp_factor = (c     ) & 15;
.//SVD/JPEG/jdmarker.cpp:286:    INPUT_BYTE(cinfo, compptr->quant_tbl_no, return FALSE);
.//SVD/JPEG/jdmarker.cpp:289:	     compptr->component_id, compptr->h_samp_factor,
.//SVD/JPEG/jdmarker.cpp:290:	     compptr->v_samp_factor, compptr->quant_tbl_no);
.//SVD/JPEG/jdmarker.cpp:293:  cinfo->marker->saw_SOF = TRUE;
.//SVD/JPEG/jdmarker.cpp:309:  if (! cinfo->marker->saw_SOF)
.//SVD/JPEG/jdmarker.cpp:321:  cinfo->comps_in_scan = n;
.//SVD/JPEG/jdmarker.cpp:323:  /* Collect the component-spec parameters */
.//SVD/JPEG/jdmarker.cpp:329:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdmarker.cpp:331:      if (cc == compptr->component_id)
.//SVD/JPEG/jdmarker.cpp:339:    cinfo->cur_comp_info[i] = compptr;
.//SVD/JPEG/jdmarker.cpp:340:    compptr->dc_tbl_no = (c >> 4) & 15;
.//SVD/JPEG/jdmarker.cpp:341:    compptr->ac_tbl_no = (c     ) & 15;
.//SVD/JPEG/jdmarker.cpp:344:	     compptr->dc_tbl_no, compptr->ac_tbl_no);
.//SVD/JPEG/jdmarker.cpp:349:  cinfo->Ss = c;
.//SVD/JPEG/jdmarker.cpp:351:  cinfo->Se = c;
.//SVD/JPEG/jdmarker.cpp:353:  cinfo->Ah = (c >> 4) & 15;
.//SVD/JPEG/jdmarker.cpp:354:  cinfo->Al = (c     ) & 15;
.//SVD/JPEG/jdmarker.cpp:356:  TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se,
.//SVD/JPEG/jdmarker.cpp:357:	   cinfo->Ah, cinfo->Al);
.//SVD/JPEG/jdmarker.cpp:360:  cinfo->marker->next_restart_num = 0;
.//SVD/JPEG/jdmarker.cpp:363:  cinfo->input_scan_number++;
.//SVD/JPEG/jdmarker.cpp:381:  length -= 2;
.//SVD/JPEG/jdmarker.cpp:387:    length -= 2;
.//SVD/JPEG/jdmarker.cpp:395:      cinfo->arith_ac_K[index-NUM_ARITH_TBLS] = (UINT8) val;
.//SVD/JPEG/jdmarker.cpp:397:      cinfo->arith_dc_L[index] = (UINT8) (val & 0x0F);
.//SVD/JPEG/jdmarker.cpp:398:      cinfo->arith_dc_U[index] = (UINT8) (val >> 4);
.//SVD/JPEG/jdmarker.cpp:399:      if (cinfo->arith_dc_L[index] > cinfo->arith_dc_U[index])
.//SVD/JPEG/jdmarker.cpp:430:  length -= 2;
.//SVD/JPEG/jdmarker.cpp:444:    length -= 1 + 16;
.//SVD/JPEG/jdmarker.cpp:462:    length -= count;
.//SVD/JPEG/jdmarker.cpp:465:      index -= 0x10;
.//SVD/JPEG/jdmarker.cpp:466:      htblptr = &cinfo->ac_huff_tbl_ptrs[index];
.//SVD/JPEG/jdmarker.cpp:468:      htblptr = &cinfo->dc_huff_tbl_ptrs[index];
.//SVD/JPEG/jdmarker.cpp:477:    MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
.//SVD/JPEG/jdmarker.cpp:478:    MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));
.//SVD/JPEG/jdmarker.cpp:500:  length -= 2;
.//SVD/JPEG/jdmarker.cpp:512:    if (cinfo->quant_tbl_ptrs[n] == NULL)
.//SVD/JPEG/jdmarker.cpp:513:      cinfo->quant_tbl_ptrs[n] = jpeg_alloc_quant_table((j_common_ptr) cinfo);
.//SVD/JPEG/jdmarker.cpp:514:    quant_ptr = cinfo->quant_tbl_ptrs[n];
.//SVD/JPEG/jdmarker.cpp:521:      /* We convert the zigzag-order table to natural array order. */
.//SVD/JPEG/jdmarker.cpp:522:      quant_ptr->quantval[jpeg_natural_order[i]] = (UINT16) tmp;
.//SVD/JPEG/jdmarker.cpp:525:    if (cinfo->err->trace_level >= 2) {
.//SVD/JPEG/jdmarker.cpp:528:		 quant_ptr->quantval[i],   quant_ptr->quantval[i+1],
.//SVD/JPEG/jdmarker.cpp:529:		 quant_ptr->quantval[i+2], quant_ptr->quantval[i+3],
.//SVD/JPEG/jdmarker.cpp:530:		 quant_ptr->quantval[i+4], quant_ptr->quantval[i+5],
.//SVD/JPEG/jdmarker.cpp:531:		 quant_ptr->quantval[i+6], quant_ptr->quantval[i+7]);
.//SVD/JPEG/jdmarker.cpp:535:    length -= DCTSIZE2+1;
.//SVD/JPEG/jdmarker.cpp:536:    if (prec) length -= DCTSIZE2;
.//SVD/JPEG/jdmarker.cpp:564:  cinfo->restart_interval = tmp;
.//SVD/JPEG/jdmarker.cpp:600:    cinfo->saw_JFIF_marker = TRUE;
.//SVD/JPEG/jdmarker.cpp:601:    cinfo->JFIF_major_version = GETJOCTET(data[5]);
.//SVD/JPEG/jdmarker.cpp:602:    cinfo->JFIF_minor_version = GETJOCTET(data[6]);
.//SVD/JPEG/jdmarker.cpp:603:    cinfo->density_unit = GETJOCTET(data[7]);
.//SVD/JPEG/jdmarker.cpp:604:    cinfo->X_density = (GETJOCTET(data[8]) << 8) + GETJOCTET(data[9]);
.//SVD/JPEG/jdmarker.cpp:605:    cinfo->Y_density = (GETJOCTET(data[10]) << 8) + GETJOCTET(data[11]);
.//SVD/JPEG/jdmarker.cpp:612:    if (cinfo->JFIF_major_version != 1)
.//SVD/JPEG/jdmarker.cpp:614:	      cinfo->JFIF_major_version, cinfo->JFIF_minor_version);
.//SVD/JPEG/jdmarker.cpp:617:	     cinfo->JFIF_major_version, cinfo->JFIF_minor_version,
.//SVD/JPEG/jdmarker.cpp:618:	     cinfo->X_density, cinfo->Y_density, cinfo->density_unit);
.//SVD/JPEG/jdmarker.cpp:623:    totallen -= APP0_DATA_LEN;
.//SVD/JPEG/jdmarker.cpp:681:    cinfo->saw_Adobe_marker = TRUE;
.//SVD/JPEG/jdmarker.cpp:682:    cinfo->Adobe_transform = (UINT8) transform;
.//SVD/JPEG/jdmarker.cpp:700:  length -= 2;
.//SVD/JPEG/jdmarker.cpp:711:  length -= numtoread;
.//SVD/JPEG/jdmarker.cpp:714:  switch (cinfo->unread_marker) {
.//SVD/JPEG/jdmarker.cpp:723:    ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
.//SVD/JPEG/jdmarker.cpp:727:  /* skip any remaining data -- could be lots */
.//SVD/JPEG/jdmarker.cpp:730:    (*cinfo->src->skip_input_data) (cinfo, (long) length);
.//SVD/JPEG/jdmarker.cpp:742:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//SVD/JPEG/jdmarker.cpp:743:  jpeg_saved_marker_ptr cur_marker = marker->cur_marker;
.//SVD/JPEG/jdmarker.cpp:752:    length -= 2;
.//SVD/JPEG/jdmarker.cpp:756:      if (cinfo->unread_marker == (int) M_COM)
.//SVD/JPEG/jdmarker.cpp:757:	limit = marker->length_limit_COM;
.//SVD/JPEG/jdmarker.cpp:759:	limit = marker->length_limit_APPn[cinfo->unread_marker - (int) M_APP0];
.//SVD/JPEG/jdmarker.cpp:764:	(*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmarker.cpp:766:      cur_marker->next = NULL;
.//SVD/JPEG/jdmarker.cpp:767:      cur_marker->marker = (UINT8) cinfo->unread_marker;
.//SVD/JPEG/jdmarker.cpp:768:      cur_marker->original_length = (unsigned int) length;
.//SVD/JPEG/jdmarker.cpp:769:      cur_marker->data_length = limit;
.//SVD/JPEG/jdmarker.cpp:771:      data = cur_marker->data = (JOCTET FAR *) (cur_marker + 1);
.//SVD/JPEG/jdmarker.cpp:772:      marker->cur_marker = cur_marker;
.//SVD/JPEG/jdmarker.cpp:773:      marker->bytes_read = 0;
.//SVD/JPEG/jdmarker.cpp:783:    bytes_read = marker->bytes_read;
.//SVD/JPEG/jdmarker.cpp:784:    data_length = cur_marker->data_length;
.//SVD/JPEG/jdmarker.cpp:785:    data = cur_marker->data + bytes_read;
.//SVD/JPEG/jdmarker.cpp:790:    marker->bytes_read = bytes_read;
.//SVD/JPEG/jdmarker.cpp:796:      bytes_in_buffer--;
.//SVD/JPEG/jdmarker.cpp:804:    if (cinfo->marker_list == NULL) {
.//SVD/JPEG/jdmarker.cpp:805:      cinfo->marker_list = cur_marker;
.//SVD/JPEG/jdmarker.cpp:807:      jpeg_saved_marker_ptr prev = cinfo->marker_list;
.//SVD/JPEG/jdmarker.cpp:808:      while (prev->next != NULL)
.//SVD/JPEG/jdmarker.cpp:809:	prev = prev->next;
.//SVD/JPEG/jdmarker.cpp:810:      prev->next = cur_marker;
.//SVD/JPEG/jdmarker.cpp:813:    data = cur_marker->data;
.//SVD/JPEG/jdmarker.cpp:814:    length = cur_marker->original_length - data_length;
.//SVD/JPEG/jdmarker.cpp:817:  marker->cur_marker = NULL;
.//SVD/JPEG/jdmarker.cpp:820:  switch (cinfo->unread_marker) {
.//SVD/JPEG/jdmarker.cpp:828:    TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker,
.//SVD/JPEG/jdmarker.cpp:833:  /* skip any remaining data -- could be lots */
.//SVD/JPEG/jdmarker.cpp:836:    (*cinfo->src->skip_input_data) (cinfo, (long) length);
.//SVD/JPEG/jdmarker.cpp:846:/* Skip over an unknown or uninteresting variable-length marker */
.//SVD/JPEG/jdmarker.cpp:852:  length -= 2;
.//SVD/JPEG/jdmarker.cpp:854:  TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker, (int) length);
.//SVD/JPEG/jdmarker.cpp:858:    (*cinfo->src->skip_input_data) (cinfo, (long) length);
.//SVD/JPEG/jdmarker.cpp:865: * Find the next JPEG marker, save it in cinfo->unread_marker.
.//SVD/JPEG/jdmarker.cpp:867: * in that case cinfo->unread_marker is unchanged.
.//SVD/JPEG/jdmarker.cpp:881:    /* Skip any non-FF bytes.
.//SVD/JPEG/jdmarker.cpp:887:      cinfo->marker->discarded_bytes++;
.//SVD/JPEG/jdmarker.cpp:901:    /* Reach here if we found a stuffed-zero data sequence (FF/00).
.//SVD/JPEG/jdmarker.cpp:904:    cinfo->marker->discarded_bytes += 2;
.//SVD/JPEG/jdmarker.cpp:908:  if (cinfo->marker->discarded_bytes != 0) {
.//SVD/JPEG/jdmarker.cpp:909:    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);
.//SVD/JPEG/jdmarker.cpp:910:    cinfo->marker->discarded_bytes = 0;
.//SVD/JPEG/jdmarker.cpp:913:  cinfo->unread_marker = c;
.//SVD/JPEG/jdmarker.cpp:925: * If an application wants to process non-JFIF files, it must seek to the
.//SVD/JPEG/jdmarker.cpp:937:  cinfo->unread_marker = c2;
.//SVD/JPEG/jdmarker.cpp:958:    if (cinfo->unread_marker == 0) {
.//SVD/JPEG/jdmarker.cpp:959:      if (! cinfo->marker->saw_SOI) {
.//SVD/JPEG/jdmarker.cpp:967:    /* At this point cinfo->unread_marker contains the marker code and the
.//SVD/JPEG/jdmarker.cpp:971:    switch (cinfo->unread_marker) {
.//SVD/JPEG/jdmarker.cpp:1008:      ERREXIT1(cinfo, JERR_SOF_UNSUPPORTED, cinfo->unread_marker);
.//SVD/JPEG/jdmarker.cpp:1014:      cinfo->unread_marker = 0;	/* processed the marker */
.//SVD/JPEG/jdmarker.cpp:1019:      cinfo->unread_marker = 0;	/* processed the marker */
.//SVD/JPEG/jdmarker.cpp:1058:      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[
.//SVD/JPEG/jdmarker.cpp:1059:		cinfo->unread_marker - (int) M_APP0]) (cinfo))
.//SVD/JPEG/jdmarker.cpp:1064:      if (! (*((my_marker_ptr) cinfo->marker)->process_COM) (cinfo))
.//SVD/JPEG/jdmarker.cpp:1077:      TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo->unread_marker);
.//SVD/JPEG/jdmarker.cpp:1088:       * Once the JPEG 3 version-number marker is well defined, this code
.//SVD/JPEG/jdmarker.cpp:1091:      ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
.//SVD/JPEG/jdmarker.cpp:1095:    cinfo->unread_marker = 0;
.//SVD/JPEG/jdmarker.cpp:1106: * number of MCUs.  cinfo->unread_marker may be nonzero if the entropy decoder
.//SVD/JPEG/jdmarker.cpp:1108: * cinfo->unread_marker will be reset to 0 before returning; if not reset,
.//SVD/JPEG/jdmarker.cpp:1117:  if (cinfo->unread_marker == 0) {
.//SVD/JPEG/jdmarker.cpp:1122:  if (cinfo->unread_marker ==
.//SVD/JPEG/jdmarker.cpp:1123:      ((int) M_RST0 + cinfo->marker->next_restart_num)) {
.//SVD/JPEG/jdmarker.cpp:1124:    /* Normal case --- swallow the marker and let entropy decoder continue */
.//SVD/JPEG/jdmarker.cpp:1125:    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);
.//SVD/JPEG/jdmarker.cpp:1126:    cinfo->unread_marker = 0;
.//SVD/JPEG/jdmarker.cpp:1128:    /* Uh-oh, the restart markers have been messed up. */
.//SVD/JPEG/jdmarker.cpp:1130:    if (! (*cinfo->src->resync_to_restart) (cinfo,
.//SVD/JPEG/jdmarker.cpp:1131:					    cinfo->marker->next_restart_num))
.//SVD/JPEG/jdmarker.cpp:1135:  /* Update next-restart state */
.//SVD/JPEG/jdmarker.cpp:1136:  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;
.//SVD/JPEG/jdmarker.cpp:1151: * a nonzero restart interval has been declared.)  cinfo->unread_marker is
.//SVD/JPEG/jdmarker.cpp:1156: * Note that cinfo->unread_marker is treated as a marker appearing before
.//SVD/JPEG/jdmarker.cpp:1157: * the current data-source input point; usually it should be reset to zero
.//SVD/JPEG/jdmarker.cpp:1170: *      dependent on buffer size and chance buffer-boundary positions.)
.//SVD/JPEG/jdmarker.cpp:1171: *   3. Leave the marker unread (by failing to zero cinfo->unread_marker).
.//SVD/JPEG/jdmarker.cpp:1185: * For any valid non-restart JPEG marker, we apply #3.  This keeps us from
.//SVD/JPEG/jdmarker.cpp:1186: * overrunning the end of a scan.  An implementation limited to single-scan
.//SVD/JPEG/jdmarker.cpp:1194:  int marker = cinfo->unread_marker;
.//SVD/JPEG/jdmarker.cpp:1205:      action = 3;		/* valid non-restart marker */
.//SVD/JPEG/jdmarker.cpp:1210:      else if (marker == ((int) M_RST0 + ((desired-1) & 7)) ||
.//SVD/JPEG/jdmarker.cpp:1211:	       marker == ((int) M_RST0 + ((desired-2) & 7)))
.//SVD/JPEG/jdmarker.cpp:1220:      cinfo->unread_marker = 0;
.//SVD/JPEG/jdmarker.cpp:1226:      marker = cinfo->unread_marker;
.//SVD/JPEG/jdmarker.cpp:1244:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//SVD/JPEG/jdmarker.cpp:1246:  cinfo->comp_info = NULL;		/* until allocated by get_sof */
.//SVD/JPEG/jdmarker.cpp:1247:  cinfo->input_scan_number = 0;		/* no SOS seen yet */
.//SVD/JPEG/jdmarker.cpp:1248:  cinfo->unread_marker = 0;		/* no pending marker */
.//SVD/JPEG/jdmarker.cpp:1249:  marker->pub.saw_SOI = FALSE;		/* set internal state too */
.//SVD/JPEG/jdmarker.cpp:1250:  marker->pub.saw_SOF = FALSE;
.//SVD/JPEG/jdmarker.cpp:1251:  marker->pub.discarded_bytes = 0;
.//SVD/JPEG/jdmarker.cpp:1252:  marker->cur_marker = NULL;
.//SVD/JPEG/jdmarker.cpp:1269:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
.//SVD/JPEG/jdmarker.cpp:1271:  cinfo->marker = (struct jpeg_marker_reader *) marker;
.//SVD/JPEG/jdmarker.cpp:1273:  marker->pub.reset_marker_reader = reset_marker_reader;
.//SVD/JPEG/jdmarker.cpp:1274:  marker->pub.read_markers = read_markers;
.//SVD/JPEG/jdmarker.cpp:1275:  marker->pub.read_restart_marker = read_restart_marker;
.//SVD/JPEG/jdmarker.cpp:1280:  marker->process_COM = skip_variable;
.//SVD/JPEG/jdmarker.cpp:1281:  marker->length_limit_COM = 0;
.//SVD/JPEG/jdmarker.cpp:1283:    marker->process_APPn[i] = skip_variable;
.//SVD/JPEG/jdmarker.cpp:1284:    marker->length_limit_APPn[i] = 0;
.//SVD/JPEG/jdmarker.cpp:1286:  marker->process_APPn[0] = get_interesting_appn;
.//SVD/JPEG/jdmarker.cpp:1287:  marker->process_APPn[14] = get_interesting_appn;
.//SVD/JPEG/jdmarker.cpp:1303:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//SVD/JPEG/jdmarker.cpp:1308:   * (should only be a concern in a 16-bit environment).
.//SVD/JPEG/jdmarker.cpp:1310:  maxlength = cinfo->mem->max_alloc_chunk - SIZEOF(struct jpeg_marker_struct);
.//SVD/JPEG/jdmarker.cpp:1326:    /* If discarding APP0/APP14, use our regular on-the-fly processor. */
.//SVD/JPEG/jdmarker.cpp:1332:    marker->process_COM = processor;
.//SVD/JPEG/jdmarker.cpp:1333:    marker->length_limit_COM = length_limit;
.//SVD/JPEG/jdmarker.cpp:1335:    marker->process_APPn[marker_code - (int) M_APP0] = processor;
.//SVD/JPEG/jdmarker.cpp:1336:    marker->length_limit_APPn[marker_code - (int) M_APP0] = length_limit;
.//SVD/JPEG/jdmarker.cpp:1352:  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
.//SVD/JPEG/jdmarker.cpp:1355:    marker->process_COM = routine;
.//SVD/JPEG/jdmarker.cpp:1357:    marker->process_APPn[marker_code - (int) M_APP0] = routine;
.//SVD/JPEG/jdmaster.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jdmaster.cpp:47:  /* Merging is the equivalent of plain box-filter upsampling */
.//SVD/JPEG/jdmaster.cpp:48:  if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
.//SVD/JPEG/jdmaster.cpp:51:  if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
.//SVD/JPEG/jdmaster.cpp:52:      cinfo->out_color_space != JCS_RGB ||
.//SVD/JPEG/jdmaster.cpp:53:      cinfo->out_color_components != RGB_PIXELSIZE)
.//SVD/JPEG/jdmaster.cpp:56:  if (cinfo->comp_info[0].h_samp_factor != 2 ||
.//SVD/JPEG/jdmaster.cpp:57:      cinfo->comp_info[1].h_samp_factor != 1 ||
.//SVD/JPEG/jdmaster.cpp:58:      cinfo->comp_info[2].h_samp_factor != 1 ||
.//SVD/JPEG/jdmaster.cpp:59:      cinfo->comp_info[0].v_samp_factor >  2 ||
.//SVD/JPEG/jdmaster.cpp:60:      cinfo->comp_info[1].v_samp_factor != 1 ||
.//SVD/JPEG/jdmaster.cpp:61:      cinfo->comp_info[2].v_samp_factor != 1)
.//SVD/JPEG/jdmaster.cpp:64:  if (cinfo->comp_info[0].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
.//SVD/JPEG/jdmaster.cpp:65:      cinfo->comp_info[1].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
.//SVD/JPEG/jdmaster.cpp:66:      cinfo->comp_info[2].DCT_scaled_size != cinfo->min_DCT_scaled_size)
.//SVD/JPEG/jdmaster.cpp:68:  /* ??? also need to test for upsample-time rescaling, when & if supported */
.//SVD/JPEG/jdmaster.cpp:93:  if (cinfo->global_state != DSTATE_READY)
.//SVD/JPEG/jdmaster.cpp:94:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdmaster.cpp:99:  if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
.//SVD/JPEG/jdmaster.cpp:101:    cinfo->output_width = (JDIMENSION)
.//SVD/JPEG/jdmaster.cpp:102:      jdiv_round_up((long) cinfo->image_width, 8L);
.//SVD/JPEG/jdmaster.cpp:103:    cinfo->output_height = (JDIMENSION)
.//SVD/JPEG/jdmaster.cpp:104:      jdiv_round_up((long) cinfo->image_height, 8L);
.//SVD/JPEG/jdmaster.cpp:105:    cinfo->min_DCT_scaled_size = 1;
.//SVD/JPEG/jdmaster.cpp:106:  } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
.//SVD/JPEG/jdmaster.cpp:108:    cinfo->output_width = (JDIMENSION)
.//SVD/JPEG/jdmaster.cpp:109:      jdiv_round_up((long) cinfo->image_width, 4L);
.//SVD/JPEG/jdmaster.cpp:110:    cinfo->output_height = (JDIMENSION)
.//SVD/JPEG/jdmaster.cpp:111:      jdiv_round_up((long) cinfo->image_height, 4L);
.//SVD/JPEG/jdmaster.cpp:112:    cinfo->min_DCT_scaled_size = 2;
.//SVD/JPEG/jdmaster.cpp:113:  } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
.//SVD/JPEG/jdmaster.cpp:115:    cinfo->output_width = (JDIMENSION)
.//SVD/JPEG/jdmaster.cpp:116:      jdiv_round_up((long) cinfo->image_width, 2L);
.//SVD/JPEG/jdmaster.cpp:117:    cinfo->output_height = (JDIMENSION)
.//SVD/JPEG/jdmaster.cpp:118:      jdiv_round_up((long) cinfo->image_height, 2L);
.//SVD/JPEG/jdmaster.cpp:119:    cinfo->min_DCT_scaled_size = 4;
.//SVD/JPEG/jdmaster.cpp:122:    cinfo->output_width = cinfo->image_width;
.//SVD/JPEG/jdmaster.cpp:123:    cinfo->output_height = cinfo->image_height;
.//SVD/JPEG/jdmaster.cpp:124:    cinfo->min_DCT_scaled_size = DCTSIZE;
.//SVD/JPEG/jdmaster.cpp:131:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdmaster.cpp:133:    int ssize = cinfo->min_DCT_scaled_size;
.//SVD/JPEG/jdmaster.cpp:135:	   (compptr->h_samp_factor * ssize * 2 <=
.//SVD/JPEG/jdmaster.cpp:136:	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
.//SVD/JPEG/jdmaster.cpp:137:	   (compptr->v_samp_factor * ssize * 2 <=
.//SVD/JPEG/jdmaster.cpp:138:	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
.//SVD/JPEG/jdmaster.cpp:141:    compptr->DCT_scaled_size = ssize;
.//SVD/JPEG/jdmaster.cpp:147:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdmaster.cpp:150:    compptr->downsampled_width = (JDIMENSION)
.//SVD/JPEG/jdmaster.cpp:151:      jdiv_round_up((long) cinfo->image_width *
.//SVD/JPEG/jdmaster.cpp:152:		    (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
.//SVD/JPEG/jdmaster.cpp:153:		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
.//SVD/JPEG/jdmaster.cpp:154:    compptr->downsampled_height = (JDIMENSION)
.//SVD/JPEG/jdmaster.cpp:155:      jdiv_round_up((long) cinfo->image_height *
.//SVD/JPEG/jdmaster.cpp:156:		    (long) (compptr->v_samp_factor * compptr->DCT_scaled_size),
.//SVD/JPEG/jdmaster.cpp:157:		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
.//SVD/JPEG/jdmaster.cpp:163:  cinfo->output_width = cinfo->image_width;
.//SVD/JPEG/jdmaster.cpp:164:  cinfo->output_height = cinfo->image_height;
.//SVD/JPEG/jdmaster.cpp:173:  switch (cinfo->out_color_space) {
.//SVD/JPEG/jdmaster.cpp:175:    cinfo->out_color_components = 1;
.//SVD/JPEG/jdmaster.cpp:179:    cinfo->out_color_components = RGB_PIXELSIZE;
.//SVD/JPEG/jdmaster.cpp:183:    cinfo->out_color_components = 3;
.//SVD/JPEG/jdmaster.cpp:187:    cinfo->out_color_components = 4;
.//SVD/JPEG/jdmaster.cpp:190:    cinfo->out_color_components = cinfo->num_components;
.//SVD/JPEG/jdmaster.cpp:193:  cinfo->output_components = (cinfo->quantize_colors ? 1 :
.//SVD/JPEG/jdmaster.cpp:194:			      cinfo->out_color_components);
.//SVD/JPEG/jdmaster.cpp:198:    cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
.//SVD/JPEG/jdmaster.cpp:200:    cinfo->rec_outbuf_height = 1;
.//SVD/JPEG/jdmaster.cpp:205: * Several decompression processes need to range-limit values to the range
.//SVD/JPEG/jdmaster.cpp:210: * a (subscript-check-less) C table lookup
.//SVD/JPEG/jdmaster.cpp:219: * -(MAXJSAMPLE+1) to 2*MAXJSAMPLE+1 is sufficient.  But for the initial
.//SVD/JPEG/jdmaster.cpp:220: * limiting step (just after the IDCT), a wildly out-of-range value is 
.//SVD/JPEG/jdmaster.cpp:222: * off the end of memory and getting a bad-pointer trap, we perform the
.//SVD/JPEG/jdmaster.cpp:223: * post-IDCT limiting thus:
.//SVD/JPEG/jdmaster.cpp:225: * where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit
.//SVD/JPEG/jdmaster.cpp:228: * cause wraparound, and we will safely generate a bogus-but-in-range output.
.//SVD/JPEG/jdmaster.cpp:229: * For the post-IDCT step, we want to convert the data from signed to unsigned
.//SVD/JPEG/jdmaster.cpp:231: * So the post-IDCT limiting table ends up looking like this:
.//SVD/JPEG/jdmaster.cpp:233: *   MAXJSAMPLE (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),
.//SVD/JPEG/jdmaster.cpp:234: *   0          (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),
.//SVD/JPEG/jdmaster.cpp:235: *   0,1,...,CENTERJSAMPLE-1
.//SVD/JPEG/jdmaster.cpp:239: * We can save some space by overlapping the start of the post-IDCT table
.//SVD/JPEG/jdmaster.cpp:240: * with the simpler range limiting table.  The post-IDCT table begins at
.//SVD/JPEG/jdmaster.cpp:255:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmaster.cpp:258:  cinfo->sample_range_limit = table;
.//SVD/JPEG/jdmaster.cpp:260:  MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
.//SVD/JPEG/jdmaster.cpp:264:  table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
.//SVD/JPEG/jdmaster.cpp:265:  /* End of simple table, rest of first half of post-IDCT table */
.//SVD/JPEG/jdmaster.cpp:268:  /* Second half of post-IDCT table */
.//SVD/JPEG/jdmaster.cpp:270:	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
.//SVD/JPEG/jdmaster.cpp:271:  MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
.//SVD/JPEG/jdmaster.cpp:272:	  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));
.//SVD/JPEG/jdmaster.cpp:290:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//SVD/JPEG/jdmaster.cpp:300:  samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
.//SVD/JPEG/jdmaster.cpp:306:  master->pass_number = 0;
.//SVD/JPEG/jdmaster.cpp:307:  master->using_merged_upsample = use_merged_upsample(cinfo);
.//SVD/JPEG/jdmaster.cpp:310:  master->quantizer_1pass = NULL;
.//SVD/JPEG/jdmaster.cpp:311:  master->quantizer_2pass = NULL;
.//SVD/JPEG/jdmaster.cpp:312:  /* No mode changes if not using buffered-image mode. */
.//SVD/JPEG/jdmaster.cpp:313:  if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
.//SVD/JPEG/jdmaster.cpp:314:    cinfo->enable_1pass_quant = FALSE;
.//SVD/JPEG/jdmaster.cpp:315:    cinfo->enable_external_quant = FALSE;
.//SVD/JPEG/jdmaster.cpp:316:    cinfo->enable_2pass_quant = FALSE;
.//SVD/JPEG/jdmaster.cpp:318:  if (cinfo->quantize_colors) {
.//SVD/JPEG/jdmaster.cpp:319:    if (cinfo->raw_data_out)
.//SVD/JPEG/jdmaster.cpp:321:    /* 2-pass quantizer only works in 3-component color space. */
.//SVD/JPEG/jdmaster.cpp:322:    if (cinfo->out_color_components != 3) {
.//SVD/JPEG/jdmaster.cpp:323:      cinfo->enable_1pass_quant = TRUE;
.//SVD/JPEG/jdmaster.cpp:324:      cinfo->enable_external_quant = FALSE;
.//SVD/JPEG/jdmaster.cpp:325:      cinfo->enable_2pass_quant = FALSE;
.//SVD/JPEG/jdmaster.cpp:326:      cinfo->colormap = NULL;
.//SVD/JPEG/jdmaster.cpp:327:    } else if (cinfo->colormap != NULL) {
.//SVD/JPEG/jdmaster.cpp:328:      cinfo->enable_external_quant = TRUE;
.//SVD/JPEG/jdmaster.cpp:329:    } else if (cinfo->two_pass_quantize) {
.//SVD/JPEG/jdmaster.cpp:330:      cinfo->enable_2pass_quant = TRUE;
.//SVD/JPEG/jdmaster.cpp:332:      cinfo->enable_1pass_quant = TRUE;
.//SVD/JPEG/jdmaster.cpp:335:    if (cinfo->enable_1pass_quant) {
.//SVD/JPEG/jdmaster.cpp:338:      master->quantizer_1pass = cinfo->cquantize;
.//SVD/JPEG/jdmaster.cpp:344:    /* We use the 2-pass code to map to external colormaps. */
.//SVD/JPEG/jdmaster.cpp:345:    if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
.//SVD/JPEG/jdmaster.cpp:348:      master->quantizer_2pass = cinfo->cquantize;
.//SVD/JPEG/jdmaster.cpp:353:    /* If both quantizers are initialized, the 2-pass one is left active;
.//SVD/JPEG/jdmaster.cpp:358:  /* Post-processing: in particular, color conversion first */
.//SVD/JPEG/jdmaster.cpp:359:  if (! cinfo->raw_data_out) {
.//SVD/JPEG/jdmaster.cpp:360:    if (master->using_merged_upsample) {
.//SVD/JPEG/jdmaster.cpp:370:    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
.//SVD/JPEG/jdmaster.cpp:375:  if (cinfo->arith_code) {
.//SVD/JPEG/jdmaster.cpp:378:    if (cinfo->progressive_mode) {
.//SVD/JPEG/jdmaster.cpp:389:  use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
.//SVD/JPEG/jdmaster.cpp:392:  if (! cinfo->raw_data_out)
.//SVD/JPEG/jdmaster.cpp:396:  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
.//SVD/JPEG/jdmaster.cpp:399:  (*cinfo->inputctl->start_input_pass) (cinfo);
.//SVD/JPEG/jdmaster.cpp:406:  if (cinfo->progress != NULL && ! cinfo->buffered_image &&
.//SVD/JPEG/jdmaster.cpp:407:      cinfo->inputctl->has_multiple_scans) {
.//SVD/JPEG/jdmaster.cpp:410:    if (cinfo->progressive_mode) {
.//SVD/JPEG/jdmaster.cpp:412:      nscans = 2 + 3 * cinfo->num_components;
.//SVD/JPEG/jdmaster.cpp:415:      nscans = cinfo->num_components;
.//SVD/JPEG/jdmaster.cpp:417:    cinfo->progress->pass_counter = 0L;
.//SVD/JPEG/jdmaster.cpp:418:    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
.//SVD/JPEG/jdmaster.cpp:419:    cinfo->progress->completed_passes = 0;
.//SVD/JPEG/jdmaster.cpp:420:    cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
.//SVD/JPEG/jdmaster.cpp:422:    master->pass_number++;
.//SVD/JPEG/jdmaster.cpp:429: * Per-pass setup.
.//SVD/JPEG/jdmaster.cpp:440:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//SVD/JPEG/jdmaster.cpp:442:  if (master->pub.is_dummy_pass) {
.//SVD/JPEG/jdmaster.cpp:444:    /* Final pass of 2-pass quantization */
.//SVD/JPEG/jdmaster.cpp:445:    master->pub.is_dummy_pass = FALSE;
.//SVD/JPEG/jdmaster.cpp:446:    (*cinfo->cquantize->start_pass) (cinfo, FALSE);
.//SVD/JPEG/jdmaster.cpp:447:    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
.//SVD/JPEG/jdmaster.cpp:448:    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
.//SVD/JPEG/jdmaster.cpp:453:    if (cinfo->quantize_colors && cinfo->colormap == NULL) {
.//SVD/JPEG/jdmaster.cpp:455:      if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
.//SVD/JPEG/jdmaster.cpp:456:	cinfo->cquantize = master->quantizer_2pass;
.//SVD/JPEG/jdmaster.cpp:457:	master->pub.is_dummy_pass = TRUE;
.//SVD/JPEG/jdmaster.cpp:458:      } else if (cinfo->enable_1pass_quant) {
.//SVD/JPEG/jdmaster.cpp:459:	cinfo->cquantize = master->quantizer_1pass;
.//SVD/JPEG/jdmaster.cpp:464:    (*cinfo->idct->start_pass) (cinfo);
.//SVD/JPEG/jdmaster.cpp:465:    (*cinfo->coef->start_output_pass) (cinfo);
.//SVD/JPEG/jdmaster.cpp:466:    if (! cinfo->raw_data_out) {
.//SVD/JPEG/jdmaster.cpp:467:      if (! master->using_merged_upsample)
.//SVD/JPEG/jdmaster.cpp:468:	(*cinfo->cconvert->start_pass) (cinfo);
.//SVD/JPEG/jdmaster.cpp:469:      (*cinfo->upsample->start_pass) (cinfo);
.//SVD/JPEG/jdmaster.cpp:470:      if (cinfo->quantize_colors)
.//SVD/JPEG/jdmaster.cpp:471:	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
.//SVD/JPEG/jdmaster.cpp:472:      (*cinfo->post->start_pass) (cinfo,
.//SVD/JPEG/jdmaster.cpp:473:	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
.//SVD/JPEG/jdmaster.cpp:474:      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
.//SVD/JPEG/jdmaster.cpp:479:  if (cinfo->progress != NULL) {
.//SVD/JPEG/jdmaster.cpp:480:    cinfo->progress->completed_passes = master->pass_number;
.//SVD/JPEG/jdmaster.cpp:481:    cinfo->progress->total_passes = master->pass_number +
.//SVD/JPEG/jdmaster.cpp:482:				    (master->pub.is_dummy_pass ? 2 : 1);
.//SVD/JPEG/jdmaster.cpp:483:    /* In buffered-image mode, we assume one more output pass if EOI not
.//SVD/JPEG/jdmaster.cpp:486:    if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
.//SVD/JPEG/jdmaster.cpp:487:      cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
.//SVD/JPEG/jdmaster.cpp:500:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//SVD/JPEG/jdmaster.cpp:502:  if (cinfo->quantize_colors)
.//SVD/JPEG/jdmaster.cpp:503:    (*cinfo->cquantize->finish_pass) (cinfo);
.//SVD/JPEG/jdmaster.cpp:504:  master->pass_number++;
.//SVD/JPEG/jdmaster.cpp:517:  my_master_ptr master = (my_master_ptr) cinfo->master;
.//SVD/JPEG/jdmaster.cpp:520:  if (cinfo->global_state != DSTATE_BUFIMAGE)
.//SVD/JPEG/jdmaster.cpp:521:    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdmaster.cpp:523:  if (cinfo->quantize_colors && cinfo->enable_external_quant &&
.//SVD/JPEG/jdmaster.cpp:524:      cinfo->colormap != NULL) {
.//SVD/JPEG/jdmaster.cpp:525:    /* Select 2-pass quantizer for external colormap use */
.//SVD/JPEG/jdmaster.cpp:526:    cinfo->cquantize = master->quantizer_2pass;
.//SVD/JPEG/jdmaster.cpp:528:    (*cinfo->cquantize->new_color_map) (cinfo);
.//SVD/JPEG/jdmaster.cpp:529:    master->pub.is_dummy_pass = FALSE; /* just in case */
.//SVD/JPEG/jdmaster.cpp:548:      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmaster.cpp:550:  cinfo->master = (struct jpeg_decomp_master *) master;
.//SVD/JPEG/jdmaster.cpp:551:  master->pub.prepare_for_output_pass = prepare_for_output_pass;
.//SVD/JPEG/jdmaster.cpp:552:  master->pub.finish_output_pass = finish_output_pass;
.//SVD/JPEG/jdmaster.cpp:554:  master->pub.is_dummy_pass = FALSE;
.//SVD/JPEG/jdmerge.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jdmerge.cpp:22: * At typical sampling ratios, this eliminates half or three-quarters of the
.//SVD/JPEG/jdmerge.cpp:29: *	Corner-aligned (non-CCIR601) sampling alignment.
.//SVD/JPEG/jdmerge.cpp:52:  /* Private state for YCC->RGB conversion */
.//SVD/JPEG/jdmerge.cpp:60:   * application provides just a one-row buffer; we also use the spare
.//SVD/JPEG/jdmerge.cpp:72:#define SCALEBITS	16	/* speediest right-shift on some machines */
.//SVD/JPEG/jdmerge.cpp:73:#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
.//SVD/JPEG/jdmerge.cpp:78: * Initialize tables for YCC->RGB colorspace conversion.
.//SVD/JPEG/jdmerge.cpp:85:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//SVD/JPEG/jdmerge.cpp:90:  upsample->Cr_r_tab = (int *)
.//SVD/JPEG/jdmerge.cpp:91:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmerge.cpp:93:  upsample->Cb_b_tab = (int *)
.//SVD/JPEG/jdmerge.cpp:94:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmerge.cpp:96:  upsample->Cr_g_tab = (INT32 *)
.//SVD/JPEG/jdmerge.cpp:97:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmerge.cpp:99:  upsample->Cb_g_tab = (INT32 *)
.//SVD/JPEG/jdmerge.cpp:100:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmerge.cpp:103:  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
.//SVD/JPEG/jdmerge.cpp:105:    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
.//SVD/JPEG/jdmerge.cpp:107:    upsample->Cr_r_tab[i] = (int)
.//SVD/JPEG/jdmerge.cpp:110:    upsample->Cb_b_tab[i] = (int)
.//SVD/JPEG/jdmerge.cpp:112:    /* Cr=>G value is scaled-up -0.71414 * x */
.//SVD/JPEG/jdmerge.cpp:113:    upsample->Cr_g_tab[i] = (- FIX(0.71414)) * x;
.//SVD/JPEG/jdmerge.cpp:114:    /* Cb=>G value is scaled-up -0.34414 * x */
.//SVD/JPEG/jdmerge.cpp:116:    upsample->Cb_g_tab[i] = (- FIX(0.34414)) * x + ONE_HALF;
.//SVD/JPEG/jdmerge.cpp:128:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//SVD/JPEG/jdmerge.cpp:131:  upsample->spare_full = FALSE;
.//SVD/JPEG/jdmerge.cpp:132:  /* Initialize total-height counter for detecting bottom of image */
.//SVD/JPEG/jdmerge.cpp:133:  upsample->rows_to_go = cinfo->output_height;
.//SVD/JPEG/jdmerge.cpp:151:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//SVD/JPEG/jdmerge.cpp:155:  if (upsample->spare_full) {
.//SVD/JPEG/jdmerge.cpp:157:    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
.//SVD/JPEG/jdmerge.cpp:158:		      1, upsample->out_row_width);
.//SVD/JPEG/jdmerge.cpp:160:    upsample->spare_full = FALSE;
.//SVD/JPEG/jdmerge.cpp:165:    if (num_rows > upsample->rows_to_go)
.//SVD/JPEG/jdmerge.cpp:166:      num_rows = upsample->rows_to_go;
.//SVD/JPEG/jdmerge.cpp:168:    out_rows_avail -= *out_row_ctr;
.//SVD/JPEG/jdmerge.cpp:176:      work_ptrs[1] = upsample->spare_row;
.//SVD/JPEG/jdmerge.cpp:177:      upsample->spare_full = TRUE;
.//SVD/JPEG/jdmerge.cpp:180:    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
.//SVD/JPEG/jdmerge.cpp:185:  upsample->rows_to_go -= num_rows;
.//SVD/JPEG/jdmerge.cpp:187:  if (! upsample->spare_full)
.//SVD/JPEG/jdmerge.cpp:200:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//SVD/JPEG/jdmerge.cpp:203:  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
.//SVD/JPEG/jdmerge.cpp:215: * Note: since we may be writing directly into application-supplied buffers,
.//SVD/JPEG/jdmerge.cpp:230:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//SVD/JPEG/jdmerge.cpp:237:  register JSAMPLE * range_limit = cinfo->sample_range_limit;
.//SVD/JPEG/jdmerge.cpp:238:  int * Crrtab = upsample->Cr_r_tab;
.//SVD/JPEG/jdmerge.cpp:239:  int * Cbbtab = upsample->Cb_b_tab;
.//SVD/JPEG/jdmerge.cpp:240:  INT32 * Crgtab = upsample->Cr_g_tab;
.//SVD/JPEG/jdmerge.cpp:241:  INT32 * Cbgtab = upsample->Cb_g_tab;
.//SVD/JPEG/jdmerge.cpp:249:  for (col = cinfo->output_width >> 1; col > 0; col--) {
.//SVD/JPEG/jdmerge.cpp:269:  if (cinfo->output_width & 1) {
.//SVD/JPEG/jdmerge.cpp:292:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//SVD/JPEG/jdmerge.cpp:299:  register JSAMPLE * range_limit = cinfo->sample_range_limit;
.//SVD/JPEG/jdmerge.cpp:300:  int * Crrtab = upsample->Cr_r_tab;
.//SVD/JPEG/jdmerge.cpp:301:  int * Cbbtab = upsample->Cb_b_tab;
.//SVD/JPEG/jdmerge.cpp:302:  INT32 * Crgtab = upsample->Cr_g_tab;
.//SVD/JPEG/jdmerge.cpp:303:  INT32 * Cbgtab = upsample->Cb_g_tab;
.//SVD/JPEG/jdmerge.cpp:313:  for (col = cinfo->output_width >> 1; col > 0; col--) {
.//SVD/JPEG/jdmerge.cpp:343:  if (cinfo->output_width & 1) {
.//SVD/JPEG/jdmerge.cpp:375:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmerge.cpp:377:  cinfo->upsample = (struct jpeg_upsampler *) upsample;
.//SVD/JPEG/jdmerge.cpp:378:  upsample->pub.start_pass = start_pass_merged_upsample;
.//SVD/JPEG/jdmerge.cpp:379:  upsample->pub.need_context_rows = FALSE;
.//SVD/JPEG/jdmerge.cpp:381:  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
.//SVD/JPEG/jdmerge.cpp:383:  if (cinfo->max_v_samp_factor == 2) {
.//SVD/JPEG/jdmerge.cpp:384:    upsample->pub.upsample = merged_2v_upsample;
.//SVD/JPEG/jdmerge.cpp:385:    upsample->upmethod = h2v2_merged_upsample;
.//SVD/JPEG/jdmerge.cpp:387:    upsample->spare_row = (JSAMPROW)
.//SVD/JPEG/jdmerge.cpp:388:      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdmerge.cpp:389:		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
.//SVD/JPEG/jdmerge.cpp:391:    upsample->pub.upsample = merged_1v_upsample;
.//SVD/JPEG/jdmerge.cpp:392:    upsample->upmethod = h2v1_merged_upsample;
.//SVD/JPEG/jdmerge.cpp:394:    upsample->spare_row = NULL;
.//SVD/JPEG/jdphuff.cpp:4: * Copyright (C) 1995-1997, Thomas G. Lane.
.//SVD/JPEG/jdphuff.cpp:88: * Initialize for a Huffman-compressed scan.
.//SVD/JPEG/jdphuff.cpp:94:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jdphuff.cpp:100:  is_DC_band = (cinfo->Ss == 0);
.//SVD/JPEG/jdphuff.cpp:105:    if (cinfo->Se != 0)
.//SVD/JPEG/jdphuff.cpp:109:    if (cinfo->Ss > cinfo->Se || cinfo->Se >= DCTSIZE2)
.//SVD/JPEG/jdphuff.cpp:112:    if (cinfo->comps_in_scan != 1)
.//SVD/JPEG/jdphuff.cpp:115:  if (cinfo->Ah != 0) {
.//SVD/JPEG/jdphuff.cpp:116:    /* Successive approximation refinement scan: must have Al = Ah-1. */
.//SVD/JPEG/jdphuff.cpp:117:    if (cinfo->Al != cinfo->Ah-1)
.//SVD/JPEG/jdphuff.cpp:120:  if (cinfo->Al > 13)		/* need not check for < 0 */
.//SVD/JPEG/jdphuff.cpp:122:  /* Arguably the maximum Al value should be less than 13 for 8-bit precision,
.//SVD/JPEG/jdphuff.cpp:124:   * accept.  Note: large Al values could result in out-of-range DC
.//SVD/JPEG/jdphuff.cpp:130:	     cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
.//SVD/JPEG/jdphuff.cpp:132:   * Note that inter-scan inconsistencies are treated as warnings
.//SVD/JPEG/jdphuff.cpp:135:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jdphuff.cpp:136:    int cindex = cinfo->cur_comp_info[ci]->component_index;
.//SVD/JPEG/jdphuff.cpp:137:    coef_bit_ptr = & cinfo->coef_bits[cindex][0];
.//SVD/JPEG/jdphuff.cpp:140:    for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
.//SVD/JPEG/jdphuff.cpp:142:      if (cinfo->Ah != expected)
.//SVD/JPEG/jdphuff.cpp:144:      coef_bit_ptr[coefi] = cinfo->Al;
.//SVD/JPEG/jdphuff.cpp:149:  if (cinfo->Ah == 0) {
.//SVD/JPEG/jdphuff.cpp:151:      entropy->pub.decode_mcu = decode_mcu_DC_first;
.//SVD/JPEG/jdphuff.cpp:153:      entropy->pub.decode_mcu = decode_mcu_AC_first;
.//SVD/JPEG/jdphuff.cpp:156:      entropy->pub.decode_mcu = decode_mcu_DC_refine;
.//SVD/JPEG/jdphuff.cpp:158:      entropy->pub.decode_mcu = decode_mcu_AC_refine;
.//SVD/JPEG/jdphuff.cpp:161:  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
.//SVD/JPEG/jdphuff.cpp:162:    compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jdphuff.cpp:167:      if (cinfo->Ah == 0) {	/* DC refinement needs no table */
.//SVD/JPEG/jdphuff.cpp:168:	tbl = compptr->dc_tbl_no;
.//SVD/JPEG/jdphuff.cpp:170:				& entropy->derived_tbls[tbl]);
.//SVD/JPEG/jdphuff.cpp:173:      tbl = compptr->ac_tbl_no;
.//SVD/JPEG/jdphuff.cpp:175:			      & entropy->derived_tbls[tbl]);
.//SVD/JPEG/jdphuff.cpp:177:      entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
.//SVD/JPEG/jdphuff.cpp:180:    entropy->saved.last_dc_val[ci] = 0;
.//SVD/JPEG/jdphuff.cpp:184:  entropy->bitstate.bits_left = 0;
.//SVD/JPEG/jdphuff.cpp:185:  entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
.//SVD/JPEG/jdphuff.cpp:186:  entropy->pub.insufficient_data = FALSE;
.//SVD/JPEG/jdphuff.cpp:189:  entropy->saved.EOBRUN = 0;
.//SVD/JPEG/jdphuff.cpp:192:  entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jdphuff.cpp:203:#define HUFF_EXTEND(x,s)  ((x) < (1<<((s)-1)) ? (x) + (((-1)<<(s)) + 1) : (x))
.//SVD/JPEG/jdphuff.cpp:209:static const int extend_test[16] =   /* entry n is 2**(n-1) */
.//SVD/JPEG/jdphuff.cpp:213:static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
.//SVD/JPEG/jdphuff.cpp:214:  { 0, ((-1)<<1) + 1, ((-1)<<2) + 1, ((-1)<<3) + 1, ((-1)<<4) + 1,
.//SVD/JPEG/jdphuff.cpp:215:    ((-1)<<5) + 1, ((-1)<<6) + 1, ((-1)<<7) + 1, ((-1)<<8) + 1,
.//SVD/JPEG/jdphuff.cpp:216:    ((-1)<<9) + 1, ((-1)<<10) + 1, ((-1)<<11) + 1, ((-1)<<12) + 1,
.//SVD/JPEG/jdphuff.cpp:217:    ((-1)<<13) + 1, ((-1)<<14) + 1, ((-1)<<15) + 1 };
.//SVD/JPEG/jdphuff.cpp:230:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jdphuff.cpp:235:  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
.//SVD/JPEG/jdphuff.cpp:236:  entropy->bitstate.bits_left = 0;
.//SVD/JPEG/jdphuff.cpp:239:  if (! (*cinfo->marker->read_restart_marker) (cinfo))
.//SVD/JPEG/jdphuff.cpp:242:  /* Re-initialize DC predictions to 0 */
.//SVD/JPEG/jdphuff.cpp:243:  for (ci = 0; ci < cinfo->comps_in_scan; ci++)
.//SVD/JPEG/jdphuff.cpp:244:    entropy->saved.last_dc_val[ci] = 0;
.//SVD/JPEG/jdphuff.cpp:245:  /* Re-init EOB run count, too */
.//SVD/JPEG/jdphuff.cpp:246:  entropy->saved.EOBRUN = 0;
.//SVD/JPEG/jdphuff.cpp:249:  entropy->restarts_to_go = cinfo->restart_interval;
.//SVD/JPEG/jdphuff.cpp:251:  /* Reset out-of-data flag, unless read_restart_marker left us smack up
.//SVD/JPEG/jdphuff.cpp:256:  if (cinfo->unread_marker == 0)
.//SVD/JPEG/jdphuff.cpp:257:    entropy->pub.insufficient_data = FALSE;
.//SVD/JPEG/jdphuff.cpp:266: * Huffman-compressed coefficients. 
.//SVD/JPEG/jdphuff.cpp:276: * spectral selection, since we'll just re-assign them on the next call.
.//SVD/JPEG/jdphuff.cpp:288:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jdphuff.cpp:289:  int Al = cinfo->Al;
.//SVD/JPEG/jdphuff.cpp:299:  if (cinfo->restart_interval) {
.//SVD/JPEG/jdphuff.cpp:300:    if (entropy->restarts_to_go == 0)
.//SVD/JPEG/jdphuff.cpp:308:  if (! entropy->pub.insufficient_data) {
.//SVD/JPEG/jdphuff.cpp:311:    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
.//SVD/JPEG/jdphuff.cpp:312:    ASSIGN_STATE(state, entropy->saved);
.//SVD/JPEG/jdphuff.cpp:316:    for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//SVD/JPEG/jdphuff.cpp:318:      ci = cinfo->MCU_membership[blkn];
.//SVD/JPEG/jdphuff.cpp:319:      compptr = cinfo->cur_comp_info[ci];
.//SVD/JPEG/jdphuff.cpp:320:      tbl = entropy->derived_tbls[compptr->dc_tbl_no];
.//SVD/JPEG/jdphuff.cpp:340:    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
.//SVD/JPEG/jdphuff.cpp:341:    ASSIGN_STATE(entropy->saved, state);
.//SVD/JPEG/jdphuff.cpp:344:  /* Account for restart interval (no-op if not using restarts) */
.//SVD/JPEG/jdphuff.cpp:345:  entropy->restarts_to_go--;
.//SVD/JPEG/jdphuff.cpp:359:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jdphuff.cpp:360:  int Se = cinfo->Se;
.//SVD/JPEG/jdphuff.cpp:361:  int Al = cinfo->Al;
.//SVD/JPEG/jdphuff.cpp:369:  if (cinfo->restart_interval) {
.//SVD/JPEG/jdphuff.cpp:370:    if (entropy->restarts_to_go == 0)
.//SVD/JPEG/jdphuff.cpp:378:  if (! entropy->pub.insufficient_data) {
.//SVD/JPEG/jdphuff.cpp:383:    EOBRUN = entropy->saved.EOBRUN;	/* only part of saved state we need */
.//SVD/JPEG/jdphuff.cpp:388:      EOBRUN--;			/* ...process it now (we do nothing) */
.//SVD/JPEG/jdphuff.cpp:390:      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
.//SVD/JPEG/jdphuff.cpp:392:      tbl = entropy->ac_derived_tbl;
.//SVD/JPEG/jdphuff.cpp:394:      for (k = cinfo->Ss; k <= Se; k++) {
.//SVD/JPEG/jdphuff.cpp:415:	    EOBRUN--;		/* this band is processed at this moment */
.//SVD/JPEG/jdphuff.cpp:416:	    break;		/* force end-of-band */
.//SVD/JPEG/jdphuff.cpp:421:      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
.//SVD/JPEG/jdphuff.cpp:425:    entropy->saved.EOBRUN = EOBRUN;	/* only part of saved state we need */
.//SVD/JPEG/jdphuff.cpp:428:  /* Account for restart interval (no-op if not using restarts) */
.//SVD/JPEG/jdphuff.cpp:429:  entropy->restarts_to_go--;
.//SVD/JPEG/jdphuff.cpp:437: * Note: we assume such scans can be multi-component, although the spec
.//SVD/JPEG/jdphuff.cpp:444:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jdphuff.cpp:445:  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
.//SVD/JPEG/jdphuff.cpp:451:  if (cinfo->restart_interval) {
.//SVD/JPEG/jdphuff.cpp:452:    if (entropy->restarts_to_go == 0)
.//SVD/JPEG/jdphuff.cpp:462:  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
.//SVD/JPEG/jdphuff.cpp:466:  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
.//SVD/JPEG/jdphuff.cpp:469:    /* Encoded data is simply the next bit of the two's-complement DC value */
.//SVD/JPEG/jdphuff.cpp:477:  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
.//SVD/JPEG/jdphuff.cpp:479:  /* Account for restart interval (no-op if not using restarts) */
.//SVD/JPEG/jdphuff.cpp:480:  entropy->restarts_to_go--;
.//SVD/JPEG/jdphuff.cpp:493:  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
.//SVD/JPEG/jdphuff.cpp:494:  int Se = cinfo->Se;
.//SVD/JPEG/jdphuff.cpp:495:  int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
.//SVD/JPEG/jdphuff.cpp:496:  int m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
.//SVD/JPEG/jdphuff.cpp:507:  if (cinfo->restart_interval) {
.//SVD/JPEG/jdphuff.cpp:508:    if (entropy->restarts_to_go == 0)
.//SVD/JPEG/jdphuff.cpp:515:  if (! entropy->pub.insufficient_data) {
.//SVD/JPEG/jdphuff.cpp:518:    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
.//SVD/JPEG/jdphuff.cpp:519:    EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */
.//SVD/JPEG/jdphuff.cpp:523:    tbl = entropy->ac_derived_tbl;
.//SVD/JPEG/jdphuff.cpp:528:     * But we need not undo addition of bits to already-nonzero coefficients;
.//SVD/JPEG/jdphuff.cpp:534:    k = cinfo->Ss;
.//SVD/JPEG/jdphuff.cpp:561:	/* Advance over already-nonzero coefs and r still-zero coefs,
.//SVD/JPEG/jdphuff.cpp:578:	    if (--r < 0)
.//SVD/JPEG/jdphuff.cpp:594:      /* Scan any remaining coefficient positions after the end-of-band
.//SVD/JPEG/jdphuff.cpp:596:       * bit to each already-nonzero coefficient.  A correction bit is 1
.//SVD/JPEG/jdphuff.cpp:614:      EOBRUN--;
.//SVD/JPEG/jdphuff.cpp:618:    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
.//SVD/JPEG/jdphuff.cpp:619:    entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */
.//SVD/JPEG/jdphuff.cpp:622:  /* Account for restart interval (no-op if not using restarts) */
.//SVD/JPEG/jdphuff.cpp:623:  entropy->restarts_to_go--;
.//SVD/JPEG/jdphuff.cpp:628:  /* Re-zero any output coefficients that we made newly nonzero */
.//SVD/JPEG/jdphuff.cpp:630:    (*block)[newnz_pos[--num_newnz]] = 0;
.//SVD/JPEG/jdphuff.cpp:648:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdphuff.cpp:650:  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
.//SVD/JPEG/jdphuff.cpp:651:  entropy->pub.start_pass = start_pass_phuff_decoder;
.//SVD/JPEG/jdphuff.cpp:655:    entropy->derived_tbls[i] = NULL;
.//SVD/JPEG/jdphuff.cpp:659:  cinfo->coef_bits = (int (*)[DCTSIZE2])
.//SVD/JPEG/jdphuff.cpp:660:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdphuff.cpp:661:				cinfo->num_components*DCTSIZE2*SIZEOF(int));
.//SVD/JPEG/jdphuff.cpp:662:  coef_bit_ptr = & cinfo->coef_bits[0][0];
.//SVD/JPEG/jdphuff.cpp:663:  for (ci = 0; ci < cinfo->num_components; ci++) 
.//SVD/JPEG/jdphuff.cpp:665:      *coef_bit_ptr++ = -1;
.//SVD/JPEG/jdpostct.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jdpostct.cpp:31:   * For two-pass color quantization, we need a full-image buffer;
.//SVD/JPEG/jdpostct.cpp:32:   * for one-pass operation, a strip buffer is sufficient.
.//SVD/JPEG/jdpostct.cpp:34:  jvirt_sarray_ptr whole_image;	/* virtual array, or NULL if one-pass */
.//SVD/JPEG/jdpostct.cpp:37:  /* for two-pass mode only: */
.//SVD/JPEG/jdpostct.cpp:75:  my_post_ptr post = (my_post_ptr) cinfo->post;
.//SVD/JPEG/jdpostct.cpp:79:    if (cinfo->quantize_colors) {
.//SVD/JPEG/jdpostct.cpp:80:      /* Single-pass processing with color quantization. */
.//SVD/JPEG/jdpostct.cpp:81:      post->pub.post_process_data = post_process_1pass;
.//SVD/JPEG/jdpostct.cpp:82:      /* We could be doing buffered-image output before starting a 2-pass
.//SVD/JPEG/jdpostct.cpp:84:       * allocate a strip buffer.  Use the virtual-array buffer as workspace.
.//SVD/JPEG/jdpostct.cpp:86:      if (post->buffer == NULL) {
.//SVD/JPEG/jdpostct.cpp:87:	post->buffer = (*cinfo->mem->access_virt_sarray)
.//SVD/JPEG/jdpostct.cpp:88:	  ((j_common_ptr) cinfo, post->whole_image,
.//SVD/JPEG/jdpostct.cpp:89:	   (JDIMENSION) 0, post->strip_height, TRUE);
.//SVD/JPEG/jdpostct.cpp:92:      /* For single-pass processing without color quantization,
.//SVD/JPEG/jdpostct.cpp:95:      post->pub.post_process_data = cinfo->upsample->upsample;
.//SVD/JPEG/jdpostct.cpp:100:    /* First pass of 2-pass quantization */
.//SVD/JPEG/jdpostct.cpp:101:    if (post->whole_image == NULL)
.//SVD/JPEG/jdpostct.cpp:103:    post->pub.post_process_data = post_process_prepass;
.//SVD/JPEG/jdpostct.cpp:106:    /* Second pass of 2-pass quantization */
.//SVD/JPEG/jdpostct.cpp:107:    if (post->whole_image == NULL)
.//SVD/JPEG/jdpostct.cpp:109:    post->pub.post_process_data = post_process_2pass;
.//SVD/JPEG/jdpostct.cpp:116:  post->starting_row = post->next_row = 0;
.//SVD/JPEG/jdpostct.cpp:121: * Process some data in the one-pass (strip buffer) case.
.//SVD/JPEG/jdpostct.cpp:122: * This is used for color precision reduction as well as one-pass quantization.
.//SVD/JPEG/jdpostct.cpp:132:  my_post_ptr post = (my_post_ptr) cinfo->post;
.//SVD/JPEG/jdpostct.cpp:137:  max_rows = out_rows_avail - *out_row_ctr;
.//SVD/JPEG/jdpostct.cpp:138:  if (max_rows > post->strip_height)
.//SVD/JPEG/jdpostct.cpp:139:    max_rows = post->strip_height;
.//SVD/JPEG/jdpostct.cpp:141:  (*cinfo->upsample->upsample) (cinfo,
.//SVD/JPEG/jdpostct.cpp:143:		post->buffer, &num_rows, max_rows);
.//SVD/JPEG/jdpostct.cpp:145:  (*cinfo->cquantize->color_quantize) (cinfo,
.//SVD/JPEG/jdpostct.cpp:146:		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
.//SVD/JPEG/jdpostct.cpp:154: * Process some data in the first pass of 2-pass quantization.
.//SVD/JPEG/jdpostct.cpp:164:  my_post_ptr post = (my_post_ptr) cinfo->post;
.//SVD/JPEG/jdpostct.cpp:168:  if (post->next_row == 0) {
.//SVD/JPEG/jdpostct.cpp:169:    post->buffer = (*cinfo->mem->access_virt_sarray)
.//SVD/JPEG/jdpostct.cpp:170:	((j_common_ptr) cinfo, post->whole_image,
.//SVD/JPEG/jdpostct.cpp:171:	 post->starting_row, post->strip_height, TRUE);
.//SVD/JPEG/jdpostct.cpp:175:  old_next_row = post->next_row;
.//SVD/JPEG/jdpostct.cpp:176:  (*cinfo->upsample->upsample) (cinfo,
.//SVD/JPEG/jdpostct.cpp:178:		post->buffer, &post->next_row, post->strip_height);
.//SVD/JPEG/jdpostct.cpp:182:  if (post->next_row > old_next_row) {
.//SVD/JPEG/jdpostct.cpp:183:    num_rows = post->next_row - old_next_row;
.//SVD/JPEG/jdpostct.cpp:184:    (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
.//SVD/JPEG/jdpostct.cpp:190:  if (post->next_row >= post->strip_height) {
.//SVD/JPEG/jdpostct.cpp:191:    post->starting_row += post->strip_height;
.//SVD/JPEG/jdpostct.cpp:192:    post->next_row = 0;
.//SVD/JPEG/jdpostct.cpp:198: * Process some data in the second pass of 2-pass quantization.
.//SVD/JPEG/jdpostct.cpp:208:  my_post_ptr post = (my_post_ptr) cinfo->post;
.//SVD/JPEG/jdpostct.cpp:212:  if (post->next_row == 0) {
.//SVD/JPEG/jdpostct.cpp:213:    post->buffer = (*cinfo->mem->access_virt_sarray)
.//SVD/JPEG/jdpostct.cpp:214:	((j_common_ptr) cinfo, post->whole_image,
.//SVD/JPEG/jdpostct.cpp:215:	 post->starting_row, post->strip_height, FALSE);
.//SVD/JPEG/jdpostct.cpp:219:  num_rows = post->strip_height - post->next_row; /* available in strip */
.//SVD/JPEG/jdpostct.cpp:220:  max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
.//SVD/JPEG/jdpostct.cpp:224:  max_rows = cinfo->output_height - post->starting_row;
.//SVD/JPEG/jdpostct.cpp:229:  (*cinfo->cquantize->color_quantize) (cinfo,
.//SVD/JPEG/jdpostct.cpp:230:		post->buffer + post->next_row, output_buf + *out_row_ctr,
.//SVD/JPEG/jdpostct.cpp:235:  post->next_row += num_rows;
.//SVD/JPEG/jdpostct.cpp:236:  if (post->next_row >= post->strip_height) {
.//SVD/JPEG/jdpostct.cpp:237:    post->starting_row += post->strip_height;
.//SVD/JPEG/jdpostct.cpp:238:    post->next_row = 0;
.//SVD/JPEG/jdpostct.cpp:255:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdpostct.cpp:257:  cinfo->post = (struct jpeg_d_post_controller *) post;
.//SVD/JPEG/jdpostct.cpp:258:  post->pub.start_pass = start_pass_dpost;
.//SVD/JPEG/jdpostct.cpp:259:  post->whole_image = NULL;	/* flag for no virtual arrays */
.//SVD/JPEG/jdpostct.cpp:260:  post->buffer = NULL;		/* flag for no strip buffer */
.//SVD/JPEG/jdpostct.cpp:263:  if (cinfo->quantize_colors) {
.//SVD/JPEG/jdpostct.cpp:268:    post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
.//SVD/JPEG/jdpostct.cpp:270:      /* Two-pass color quantization: need full-image storage. */
.//SVD/JPEG/jdpostct.cpp:273:      post->whole_image = (*cinfo->mem->request_virt_sarray)
.//SVD/JPEG/jdpostct.cpp:275:	 cinfo->output_width * cinfo->out_color_components,
.//SVD/JPEG/jdpostct.cpp:276:	 (JDIMENSION) jround_up((long) cinfo->output_height,
.//SVD/JPEG/jdpostct.cpp:277:				(long) post->strip_height),
.//SVD/JPEG/jdpostct.cpp:278:	 post->strip_height);
.//SVD/JPEG/jdpostct.cpp:283:      /* One-pass color quantization: just make a strip buffer. */
.//SVD/JPEG/jdpostct.cpp:284:      post->buffer = (*cinfo->mem->alloc_sarray)
.//SVD/JPEG/jdpostct.cpp:286:	 cinfo->output_width * cinfo->out_color_components,
.//SVD/JPEG/jdpostct.cpp:287:	 post->strip_height);
.//SVD/JPEG/jdsample.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//SVD/JPEG/jdsample.cpp:18: *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.
.//SVD/JPEG/jdsample.cpp:39:   * Note: we do not allocate any storage for component(s) which are full-size,
.//SVD/JPEG/jdsample.cpp:45:  /* Per-component upsampling method pointers */
.//SVD/JPEG/jdsample.cpp:71:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//SVD/JPEG/jdsample.cpp:74:  upsample->next_row_out = cinfo->max_v_samp_factor;
.//SVD/JPEG/jdsample.cpp:75:  /* Initialize total-height counter for detecting bottom of image */
.//SVD/JPEG/jdsample.cpp:76:  upsample->rows_to_go = cinfo->output_height;
.//SVD/JPEG/jdsample.cpp:95:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//SVD/JPEG/jdsample.cpp:101:  if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
.//SVD/JPEG/jdsample.cpp:102:    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdsample.cpp:104:      /* Invoke per-component upsample method.  Notice we pass a POINTER
.//SVD/JPEG/jdsample.cpp:107:      (*upsample->methods[ci]) (cinfo, compptr,
.//SVD/JPEG/jdsample.cpp:108:	input_buf[ci] + (*in_row_group_ctr * upsample->rowgroup_height[ci]),
.//SVD/JPEG/jdsample.cpp:109:	upsample->color_buf + ci);
.//SVD/JPEG/jdsample.cpp:111:    upsample->next_row_out = 0;
.//SVD/JPEG/jdsample.cpp:114:  /* Color-convert and emit rows */
.//SVD/JPEG/jdsample.cpp:117:  num_rows = (JDIMENSION) (cinfo->max_v_samp_factor - upsample->next_row_out);
.//SVD/JPEG/jdsample.cpp:121:  if (num_rows > upsample->rows_to_go) 
.//SVD/JPEG/jdsample.cpp:122:    num_rows = upsample->rows_to_go;
.//SVD/JPEG/jdsample.cpp:124:  out_rows_avail -= *out_row_ctr;
.//SVD/JPEG/jdsample.cpp:128:  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
.//SVD/JPEG/jdsample.cpp:129:				     (JDIMENSION) upsample->next_row_out,
.//SVD/JPEG/jdsample.cpp:135:  upsample->rows_to_go -= num_rows;
.//SVD/JPEG/jdsample.cpp:136:  upsample->next_row_out += num_rows;
.//SVD/JPEG/jdsample.cpp:138:  if (upsample->next_row_out >= cinfo->max_v_samp_factor)
.//SVD/JPEG/jdsample.cpp:150: * For full-size components, we just make color_buf[ci] point at the
.//SVD/JPEG/jdsample.cpp:165: * This is a no-op version used for "uninteresting" components.
.//SVD/JPEG/jdsample.cpp:182: * pixels.  The hi-falutin sampling literature refers to this as a
.//SVD/JPEG/jdsample.cpp:192:  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
.//SVD/JPEG/jdsample.cpp:201:  h_expand = upsample->h_expand[compptr->component_index];
.//SVD/JPEG/jdsample.cpp:202:  v_expand = upsample->v_expand[compptr->component_index];
.//SVD/JPEG/jdsample.cpp:205:  while (outrow < cinfo->max_v_samp_factor) {
.//SVD/JPEG/jdsample.cpp:209:    outend = outptr + cinfo->output_width;
.//SVD/JPEG/jdsample.cpp:212:      for (h = h_expand; h > 0; h--) {
.//SVD/JPEG/jdsample.cpp:219:			v_expand-1, cinfo->output_width);
.//SVD/JPEG/jdsample.cpp:242:  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
.//SVD/JPEG/jdsample.cpp:245:    outend = outptr + cinfo->output_width;
.//SVD/JPEG/jdsample.cpp:271:  while (outrow < cinfo->max_v_samp_factor) {
.//SVD/JPEG/jdsample.cpp:274:    outend = outptr + cinfo->output_width;
.//SVD/JPEG/jdsample.cpp:281:		      1, cinfo->output_width);
.//SVD/JPEG/jdsample.cpp:313:  for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
.//SVD/JPEG/jdsample.cpp:321:    for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
.//SVD/JPEG/jdsample.cpp:324:      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(inptr[-2]) + 1) >> 2);
.//SVD/JPEG/jdsample.cpp:330:    *outptr++ = (JSAMPLE) ((invalue * 3 + GETJSAMPLE(inptr[-1]) + 1) >> 2);
.//SVD/JPEG/jdsample.cpp:359:  while (outrow < cinfo->max_v_samp_factor) {
.//SVD/JPEG/jdsample.cpp:364:	inptr1 = input_data[inrow-1];
.//SVD/JPEG/jdsample.cpp:376:      for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
.//SVD/JPEG/jdsample.cpp:408:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jdsample.cpp:410:  cinfo->upsample = (struct jpeg_upsampler *) upsample;
.//SVD/JPEG/jdsample.cpp:411:  upsample->pub.start_pass = start_pass_upsample;
.//SVD/JPEG/jdsample.cpp:412:  upsample->pub.upsample = sep_upsample;
.//SVD/JPEG/jdsample.cpp:413:  upsample->pub.need_context_rows = FALSE; /* until we find out differently */
.//SVD/JPEG/jdsample.cpp:415:  if (cinfo->CCIR601_sampling)	/* this isn't supported */
.//SVD/JPEG/jdsample.cpp:421:  do_fancy = cinfo->do_fancy_upsampling && cinfo->min_DCT_scaled_size > 1;
.//SVD/JPEG/jdsample.cpp:423:  /* Verify we can handle the sampling factors, select per-component methods,
.//SVD/JPEG/jdsample.cpp:426:  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
.//SVD/JPEG/jdsample.cpp:431:    h_in_group = (compptr->h_samp_factor * compptr->DCT_scaled_size) /
.//SVD/JPEG/jdsample.cpp:432:		 cinfo->min_DCT_scaled_size;
.//SVD/JPEG/jdsample.cpp:433:    v_in_group = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
.//SVD/JPEG/jdsample.cpp:434:		 cinfo->min_DCT_scaled_size;
.//SVD/JPEG/jdsample.cpp:435:    h_out_group = cinfo->max_h_samp_factor;
.//SVD/JPEG/jdsample.cpp:436:    v_out_group = cinfo->max_v_samp_factor;
.//SVD/JPEG/jdsample.cpp:437:    upsample->rowgroup_height[ci] = v_in_group; /* save for use later */
.//SVD/JPEG/jdsample.cpp:439:    if (! compptr->component_needed) {
.//SVD/JPEG/jdsample.cpp:441:      upsample->methods[ci] = noop_upsample;
.//SVD/JPEG/jdsample.cpp:445:      upsample->methods[ci] = fullsize_upsample;
.//SVD/JPEG/jdsample.cpp:450:      if (do_fancy && compptr->downsampled_width > 2)
.//SVD/JPEG/jdsample.cpp:451:	upsample->methods[ci] = h2v1_fancy_upsample;
.//SVD/JPEG/jdsample.cpp:453:	upsample->methods[ci] = h2v1_upsample;
.//SVD/JPEG/jdsample.cpp:457:      if (do_fancy && compptr->downsampled_width > 2) {
.//SVD/JPEG/jdsample.cpp:458:	upsample->methods[ci] = h2v2_fancy_upsample;
.//SVD/JPEG/jdsample.cpp:459:	upsample->pub.need_context_rows = TRUE;
.//SVD/JPEG/jdsample.cpp:461:	upsample->methods[ci] = h2v2_upsample;
.//SVD/JPEG/jdsample.cpp:464:      /* Generic integral-factors upsampling method */
.//SVD/JPEG/jdsample.cpp:465:      upsample->methods[ci] = int_upsample;
.//SVD/JPEG/jdsample.cpp:466:      upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);
.//SVD/JPEG/jdsample.cpp:467:      upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);
.//SVD/JPEG/jdsample.cpp:471:      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
.//SVD/JPEG/jdsample.cpp:473:	 (JDIMENSION) jround_up((long) cinfo->output_width,
.//SVD/JPEG/jdsample.cpp:474:				(long) cinfo->max_h_samp_factor),
.//SVD/JPEG/jdsample.cpp:475:	 (JDIMENSION) cinfo->max_v_samp_factor);
.//SVD/JPEG/jdtrans.cpp:4: * Copyright (C) 1995-1997, Thomas G. Lane.
.//SVD/JPEG/jdtrans.cpp:26: * The entire image is read into a set of virtual coefficient-block arrays,
.//SVD/JPEG/jdtrans.cpp:28: * virtual-array descriptors.  These can be manipulated directly via the
.//SVD/JPEG/jdtrans.cpp:34: * during a buffered-image-mode decompression operation.  This is allowed
.//SVD/JPEG/jdtrans.cpp:47:  if (cinfo->global_state == DSTATE_READY) {
.//SVD/JPEG/jdtrans.cpp:50:    cinfo->global_state = DSTATE_RDCOEFS;
.//SVD/JPEG/jdtrans.cpp:52:  if (cinfo->global_state == DSTATE_RDCOEFS) {
.//SVD/JPEG/jdtrans.cpp:57:      if (cinfo->progress != NULL)
.//SVD/JPEG/jdtrans.cpp:58:	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
.//SVD/JPEG/jdtrans.cpp:60:      retcode = (*cinfo->inputctl->consume_input) (cinfo);
.//SVD/JPEG/jdtrans.cpp:66:      if (cinfo->progress != NULL &&
.//SVD/JPEG/jdtrans.cpp:68:	if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
.//SVD/JPEG/jdtrans.cpp:70:	  cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
.//SVD/JPEG/jdtrans.cpp:75:    cinfo->global_state = DSTATE_STOPPING;
.//SVD/JPEG/jdtrans.cpp:79:   * to the coefficients during a full buffered-image-mode decompression.
.//SVD/JPEG/jdtrans.cpp:81:  if ((cinfo->global_state == DSTATE_STOPPING ||
.//SVD/JPEG/jdtrans.cpp:82:       cinfo->global_state == DSTATE_BUFIMAGE) && cinfo->buffered_image) {
.//SVD/JPEG/jdtrans.cpp:83:    return cinfo->coef->coef_arrays;
.//SVD/JPEG/jdtrans.cpp:86:  ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
.//SVD/JPEG/jdtrans.cpp:99:  /* This is effectively a buffered-image operation. */
.//SVD/JPEG/jdtrans.cpp:100:  cinfo->buffered_image = TRUE;
.//SVD/JPEG/jdtrans.cpp:103:  if (cinfo->arith_code) {
.//SVD/JPEG/jdtrans.cpp:106:    if (cinfo->progressive_mode) {
.//SVD/JPEG/jdtrans.cpp:116:  /* Always get a full-image coefficient buffer. */
.//SVD/JPEG/jdtrans.cpp:120:  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
.//SVD/JPEG/jdtrans.cpp:123:  (*cinfo->inputctl->start_input_pass) (cinfo);
.//SVD/JPEG/jdtrans.cpp:126:  if (cinfo->progress != NULL) {
.//SVD/JPEG/jdtrans.cpp:129:    if (cinfo->progressive_mode) {
.//SVD/JPEG/jdtrans.cpp:131:      nscans = 2 + 3 * cinfo->num_components;
.//SVD/JPEG/jdtrans.cpp:132:    } else if (cinfo->inputctl->has_multiple_scans) {
.//SVD/JPEG/jdtrans.cpp:134:      nscans = cinfo->num_components;
.//SVD/JPEG/jdtrans.cpp:138:    cinfo->progress->pass_counter = 0L;
.//SVD/JPEG/jdtrans.cpp:139:    cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
.//SVD/JPEG/jdtrans.cpp:140:    cinfo->progress->completed_passes = 0;
.//SVD/JPEG/jdtrans.cpp:141:    cinfo->progress->total_passes = 1;
.//SVD/JPEG/jerror.cpp:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//SVD/JPEG/jerror.cpp:8: * This file contains simple error-reporting and trace-message routines.
.//SVD/JPEG/jerror.cpp:9: * These are suitable for Unix-like systems and others where writing to
.//SVD/JPEG/jerror.cpp:14: * you get a Windows-specific hack to display error messages in a dialog box.
.//SVD/JPEG/jerror.cpp:38: * We do this from the master message list in jerror.h by re-reading
.//SVD/JPEG/jerror.cpp:73:  (*cinfo->err->output_message) (cinfo);
.//SVD/JPEG/jerror.cpp:88: * so we provide optional code to produce an error-dialog popup.
.//SVD/JPEG/jerror.cpp:103:  (*cinfo->err->format_message) (cinfo, buffer);
.//SVD/JPEG/jerror.cpp:119: *   -1: recoverable corrupt-data warning, may want to abort.
.//SVD/JPEG/jerror.cpp:130:  struct jpeg_error_mgr * err = cinfo->err;
.//SVD/JPEG/jerror.cpp:137:    if (err->num_warnings == 0 || err->trace_level >= 3)
.//SVD/JPEG/jerror.cpp:138:      (*err->output_message) (cinfo);
.//SVD/JPEG/jerror.cpp:140:    err->num_warnings++;
.//SVD/JPEG/jerror.cpp:143:    if (err->trace_level >= msg_level)
.//SVD/JPEG/jerror.cpp:144:      (*err->output_message) (cinfo);
.//SVD/JPEG/jerror.cpp:159:  struct jpeg_error_mgr * err = cinfo->err;
.//SVD/JPEG/jerror.cpp:160:  int msg_code = err->msg_code;
.//SVD/JPEG/jerror.cpp:167:  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
.//SVD/JPEG/jerror.cpp:168:    msgtext = err->jpeg_message_table[msg_code];
.//SVD/JPEG/jerror.cpp:169:  } else if (err->addon_message_table != NULL &&
.//SVD/JPEG/jerror.cpp:170:	     msg_code >= err->first_addon_message &&
.//SVD/JPEG/jerror.cpp:171:	     msg_code <= err->last_addon_message) {
.//SVD/JPEG/jerror.cpp:172:    msgtext = err->addon_message_table[msg_code - err->first_addon_message];
.//SVD/JPEG/jerror.cpp:177:    err->msg_parm.i[0] = msg_code;
.//SVD/JPEG/jerror.cpp:178:    msgtext = err->jpeg_message_table[0];
.//SVD/JPEG/jerror.cpp:193:    sprintf(buffer, msgtext, err->msg_parm.s);
.//SVD/JPEG/jerror.cpp:196:	    err->msg_parm.i[0], err->msg_parm.i[1],
.//SVD/JPEG/jerror.cpp:197:	    err->msg_parm.i[2], err->msg_parm.i[3],
.//SVD/JPEG/jerror.cpp:198:	    err->msg_parm.i[4], err->msg_parm.i[5],
.//SVD/JPEG/jerror.cpp:199:	    err->msg_parm.i[6], err->msg_parm.i[7]);
.//SVD/JPEG/jerror.cpp:206: * processing to default state, without losing any application-specific
.//SVD/JPEG/jerror.cpp:214:  cinfo->err->num_warnings = 0;
.//SVD/JPEG/jerror.cpp:215:  /* trace_level is not reset since it is an application-supplied parameter */
.//SVD/JPEG/jerror.cpp:216:  cinfo->err->msg_code = 0;	/* may be useful as a flag for "no error" */
.//SVD/JPEG/jerror.cpp:221: * Fill in the standard error-handling methods in a jpeg_error_mgr object.
.//SVD/JPEG/jerror.cpp:233:  err->error_exit = error_exit;
.//SVD/JPEG/jerror.cpp:234:  err->emit_message = emit_message;
.//SVD/JPEG/jerror.cpp:235:  err->output_message = output_message;
.//SVD/JPEG/jerror.cpp:236:  err->format_message = format_message;
.//SVD/JPEG/jerror.cpp:237:  err->reset_error_mgr = reset_error_mgr;
.//SVD/JPEG/jerror.cpp:239:  err->trace_level = 0;		/* default = no tracing */
.//SVD/JPEG/jerror.cpp:240:  err->num_warnings = 0;	/* no warnings emitted yet */
.//SVD/JPEG/jerror.cpp:241:  err->msg_code = 0;		/* may be useful as a flag for "no error" */
.//SVD/JPEG/jerror.cpp:244:  err->jpeg_message_table = jpeg_std_message_table;
.//SVD/JPEG/jerror.cpp:245:  err->last_jpeg_message = (int) JMSG_LASTMSGCODE - 1;
.//SVD/JPEG/jerror.cpp:247:  err->addon_message_table = NULL;
.//SVD/JPEG/jerror.cpp:248:  err->first_addon_message = 0;	/* for safety */
.//SVD/JPEG/jerror.cpp:249:  err->last_addon_message = 0;
.//SVD/JPEG/jerror.h:4: * Copyright (C) 1994-1997, Thomas G. Lane.
.//SVD/JPEG/jerror.h:11: * A set of error-reporting macros are defined too.  Some applications using
.//SVD/JPEG/jerror.h:26:/* Repeated inclusions of this file are no-ops unless JMESSAGE is defined */
.//SVD/JPEG/jerror.h:83:JMESSAGE(JERR_FILE_WRITE, "Output file write error --- out of disk space?")
.//SVD/JPEG/jerror.h:115:	 "Write failed on temporary file --- out of disk space?")
.//SVD/JPEG/jerror.h:163:	 "JFIF extension marker: JPEG-compressed thumbnail image, length %u")
.//SVD/JPEG/jerror.h:194:/* Zap JMESSAGE macro so that future re-inclusions do nothing by default */
.//SVD/JPEG/jerror.h:206:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:207:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//SVD/JPEG/jerror.h:209:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:210:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//SVD/JPEG/jerror.h:211:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//SVD/JPEG/jerror.h:213:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:214:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//SVD/JPEG/jerror.h:215:   (cinfo)->err->msg_parm.i[1] = (p2), \
.//SVD/JPEG/jerror.h:216:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//SVD/JPEG/jerror.h:218:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:219:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//SVD/JPEG/jerror.h:220:   (cinfo)->err->msg_parm.i[1] = (p2), \
.//SVD/JPEG/jerror.h:221:   (cinfo)->err->msg_parm.i[2] = (p3), \
.//SVD/JPEG/jerror.h:222:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//SVD/JPEG/jerror.h:224:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:225:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//SVD/JPEG/jerror.h:226:   (cinfo)->err->msg_parm.i[1] = (p2), \
.//SVD/JPEG/jerror.h:227:   (cinfo)->err->msg_parm.i[2] = (p3), \
.//SVD/JPEG/jerror.h:228:   (cinfo)->err->msg_parm.i[3] = (p4), \
.//SVD/JPEG/jerror.h:229:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//SVD/JPEG/jerror.h:231:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:232:   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
.//SVD/JPEG/jerror.h:233:   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
.//SVD/JPEG/jerror.h:239:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:240:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
.//SVD/JPEG/jerror.h:242:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:243:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//SVD/JPEG/jerror.h:244:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
.//SVD/JPEG/jerror.h:246:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:247:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//SVD/JPEG/jerror.h:248:   (cinfo)->err->msg_parm.i[1] = (p2), \
.//SVD/JPEG/jerror.h:249:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
.//SVD/JPEG/jerror.h:253:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:254:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
.//SVD/JPEG/jerror.h:256:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:257:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//SVD/JPEG/jerror.h:258:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
.//SVD/JPEG/jerror.h:260:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:261:   (cinfo)->err->msg_parm.i[0] = (p1), \
.//SVD/JPEG/jerror.h:262:   (cinfo)->err->msg_parm.i[1] = (p2), \
.//SVD/JPEG/jerror.h:263:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
.//SVD/JPEG/jerror.h:265:  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
.//SVD/JPEG/jerror.h:267:	   (cinfo)->err->msg_code = (code); \
.//SVD/JPEG/jerror.h:268:	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
.//SVD/JPEG/jerror.h:270:  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
.//SVD/JPEG/jerror.h:272:	   (cinfo)->err->msg_code = (code); \
.//SVD/JPEG/jerror.h:273:	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
.//SVD/JPEG/jerror.h:275:  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
.//SVD/JPEG/jerror.h:278:	   (cinfo)->err->msg_code = (code); \
.//SVD/JPEG/jerror.h:279:	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
.//SVD/JPEG/jerror.h:281:  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
.//SVD/JPEG/jerror.h:284:	   (cinfo)->err->msg_code = (code); \
.//SVD/JPEG/jerror.h:285:	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
.//SVD/JPEG/jerror.h:287:  ((cinfo)->err->msg_code = (code), \
.//SVD/JPEG/jerror.h:288:   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
.//SVD/JPEG/jerror.h:289:   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
.//SVD/JPEG/jfdctflt.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jfdctflt.cpp:8: * This file contains a floating-point implementation of the
.//SVD/JPEG/jfdctflt.cpp:16: * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
.//SVD/JPEG/jfdctflt.cpp:21: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
.//SVD/JPEG/jfdctflt.cpp:24: * is based directly on figure 4-8 in P&M.
.//SVD/JPEG/jfdctflt.cpp:25: * While an 8-point DCT cannot be done in less than 11 multiplies, it is
.//SVD/JPEG/jfdctflt.cpp:31: * The primary disadvantage of this method is that with a fixed-point
.//SVD/JPEG/jfdctflt.cpp:70:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//SVD/JPEG/jfdctflt.cpp:72:    tmp7 = dataptr[0] - dataptr[7];
.//SVD/JPEG/jfdctflt.cpp:74:    tmp6 = dataptr[1] - dataptr[6];
.//SVD/JPEG/jfdctflt.cpp:76:    tmp5 = dataptr[2] - dataptr[5];
.//SVD/JPEG/jfdctflt.cpp:78:    tmp4 = dataptr[3] - dataptr[4];
.//SVD/JPEG/jfdctflt.cpp:83:    tmp13 = tmp0 - tmp3;
.//SVD/JPEG/jfdctflt.cpp:85:    tmp12 = tmp1 - tmp2;
.//SVD/JPEG/jfdctflt.cpp:88:    dataptr[4] = tmp10 - tmp11;
.//SVD/JPEG/jfdctflt.cpp:92:    dataptr[6] = tmp13 - z1;
.//SVD/JPEG/jfdctflt.cpp:100:    /* The rotator is modified from fig 4-8 to avoid extra negations. */
.//SVD/JPEG/jfdctflt.cpp:101:    z5 = (tmp10 - tmp12) * ((FAST_FLOAT) 0.382683433); /* c6 */
.//SVD/JPEG/jfdctflt.cpp:102:    z2 = ((FAST_FLOAT) 0.541196100) * tmp10 + z5; /* c2-c6 */
.//SVD/JPEG/jfdctflt.cpp:107:    z13 = tmp7 - z3;
.//SVD/JPEG/jfdctflt.cpp:110:    dataptr[3] = z13 - z2;
.//SVD/JPEG/jfdctflt.cpp:112:    dataptr[7] = z11 - z4;
.//SVD/JPEG/jfdctflt.cpp:120:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//SVD/JPEG/jfdctflt.cpp:122:    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];
.//SVD/JPEG/jfdctflt.cpp:124:    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];
.//SVD/JPEG/jfdctflt.cpp:126:    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];
.//SVD/JPEG/jfdctflt.cpp:128:    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];
.//SVD/JPEG/jfdctflt.cpp:133:    tmp13 = tmp0 - tmp3;
.//SVD/JPEG/jfdctflt.cpp:135:    tmp12 = tmp1 - tmp2;
.//SVD/JPEG/jfdctflt.cpp:138:    dataptr[DCTSIZE*4] = tmp10 - tmp11;
.//SVD/JPEG/jfdctflt.cpp:142:    dataptr[DCTSIZE*6] = tmp13 - z1;
.//SVD/JPEG/jfdctflt.cpp:150:    /* The rotator is modified from fig 4-8 to avoid extra negations. */
.//SVD/JPEG/jfdctflt.cpp:151:    z5 = (tmp10 - tmp12) * ((FAST_FLOAT) 0.382683433); /* c6 */
.//SVD/JPEG/jfdctflt.cpp:152:    z2 = ((FAST_FLOAT) 0.541196100) * tmp10 + z5; /* c2-c6 */
.//SVD/JPEG/jfdctflt.cpp:157:    z13 = tmp7 - z3;
.//SVD/JPEG/jfdctflt.cpp:160:    dataptr[DCTSIZE*3] = z13 - z2;
.//SVD/JPEG/jfdctflt.cpp:162:    dataptr[DCTSIZE*7] = z11 - z4;
.//SVD/JPEG/jfdctfst.cpp:4: * Copyright (C) 1994-1996, Thomas G. Lane.
.//SVD/JPEG/jfdctfst.cpp:11: * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
.//SVD/JPEG/jfdctfst.cpp:16: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
.//SVD/JPEG/jfdctfst.cpp:19: * is based directly on figure 4-8 in P&M.
.//SVD/JPEG/jfdctfst.cpp:20: * While an 8-point DCT cannot be done in less than 11 multiplies, it is
.//SVD/JPEG/jfdctfst.cpp:26: * The primary disadvantage of this method is that with fixed-point math,
.//SVD/JPEG/jfdctfst.cpp:29: * precise the scaled value, so this implementation does worse with high-
.//SVD/JPEG/jfdctfst.cpp:30: * quality-setting files than with low-quality ones.
.//SVD/JPEG/jfdctfst.cpp:55: * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
.//SVD/JPEG/jfdctfst.cpp:57: * of work on 16-bit-int machines.
.//SVD/JPEG/jfdctfst.cpp:65: * are fewer one-bits in the constants).
.//SVD/JPEG/jfdctfst.cpp:72: * causing a lot of useless floating-point operations at run time.
.//SVD/JPEG/jfdctfst.cpp:73: * To get around this we use the following pre-calculated constants.
.//SVD/JPEG/jfdctfst.cpp:126:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//SVD/JPEG/jfdctfst.cpp:128:    tmp7 = dataptr[0] - dataptr[7];
.//SVD/JPEG/jfdctfst.cpp:130:    tmp6 = dataptr[1] - dataptr[6];
.//SVD/JPEG/jfdctfst.cpp:132:    tmp5 = dataptr[2] - dataptr[5];
.//SVD/JPEG/jfdctfst.cpp:134:    tmp4 = dataptr[3] - dataptr[4];
.//SVD/JPEG/jfdctfst.cpp:139:    tmp13 = tmp0 - tmp3;
.//SVD/JPEG/jfdctfst.cpp:141:    tmp12 = tmp1 - tmp2;
.//SVD/JPEG/jfdctfst.cpp:144:    dataptr[4] = tmp10 - tmp11;
.//SVD/JPEG/jfdctfst.cpp:148:    dataptr[6] = tmp13 - z1;
.//SVD/JPEG/jfdctfst.cpp:156:    /* The rotator is modified from fig 4-8 to avoid extra negations. */
.//SVD/JPEG/jfdctfst.cpp:157:    z5 = MULTIPLY(tmp10 - tmp12, FIX_0_382683433); /* c6 */
.//SVD/JPEG/jfdctfst.cpp:158:    z2 = MULTIPLY(tmp10, FIX_0_541196100) + z5; /* c2-c6 */
.//SVD/JPEG/jfdctfst.cpp:163:    z13 = tmp7 - z3;
.//SVD/JPEG/jfdctfst.cpp:166:    dataptr[3] = z13 - z2;
.//SVD/JPEG/jfdctfst.cpp:168:    dataptr[7] = z11 - z4;
.//SVD/JPEG/jfdctfst.cpp:176:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//SVD/JPEG/jfdctfst.cpp:178:    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];
.//SVD/JPEG/jfdctfst.cpp:180:    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];
.//SVD/JPEG/jfdctfst.cpp:182:    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];
.//SVD/JPEG/jfdctfst.cpp:184:    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];
.//SVD/JPEG/jfdctfst.cpp:189:    tmp13 = tmp0 - tmp3;
.//SVD/JPEG/jfdctfst.cpp:191:    tmp12 = tmp1 - tmp2;
.//SVD/JPEG/jfdctfst.cpp:194:    dataptr[DCTSIZE*4] = tmp10 - tmp11;
.//SVD/JPEG/jfdctfst.cpp:198:    dataptr[DCTSIZE*6] = tmp13 - z1;
.//SVD/JPEG/jfdctfst.cpp:206:    /* The rotator is modified from fig 4-8 to avoid extra negations. */
.//SVD/JPEG/jfdctfst.cpp:207:    z5 = MULTIPLY(tmp10 - tmp12, FIX_0_382683433); /* c6 */
.//SVD/JPEG/jfdctfst.cpp:208:    z2 = MULTIPLY(tmp10, FIX_0_541196100) + z5; /* c2-c6 */
.//SVD/JPEG/jfdctfst.cpp:213:    z13 = tmp7 - z3;
.//SVD/JPEG/jfdctfst.cpp:216:    dataptr[DCTSIZE*3] = z13 - z2;
.//SVD/JPEG/jfdctfst.cpp:218:    dataptr[DCTSIZE*7] = z11 - z4;
.//SVD/JPEG/jfdctint.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//SVD/JPEG/jfdctint.cpp:8: * This file contains a slow-but-accurate integer implementation of the
.//SVD/JPEG/jfdctint.cpp:11: * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
.//SVD/JPEG/jfdctint.cpp:16: *   C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
.//SVD/JPEG/jfdctint.cpp:18: *   Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
.//SVD/JPEG/jfdctint.cpp:23: * scaled fixed-point arithmetic, with a minimal number of shifts.
.//SVD/JPEG/jfdctint.cpp:46: * Each 1-D DCT step produces outputs which are a factor of sqrt(N)
.//SVD/JPEG/jfdctint.cpp:50: * this arrangement is that we save two multiplications per 1-D DCT,
.//SVD/JPEG/jfdctint.cpp:67: * they are represented to better-than-integral precision.  These outputs
.//SVD/JPEG/jfdctint.cpp:68: * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word
.//SVD/JPEG/jfdctint.cpp:69: * with the recommended scaling.  (For 12-bit sample data, the intermediate
.//SVD/JPEG/jfdctint.cpp:72: * To avoid overflow of the 32-bit intermediate results in pass 2, we must
.//SVD/JPEG/jfdctint.cpp:86: * causing a lot of useless floating-point operations at run time.
.//SVD/JPEG/jfdctint.cpp:87: * To get around this we use the following pre-calculated constants.
.//SVD/JPEG/jfdctint.cpp:122: * For 8-bit samples with the recommended scaling, all the variable
.//SVD/JPEG/jfdctint.cpp:124: * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.
.//SVD/JPEG/jfdctint.cpp:125: * For 12-bit samples, a full 32-bit multiplication will be needed.
.//SVD/JPEG/jfdctint.cpp:154:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//SVD/JPEG/jfdctint.cpp:156:    tmp7 = dataptr[0] - dataptr[7];
.//SVD/JPEG/jfdctint.cpp:158:    tmp6 = dataptr[1] - dataptr[6];
.//SVD/JPEG/jfdctint.cpp:160:    tmp5 = dataptr[2] - dataptr[5];
.//SVD/JPEG/jfdctint.cpp:162:    tmp4 = dataptr[3] - dataptr[4];
.//SVD/JPEG/jfdctint.cpp:164:    /* Even part per LL&M figure 1 --- note that published figure is faulty;
.//SVD/JPEG/jfdctint.cpp:169:    tmp13 = tmp0 - tmp3;
.//SVD/JPEG/jfdctint.cpp:171:    tmp12 = tmp1 - tmp2;
.//SVD/JPEG/jfdctint.cpp:174:    dataptr[4] = (DCTELEM) ((tmp10 - tmp11) << PASS1_BITS);
.//SVD/JPEG/jfdctint.cpp:178:				   CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jfdctint.cpp:179:    dataptr[6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),
.//SVD/JPEG/jfdctint.cpp:180:				   CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jfdctint.cpp:182:    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).
.//SVD/JPEG/jfdctint.cpp:193:    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
.//SVD/JPEG/jfdctint.cpp:194:    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
.//SVD/JPEG/jfdctint.cpp:195:    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
.//SVD/JPEG/jfdctint.cpp:196:    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
.//SVD/JPEG/jfdctint.cpp:197:    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
.//SVD/JPEG/jfdctint.cpp:198:    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
.//SVD/JPEG/jfdctint.cpp:199:    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
.//SVD/JPEG/jfdctint.cpp:200:    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
.//SVD/JPEG/jfdctint.cpp:205:    dataptr[7] = (DCTELEM) DESCALE(tmp4 + z1 + z3, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jfdctint.cpp:206:    dataptr[5] = (DCTELEM) DESCALE(tmp5 + z2 + z4, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jfdctint.cpp:207:    dataptr[3] = (DCTELEM) DESCALE(tmp6 + z2 + z3, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jfdctint.cpp:208:    dataptr[1] = (DCTELEM) DESCALE(tmp7 + z1 + z4, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jfdctint.cpp:219:  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {
.//SVD/JPEG/jfdctint.cpp:221:    tmp7 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*7];
.//SVD/JPEG/jfdctint.cpp:223:    tmp6 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*6];
.//SVD/JPEG/jfdctint.cpp:225:    tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*5];
.//SVD/JPEG/jfdctint.cpp:227:    tmp4 = dataptr[DCTSIZE*3] - dataptr[DCTSIZE*4];
.//SVD/JPEG/jfdctint.cpp:229:    /* Even part per LL&M figure 1 --- note that published figure is faulty;
.//SVD/JPEG/jfdctint.cpp:234:    tmp13 = tmp0 - tmp3;
.//SVD/JPEG/jfdctint.cpp:236:    tmp12 = tmp1 - tmp2;
.//SVD/JPEG/jfdctint.cpp:239:    dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS);
.//SVD/JPEG/jfdctint.cpp:244:    dataptr[DCTSIZE*6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),
.//SVD/JPEG/jfdctint.cpp:247:    /* Odd part per figure 8 --- note paper omits factor of sqrt(2).
.//SVD/JPEG/jfdctint.cpp:258:    tmp4 = MULTIPLY(tmp4, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
.//SVD/JPEG/jfdctint.cpp:259:    tmp5 = MULTIPLY(tmp5, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
.//SVD/JPEG/jfdctint.cpp:260:    tmp6 = MULTIPLY(tmp6, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
.//SVD/JPEG/jfdctint.cpp:261:    tmp7 = MULTIPLY(tmp7, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
.//SVD/JPEG/jfdctint.cpp:262:    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
.//SVD/JPEG/jfdctint.cpp:263:    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
.//SVD/JPEG/jfdctint.cpp:264:    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
.//SVD/JPEG/jfdctint.cpp:265:    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
.//SVD/JPEG/jidctflt.cpp:4: * Copyright (C) 1994-1998, Thomas G. Lane.
.//SVD/JPEG/jidctflt.cpp:8: * This file contains a floating-point implementation of the
.//SVD/JPEG/jidctflt.cpp:17: * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
.//SVD/JPEG/jidctflt.cpp:23: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
.//SVD/JPEG/jidctflt.cpp:26: * is based directly on figure 4-8 in P&M.
.//SVD/JPEG/jidctflt.cpp:27: * While an 8-point DCT cannot be done in less than 11 multiplies, it is
.//SVD/JPEG/jidctflt.cpp:33: * The primary disadvantage of this method is that with a fixed-point
.//SVD/JPEG/jidctflt.cpp:56:/* Dequantize a coefficient by multiplying it by the multiplier-table
.//SVD/JPEG/jidctflt.cpp:87:  quantptr = (FLOAT_MULT_TYPE *) compptr->dct_table;
.//SVD/JPEG/jidctflt.cpp:89:  for (ctr = DCTSIZE; ctr > 0; ctr--) {
.//SVD/JPEG/jidctflt.cpp:92:     * by short-circuiting the IDCT calculation for any column in which all
.//SVD/JPEG/jidctflt.cpp:129:    tmp11 = tmp0 - tmp2;
.//SVD/JPEG/jidctflt.cpp:131:    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
.//SVD/JPEG/jidctflt.cpp:132:    tmp12 = (tmp1 - tmp3) * ((FAST_FLOAT) 1.414213562) - tmp13; /* 2*c4 */
.//SVD/JPEG/jidctflt.cpp:135:    tmp3 = tmp10 - tmp13;
.//SVD/JPEG/jidctflt.cpp:137:    tmp2 = tmp11 - tmp12;
.//SVD/JPEG/jidctflt.cpp:147:    z10 = tmp6 - tmp5;
.//SVD/JPEG/jidctflt.cpp:149:    z12 = tmp4 - tmp7;
.//SVD/JPEG/jidctflt.cpp:152:    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562); /* 2*c4 */
.//SVD/JPEG/jidctflt.cpp:155:    tmp10 = ((FAST_FLOAT) 1.082392200) * z12 - z5; /* 2*(c2-c6) */
.//SVD/JPEG/jidctflt.cpp:156:    tmp12 = ((FAST_FLOAT) -2.613125930) * z10 + z5; /* -2*(c2+c6) */
.//SVD/JPEG/jidctflt.cpp:158:    tmp6 = tmp12 - tmp7;	/* phase 2 */
.//SVD/JPEG/jidctflt.cpp:159:    tmp5 = tmp11 - tmp6;
.//SVD/JPEG/jidctflt.cpp:163:    wsptr[DCTSIZE*7] = tmp0 - tmp7;
.//SVD/JPEG/jidctflt.cpp:165:    wsptr[DCTSIZE*6] = tmp1 - tmp6;
.//SVD/JPEG/jidctflt.cpp:167:    wsptr[DCTSIZE*5] = tmp2 - tmp5;
.//SVD/JPEG/jidctflt.cpp:169:    wsptr[DCTSIZE*3] = tmp3 - tmp4;
.//SVD/JPEG/jidctflt.cpp:191:    tmp11 = wsptr[0] - wsptr[4];
.//SVD/JPEG/jidctflt.cpp:194:    tmp12 = (wsptr[2] - wsptr[6]) * ((FAST_FLOAT) 1.414213562) - tmp13;
.//SVD/JPEG/jidctflt.cpp:197:    tmp3 = tmp10 - tmp13;
.//SVD/JPEG/jidctflt.cpp:199:    tmp2 = tmp11 - tmp12;
.//SVD/JPEG/jidctflt.cpp:204:    z10 = wsptr[5] - wsptr[3];
.//SVD/JPEG/jidctflt.cpp:206:    z12 = wsptr[1] - wsptr[7];
.//SVD/JPEG/jidctflt.cpp:209:    tmp11 = (z11 - z13) * ((FAST_FLOAT) 1.414213562);
.//SVD/JPEG/jidctflt.cpp:212:    tmp10 = ((FAST_FLOAT) 1.082392200) * z12 - z5; /* 2*(c2-c6) */
.//SVD/JPEG/jidctflt.cpp:213:    tmp12 = ((FAST_FLOAT) -2.613125930) * z10 + z5; /* -2*(c2+c6) */
.//SVD/JPEG/jidctflt.cpp:215:    tmp6 = tmp12 - tmp7;
.//SVD/JPEG/jidctflt.cpp:216:    tmp5 = tmp11 - tmp6;
.//SVD/JPEG/jidctflt.cpp:219:    /* Final output stage: scale down by a factor of 8 and range-limit */
.//SVD/JPEG/jidctflt.cpp:223:    outptr[7] = range_limit[(int) DESCALE((INT32) (tmp0 - tmp7), 3)
.//SVD/JPEG/jidctflt.cpp:227:    outptr[6] = range_limit[(int) DESCALE((INT32) (tmp1 - tmp6), 3)
.//SVD/JPEG/jidctflt.cpp:231:    outptr[5] = range_limit[(int) DESCALE((INT32) (tmp2 - tmp5), 3)
.//SVD/JPEG/jidctflt.cpp:235:    outptr[3] = range_limit[(int) DESCALE((INT32) (tmp3 - tmp4), 3)
.//SVD/JPEG/jidctfst.cpp:4: * Copyright (C) 1994-1998, Thomas G. Lane.
.//SVD/JPEG/jidctfst.cpp:12: * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
.//SVD/JPEG/jidctfst.cpp:18: * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
.//SVD/JPEG/jidctfst.cpp:21: * is based directly on figure 4-8 in P&M.
.//SVD/JPEG/jidctfst.cpp:22: * While an 8-point DCT cannot be done in less than 11 multiplies, it is
.//SVD/JPEG/jidctfst.cpp:28: * The primary disadvantage of this method is that with fixed-point math,
.//SVD/JPEG/jidctfst.cpp:31: * precise the scaled value, so this implementation does worse with high-
.//SVD/JPEG/jidctfst.cpp:32: * quality-setting files than with low-quality ones.
.//SVD/JPEG/jidctfst.cpp:57: * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
.//SVD/JPEG/jidctfst.cpp:59: * of work on 16-bit-int machines.
.//SVD/JPEG/jidctfst.cpp:64: * For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = PASS1_BITS so as to
.//SVD/JPEG/jidctfst.cpp:67: * For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,
.//SVD/JPEG/jidctfst.cpp:73: * are fewer one-bits in the constants).
.//SVD/JPEG/jidctfst.cpp:85: * causing a lot of useless floating-point operations at run time.
.//SVD/JPEG/jidctfst.cpp:86: * To get around this we use the following pre-calculated constants.
.//SVD/JPEG/jidctfst.cpp:122:/* Dequantize a coefficient by multiplying it by the multiplier-table
.//SVD/JPEG/jidctfst.cpp:123: * entry; produce a DCTELEM result.  For 8-bit data a 16x16->16
.//SVD/JPEG/jidctfst.cpp:124: * multiplication will do.  For 12-bit data, the multiplier table is
.//SVD/JPEG/jidctfst.cpp:125: * declared INT32, so a 32-bit multiply will be used.
.//SVD/JPEG/jidctfst.cpp:132:	DESCALE((coef)*(quantval), IFAST_SCALE_BITS-PASS1_BITS)
.//SVD/JPEG/jidctfst.cpp:149:     (ishift_temp >> (shft)) | ((~((DCTELEM) 0)) << (DCTELEMBITS-(shft))) : \
.//SVD/JPEG/jidctfst.cpp:157:#define IDESCALE(x,n)  ((int) IRIGHT_SHIFT((x) + (1 << ((n)-1)), n))
.//SVD/JPEG/jidctfst.cpp:188:  quantptr = (IFAST_MULT_TYPE *) compptr->dct_table;
.//SVD/JPEG/jidctfst.cpp:190:  for (ctr = DCTSIZE; ctr > 0; ctr--) {
.//SVD/JPEG/jidctfst.cpp:193:     * by short-circuiting the IDCT calculation for any column in which all
.//SVD/JPEG/jidctfst.cpp:230:    tmp11 = tmp0 - tmp2;
.//SVD/JPEG/jidctfst.cpp:232:    tmp13 = tmp1 + tmp3;	/* phases 5-3 */
.//SVD/JPEG/jidctfst.cpp:233:    tmp12 = MULTIPLY(tmp1 - tmp3, FIX_1_414213562) - tmp13; /* 2*c4 */
.//SVD/JPEG/jidctfst.cpp:236:    tmp3 = tmp10 - tmp13;
.//SVD/JPEG/jidctfst.cpp:238:    tmp2 = tmp11 - tmp12;
.//SVD/JPEG/jidctfst.cpp:248:    z10 = tmp6 - tmp5;
.//SVD/JPEG/jidctfst.cpp:250:    z12 = tmp4 - tmp7;
.//SVD/JPEG/jidctfst.cpp:253:    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */
.//SVD/JPEG/jidctfst.cpp:256:    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
.//SVD/JPEG/jidctfst.cpp:257:    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */
.//SVD/JPEG/jidctfst.cpp:259:    tmp6 = tmp12 - tmp7;	/* phase 2 */
.//SVD/JPEG/jidctfst.cpp:260:    tmp5 = tmp11 - tmp6;
.//SVD/JPEG/jidctfst.cpp:264:    wsptr[DCTSIZE*7] = (int) (tmp0 - tmp7);
.//SVD/JPEG/jidctfst.cpp:266:    wsptr[DCTSIZE*6] = (int) (tmp1 - tmp6);
.//SVD/JPEG/jidctfst.cpp:268:    wsptr[DCTSIZE*5] = (int) (tmp2 - tmp5);
.//SVD/JPEG/jidctfst.cpp:270:    wsptr[DCTSIZE*3] = (int) (tmp3 - tmp4);
.//SVD/JPEG/jidctfst.cpp:316:    tmp11 = ((DCTELEM) wsptr[0] - (DCTELEM) wsptr[4]);
.//SVD/JPEG/jidctfst.cpp:319:    tmp12 = MULTIPLY((DCTELEM) wsptr[2] - (DCTELEM) wsptr[6], FIX_1_414213562)
.//SVD/JPEG/jidctfst.cpp:320:	    - tmp13;
.//SVD/JPEG/jidctfst.cpp:323:    tmp3 = tmp10 - tmp13;
.//SVD/JPEG/jidctfst.cpp:325:    tmp2 = tmp11 - tmp12;
.//SVD/JPEG/jidctfst.cpp:330:    z10 = (DCTELEM) wsptr[5] - (DCTELEM) wsptr[3];
.//SVD/JPEG/jidctfst.cpp:332:    z12 = (DCTELEM) wsptr[1] - (DCTELEM) wsptr[7];
.//SVD/JPEG/jidctfst.cpp:335:    tmp11 = MULTIPLY(z11 - z13, FIX_1_414213562); /* 2*c4 */
.//SVD/JPEG/jidctfst.cpp:338:    tmp10 = MULTIPLY(z12, FIX_1_082392200) - z5; /* 2*(c2-c6) */
.//SVD/JPEG/jidctfst.cpp:339:    tmp12 = MULTIPLY(z10, - FIX_2_613125930) + z5; /* -2*(c2+c6) */
.//SVD/JPEG/jidctfst.cpp:341:    tmp6 = tmp12 - tmp7;	/* phase 2 */
.//SVD/JPEG/jidctfst.cpp:342:    tmp5 = tmp11 - tmp6;
.//SVD/JPEG/jidctfst.cpp:345:    /* Final output stage: scale down by a factor of 8 and range-limit */
.//SVD/JPEG/jidctfst.cpp:349:    outptr[7] = range_limit[IDESCALE(tmp0 - tmp7, PASS1_BITS+3)
.//SVD/JPEG/jidctfst.cpp:353:    outptr[6] = range_limit[IDESCALE(tmp1 - tmp6, PASS1_BITS+3)
.//SVD/JPEG/jidctfst.cpp:357:    outptr[5] = range_limit[IDESCALE(tmp2 - tmp5, PASS1_BITS+3)
.//SVD/JPEG/jidctfst.cpp:361:    outptr[3] = range_limit[IDESCALE(tmp3 - tmp4, PASS1_BITS+3)
.//SVD/JPEG/jidctint.cpp:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//SVD/JPEG/jidctint.cpp:8: * This file contains a slow-but-accurate integer implementation of the
.//SVD/JPEG/jidctint.cpp:12: * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
.//SVD/JPEG/jidctint.cpp:18: *   C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
.//SVD/JPEG/jidctint.cpp:20: *   Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
.//SVD/JPEG/jidctint.cpp:25: * scaled fixed-point arithmetic, with a minimal number of shifts.
.//SVD/JPEG/jidctint.cpp:48: * Each 1-D IDCT step produces outputs which are a factor of sqrt(N)
.//SVD/JPEG/jidctint.cpp:52: * this arrangement is that we save two multiplications per 1-D IDCT,
.//SVD/JPEG/jidctint.cpp:67: * they are represented to better-than-integral precision.  These outputs
.//SVD/JPEG/jidctint.cpp:68: * require BITS_IN_JSAMPLE + PASS1_BITS + 3 bits; this fits in a 16-bit word
.//SVD/JPEG/jidctint.cpp:69: * with the recommended scaling.  (To scale up 12-bit sample data further, an
.//SVD/JPEG/jidctint.cpp:72: * To avoid overflow of the 32-bit intermediate results in pass 2, we must
.//SVD/JPEG/jidctint.cpp:86: * causing a lot of useless floating-point operations at run time.
.//SVD/JPEG/jidctint.cpp:87: * To get around this we use the following pre-calculated constants.
.//SVD/JPEG/jidctint.cpp:122: * For 8-bit samples with the recommended scaling, all the variable
.//SVD/JPEG/jidctint.cpp:124: * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.
.//SVD/JPEG/jidctint.cpp:125: * For 12-bit samples, a full 32-bit multiplication will be needed.
.//SVD/JPEG/jidctint.cpp:135:/* Dequantize a coefficient by multiplying it by the multiplier-table
.//SVD/JPEG/jidctint.cpp:169:  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
.//SVD/JPEG/jidctint.cpp:171:  for (ctr = DCTSIZE; ctr > 0; ctr--) {
.//SVD/JPEG/jidctint.cpp:174:     * by short-circuiting the IDCT calculation for any column in which all
.//SVD/JPEG/jidctint.cpp:204:    /* The rotator is sqrt(2)*c(-6). */
.//SVD/JPEG/jidctint.cpp:210:    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
.//SVD/JPEG/jidctint.cpp:217:    tmp1 = (z2 - z3) << CONST_BITS;
.//SVD/JPEG/jidctint.cpp:220:    tmp13 = tmp0 - tmp3;
.//SVD/JPEG/jidctint.cpp:222:    tmp12 = tmp1 - tmp2;
.//SVD/JPEG/jidctint.cpp:239:    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
.//SVD/JPEG/jidctint.cpp:240:    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
.//SVD/JPEG/jidctint.cpp:241:    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
.//SVD/JPEG/jidctint.cpp:242:    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
.//SVD/JPEG/jidctint.cpp:243:    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
.//SVD/JPEG/jidctint.cpp:244:    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
.//SVD/JPEG/jidctint.cpp:245:    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
.//SVD/JPEG/jidctint.cpp:246:    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
.//SVD/JPEG/jidctint.cpp:258:    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jidctint.cpp:259:    wsptr[DCTSIZE*7] = (int) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jidctint.cpp:260:    wsptr[DCTSIZE*1] = (int) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jidctint.cpp:261:    wsptr[DCTSIZE*6] = (int) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jidctint.cpp:262:    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jidctint.cpp:263:    wsptr[DCTSIZE*5] = (int) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jidctint.cpp:264:    wsptr[DCTSIZE*3] = (int) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jidctint.cpp:265:    wsptr[DCTSIZE*4] = (int) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
.//SVD/JPEG/jidctint.cpp:309:    /* The rotator is sqrt(2)*c(-6). */
.//SVD/JPEG/jidctint.cpp:315:    tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
.//SVD/JPEG/jidctint.cpp:319:    tmp1 = ((INT32) wsptr[0] - (INT32) wsptr[4]) << CONST_BITS;
.//SVD/JPEG/jidctint.cpp:322:    tmp13 = tmp0 - tmp3;
.//SVD/JPEG/jidctint.cpp:324:    tmp12 = tmp1 - tmp2;
.//SVD/JPEG/jidctint.cpp:341:    tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
.//SVD/JPEG/jidctint.cpp:342:    tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
.//SVD/JPEG/jidctint.cpp:343:    tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
.//SVD/JPEG/jidctint.cpp:344:    tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
.//SVD/JPEG/jidctint.cpp:345:    z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
.//SVD/JPEG/jidctint.cpp:346:    z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
.//SVD/JPEG/jidctint.cpp:347:    z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
.//SVD/JPEG/jidctint.cpp:348:    z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
.//SVD/JPEG/jidctint.cpp:363:    outptr[7] = range_limit[(int) DESCALE(tmp10 - tmp3,
.//SVD/JPEG/jidctint.cpp:369:    outptr[6] = range_limit[(int) DESCALE(tmp11 - tmp2,
.//SVD/JPEG/jidctint.cpp:375:    outptr[5] = range_limit[(int) DESCALE(tmp12 - tmp1,
.//SVD/JPEG/jidctint.cpp:381:    outptr[4] = range_limit[(int) DESCALE(tmp13 - tmp0,
.//SVD/JPEG/jidctred.cpp:4: * Copyright (C) 1994-1998, Thomas G. Lane.
.//SVD/JPEG/jidctred.cpp:8: * This file contains inverse-DCT routines that produce reduced-size output:
.//SVD/JPEG/jidctred.cpp:12: * algorithm used in jidctint.c.  We simply replace each 8-to-8 1-D IDCT step
.//SVD/JPEG/jidctred.cpp:13: * with an 8-to-4 step that produces the four averages of two adjacent outputs
.//SVD/JPEG/jidctred.cpp:14: * (or an 8-to-2 step producing two averages of four outputs, for 2x2 output).
.//SVD/JPEG/jidctred.cpp:51: * causing a lot of useless floating-point operations at run time.
.//SVD/JPEG/jidctred.cpp:52: * To get around this we use the following pre-calculated constants.
.//SVD/JPEG/jidctred.cpp:91: * For 8-bit samples with the recommended scaling, all the variable
.//SVD/JPEG/jidctred.cpp:93: * 16x16->32 bit multiply can be used instead of a full 32x32 multiply.
.//SVD/JPEG/jidctred.cpp:94: * For 12-bit samples, a full 32-bit multiplication will be needed.
.//SVD/JPEG/jidctred.cpp:104:/* Dequantize a coefficient by multiplying it by the multiplier-table
.//SVD/JPEG/jidctred.cpp:114: * producing a reduced-size 4x4 output block.
.//SVD/JPEG/jidctred.cpp:136:  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
.//SVD/JPEG/jidctred.cpp:138:  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
.//SVD/JPEG/jidctred.cpp:140:    if (ctr == DCTSIZE-4)
.//SVD/JPEG/jidctred.cpp:164:    tmp2 = MULTIPLY(z2, FIX_1_847759065) + MULTIPLY(z3, - FIX_0_765366865);
.//SVD/JPEG/jidctred.cpp:167:    tmp12 = tmp0 - tmp2;
.//SVD/JPEG/jidctred.cpp:176:    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
.//SVD/JPEG/jidctred.cpp:178:	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
.//SVD/JPEG/jidctred.cpp:181:    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
.//SVD/JPEG/jidctred.cpp:182:	 + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */
.//SVD/JPEG/jidctred.cpp:183:	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
.//SVD/JPEG/jidctred.cpp:188:    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp2, CONST_BITS-PASS1_BITS+1);
.//SVD/JPEG/jidctred.cpp:189:    wsptr[DCTSIZE*3] = (int) DESCALE(tmp10 - tmp2, CONST_BITS-PASS1_BITS+1);
.//SVD/JPEG/jidctred.cpp:190:    wsptr[DCTSIZE*1] = (int) DESCALE(tmp12 + tmp0, CONST_BITS-PASS1_BITS+1);
.//SVD/JPEG/jidctred.cpp:191:    wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 - tmp0, CONST_BITS-PASS1_BITS+1);
.//SVD/JPEG/jidctred.cpp:223:	 + MULTIPLY((INT32) wsptr[6], - FIX_0_765366865);
.//SVD/JPEG/jidctred.cpp:226:    tmp12 = tmp0 - tmp2;
.//SVD/JPEG/jidctred.cpp:235:    tmp0 = MULTIPLY(z1, - FIX_0_211164243) /* sqrt(2) * (c3-c1) */
.//SVD/JPEG/jidctred.cpp:237:	 + MULTIPLY(z3, - FIX_2_172734803) /* sqrt(2) * (-c1-c5) */
.//SVD/JPEG/jidctred.cpp:240:    tmp2 = MULTIPLY(z1, - FIX_0_509795579) /* sqrt(2) * (c7-c5) */
.//SVD/JPEG/jidctred.cpp:241:	 + MULTIPLY(z2, - FIX_0_601344887) /* sqrt(2) * (c5-c1) */
.//SVD/JPEG/jidctred.cpp:242:	 + MULTIPLY(z3, FIX_0_899976223) /* sqrt(2) * (c3-c7) */
.//SVD/JPEG/jidctred.cpp:250:    outptr[3] = range_limit[(int) DESCALE(tmp10 - tmp2,
.//SVD/JPEG/jidctred.cpp:256:    outptr[2] = range_limit[(int) DESCALE(tmp12 - tmp0,
.//SVD/JPEG/jidctred.cpp:267: * producing a reduced-size 2x2 output block.
.//SVD/JPEG/jidctred.cpp:288:  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
.//SVD/JPEG/jidctred.cpp:290:  for (ctr = DCTSIZE; ctr > 0; inptr++, quantptr++, wsptr++, ctr--) {
.//SVD/JPEG/jidctred.cpp:292:    if (ctr == DCTSIZE-2 || ctr == DCTSIZE-4 || ctr == DCTSIZE-6)
.//SVD/JPEG/jidctred.cpp:313:    tmp0 = MULTIPLY(z1, - FIX_0_720959822); /* sqrt(2) * (c7-c5+c3-c1) */
.//SVD/JPEG/jidctred.cpp:315:    tmp0 += MULTIPLY(z1, FIX_0_850430095); /* sqrt(2) * (-c1+c3+c5+c7) */
.//SVD/JPEG/jidctred.cpp:317:    tmp0 += MULTIPLY(z1, - FIX_1_272758580); /* sqrt(2) * (-c1+c3-c5-c7) */
.//SVD/JPEG/jidctred.cpp:323:    wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp0, CONST_BITS-PASS1_BITS+2);
.//SVD/JPEG/jidctred.cpp:324:    wsptr[DCTSIZE*1] = (int) DESCALE(tmp10 - tmp0, CONST_BITS-PASS1_BITS+2);
.//SVD/JPEG/jidctred.cpp:354:    tmp0 = MULTIPLY((INT32) wsptr[7], - FIX_0_720959822) /* sqrt(2) * (c7-c5+c3-c1) */
.//SVD/JPEG/jidctred.cpp:355:	 + MULTIPLY((INT32) wsptr[5], FIX_0_850430095) /* sqrt(2) * (-c1+c3+c5+c7) */
.//SVD/JPEG/jidctred.cpp:356:	 + MULTIPLY((INT32) wsptr[3], - FIX_1_272758580) /* sqrt(2) * (-c1+c3-c5-c7) */
.//SVD/JPEG/jidctred.cpp:364:    outptr[1] = range_limit[(int) DESCALE(tmp10 - tmp0,
.//SVD/JPEG/jidctred.cpp:375: * producing a reduced-size 1x1 output block.
.//SVD/JPEG/jidctred.cpp:389:   * average pixel value, which is one-eighth of the DC coefficient.
.//SVD/JPEG/jidctred.cpp:391:  quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
.//SVD/JPEG/jinclude.h:4: * Copyright (C) 1991-1994, Thomas G. Lane.
.//SVD/JPEG/jinclude.h:18:/* Include auto-config file to find out which system include files we need. */
.//SVD/JPEG/jinclude.h:25: * On an ANSI-conforming system it is sufficient to include <stddef.h>.
.//SVD/JPEG/jmemmgr.cpp:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jmemmgr.cpp:8: * This file contains the JPEG system-independent memory management
.//SVD/JPEG/jmemmgr.cpp:12: *   * pool-based allocation and freeing of memory;
.//SVD/JPEG/jmemmgr.cpp:17: * The separate system-dependent file provides the actual backing-storage
.//SVD/JPEG/jmemmgr.cpp:20: * This file is system-dependent in the sense that some of its functions
.//SVD/JPEG/jmemmgr.cpp:31:#include "jmemsys.h"		/* import the system-dependent declarations */
.//SVD/JPEG/jmemmgr.cpp:54: * Many machines require storage alignment: longs must start on 4-byte
.//SVD/JPEG/jmemmgr.cpp:55: * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()
.//SVD/JPEG/jmemmgr.cpp:56: * always returns pointers that are multiples of the worst-case alignment
.//SVD/JPEG/jmemmgr.cpp:58: * There isn't any really portable way to determine the worst-case alignment
.//SVD/JPEG/jmemmgr.cpp:62: * workstations (where doubles really do need 8-byte alignment) and will work
.//SVD/JPEG/jmemmgr.cpp:66: * 680x0 compilers that define double as a 10-byte IEEE extended float.
.//SVD/JPEG/jmemmgr.cpp:67: * Doing 10-byte alignment is counterproductive because longwords won't be
.//SVD/JPEG/jmemmgr.cpp:79: * request to jpeg_get_small() or jpeg_get_large().  There is no per-object
.//SVD/JPEG/jmemmgr.cpp:126:   * in the small-pool list.
.//SVD/JPEG/jmemmgr.cpp:146: * System-dependent info for the associated backing store (if any) is hidden
.//SVD/JPEG/jmemmgr.cpp:151:  JSAMPARRAY mem_buffer;	/* => the in-memory buffer */
.//SVD/JPEG/jmemmgr.cpp:159:  boolean pre_zero;		/* pre-zero mode requested? */
.//SVD/JPEG/jmemmgr.cpp:161:  boolean b_s_open;		/* is backing-store data valid? */
.//SVD/JPEG/jmemmgr.cpp:163:  backing_store_info b_s_info;	/* System-dependent control info */
.//SVD/JPEG/jmemmgr.cpp:167:  JBLOCKARRAY mem_buffer;	/* => the in-memory buffer */
.//SVD/JPEG/jmemmgr.cpp:175:  boolean pre_zero;		/* pre-zero mode requested? */
.//SVD/JPEG/jmemmgr.cpp:177:  boolean b_s_open;		/* is backing-store data valid? */
.//SVD/JPEG/jmemmgr.cpp:179:  backing_store_info b_s_info;	/* System-dependent control info */
.//SVD/JPEG/jmemmgr.cpp:188:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//SVD/JPEG/jmemmgr.cpp:197:	  pool_id, mem->total_space_allocated);
.//SVD/JPEG/jmemmgr.cpp:199:  for (lhdr_ptr = mem->large_list[pool_id]; lhdr_ptr != NULL;
.//SVD/JPEG/jmemmgr.cpp:200:       lhdr_ptr = lhdr_ptr->hdr.next) {
.//SVD/JPEG/jmemmgr.cpp:202:	    (long) lhdr_ptr->hdr.bytes_used);
.//SVD/JPEG/jmemmgr.cpp:205:  for (shdr_ptr = mem->small_list[pool_id]; shdr_ptr != NULL;
.//SVD/JPEG/jmemmgr.cpp:206:       shdr_ptr = shdr_ptr->hdr.next) {
.//SVD/JPEG/jmemmgr.cpp:208:	    (long) shdr_ptr->hdr.bytes_used,
.//SVD/JPEG/jmemmgr.cpp:209:	    (long) shdr_ptr->hdr.bytes_left);
.//SVD/JPEG/jmemmgr.cpp:218:/* Report an out-of-memory error and stop execution */
.//SVD/JPEG/jmemmgr.cpp:222:  cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
.//SVD/JPEG/jmemmgr.cpp:237: * NOTE: the values given work fairly well on both 16- and 32-bit-int
.//SVD/JPEG/jmemmgr.cpp:260:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//SVD/JPEG/jmemmgr.cpp:266:  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
.//SVD/JPEG/jmemmgr.cpp:272:    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
.//SVD/JPEG/jmemmgr.cpp:278:  hdr_ptr = mem->small_list[pool_id];
.//SVD/JPEG/jmemmgr.cpp:280:    if (hdr_ptr->hdr.bytes_left >= sizeofobject)
.//SVD/JPEG/jmemmgr.cpp:283:    hdr_ptr = hdr_ptr->hdr.next;
.//SVD/JPEG/jmemmgr.cpp:295:    if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
.//SVD/JPEG/jmemmgr.cpp:296:      slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
.//SVD/JPEG/jmemmgr.cpp:306:    mem->total_space_allocated += min_request + slop;
.//SVD/JPEG/jmemmgr.cpp:308:    hdr_ptr->hdr.next = NULL;
.//SVD/JPEG/jmemmgr.cpp:309:    hdr_ptr->hdr.bytes_used = 0;
.//SVD/JPEG/jmemmgr.cpp:310:    hdr_ptr->hdr.bytes_left = sizeofobject + slop;
.//SVD/JPEG/jmemmgr.cpp:312:      mem->small_list[pool_id] = hdr_ptr;
.//SVD/JPEG/jmemmgr.cpp:314:      prev_hdr_ptr->hdr.next = hdr_ptr;
.//SVD/JPEG/jmemmgr.cpp:319:  data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
.//SVD/JPEG/jmemmgr.cpp:320:  hdr_ptr->hdr.bytes_used += sizeofobject;
.//SVD/JPEG/jmemmgr.cpp:321:  hdr_ptr->hdr.bytes_left -= sizeofobject;
.//SVD/JPEG/jmemmgr.cpp:345:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//SVD/JPEG/jmemmgr.cpp:350:  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
.//SVD/JPEG/jmemmgr.cpp:356:    sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
.//SVD/JPEG/jmemmgr.cpp:366:  mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
.//SVD/JPEG/jmemmgr.cpp:369:  hdr_ptr->hdr.next = mem->large_list[pool_id];
.//SVD/JPEG/jmemmgr.cpp:373:  hdr_ptr->hdr.bytes_used = sizeofobject;
.//SVD/JPEG/jmemmgr.cpp:374:  hdr_ptr->hdr.bytes_left = 0;
.//SVD/JPEG/jmemmgr.cpp:375:  mem->large_list[pool_id] = hdr_ptr;
.//SVD/JPEG/jmemmgr.cpp:382: * Creation of 2-D sample arrays.
.//SVD/JPEG/jmemmgr.cpp:397:/* Allocate a 2-D sample array */
.//SVD/JPEG/jmemmgr.cpp:399:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//SVD/JPEG/jmemmgr.cpp:406:  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
.//SVD/JPEG/jmemmgr.cpp:414:  mem->last_rowsperchunk = rowsperchunk;
.//SVD/JPEG/jmemmgr.cpp:423:    rowsperchunk = MIN(rowsperchunk, numrows - currow);
.//SVD/JPEG/jmemmgr.cpp:427:    for (i = rowsperchunk; i > 0; i--) {
.//SVD/JPEG/jmemmgr.cpp:438: * Creation of 2-D coefficient-block arrays.
.//SVD/JPEG/jmemmgr.cpp:445:/* Allocate a 2-D coefficient-block array */
.//SVD/JPEG/jmemmgr.cpp:447:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//SVD/JPEG/jmemmgr.cpp:454:  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
.//SVD/JPEG/jmemmgr.cpp:462:  mem->last_rowsperchunk = rowsperchunk;
.//SVD/JPEG/jmemmgr.cpp:471:    rowsperchunk = MIN(rowsperchunk, numrows - currow);
.//SVD/JPEG/jmemmgr.cpp:475:    for (i = rowsperchunk; i > 0; i--) {
.//SVD/JPEG/jmemmgr.cpp:489: * (as wide as the image, but just a few rows high).  Full-image-sized buffers
.//SVD/JPEG/jmemmgr.cpp:497: * the maximum number of rows that will be accessed at once.  The in-memory
.//SVD/JPEG/jmemmgr.cpp:500: * The request routines create control blocks but not the in-memory buffers.
.//SVD/JPEG/jmemmgr.cpp:508: * the accessed strip; during a read-only pass this saves having to rewrite
.//SVD/JPEG/jmemmgr.cpp:509: * data to disk.  The access routines are also responsible for pre-zeroing
.//SVD/JPEG/jmemmgr.cpp:510: * any newly accessed rows, if pre-zeroing was requested.
.//SVD/JPEG/jmemmgr.cpp:515: * buffer dump/reload logic, by making the in-memory buffer be a multiple
.//SVD/JPEG/jmemmgr.cpp:526:/* Request a virtual 2-D sample array */
.//SVD/JPEG/jmemmgr.cpp:528:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//SVD/JPEG/jmemmgr.cpp:531:  /* Only IMAGE-lifetime virtual arrays are currently supported */
.//SVD/JPEG/jmemmgr.cpp:539:  result->mem_buffer = NULL;	/* marks array not yet realized */
.//SVD/JPEG/jmemmgr.cpp:540:  result->rows_in_array = numrows;
.//SVD/JPEG/jmemmgr.cpp:541:  result->samplesperrow = samplesperrow;
.//SVD/JPEG/jmemmgr.cpp:542:  result->maxaccess = maxaccess;
.//SVD/JPEG/jmemmgr.cpp:543:  result->pre_zero = pre_zero;
.//SVD/JPEG/jmemmgr.cpp:544:  result->b_s_open = FALSE;	/* no associated backing-store object */
.//SVD/JPEG/jmemmgr.cpp:545:  result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
.//SVD/JPEG/jmemmgr.cpp:546:  mem->virt_sarray_list = result;
.//SVD/JPEG/jmemmgr.cpp:556:/* Request a virtual 2-D coefficient-block array */
.//SVD/JPEG/jmemmgr.cpp:558:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//SVD/JPEG/jmemmgr.cpp:561:  /* Only IMAGE-lifetime virtual arrays are currently supported */
.//SVD/JPEG/jmemmgr.cpp:569:  result->mem_buffer = NULL;	/* marks array not yet realized */
.//SVD/JPEG/jmemmgr.cpp:570:  result->rows_in_array = numrows;
.//SVD/JPEG/jmemmgr.cpp:571:  result->blocksperrow = blocksperrow;
.//SVD/JPEG/jmemmgr.cpp:572:  result->maxaccess = maxaccess;
.//SVD/JPEG/jmemmgr.cpp:573:  result->pre_zero = pre_zero;
.//SVD/JPEG/jmemmgr.cpp:574:  result->b_s_open = FALSE;	/* no associated backing-store object */
.//SVD/JPEG/jmemmgr.cpp:575:  result->next = mem->virt_barray_list; /* add to list of virtual arrays */
.//SVD/JPEG/jmemmgr.cpp:576:  mem->virt_barray_list = result;
.//SVD/JPEG/jmemmgr.cpp:584:/* Allocate the in-memory buffers for any unrealized virtual arrays */
.//SVD/JPEG/jmemmgr.cpp:586:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//SVD/JPEG/jmemmgr.cpp:594:   * These may be of use to the system-dependent jpeg_mem_available routine.
.//SVD/JPEG/jmemmgr.cpp:598:  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
.//SVD/JPEG/jmemmgr.cpp:599:    if (sptr->mem_buffer == NULL) { /* if not realized yet */
.//SVD/JPEG/jmemmgr.cpp:600:      space_per_minheight += (long) sptr->maxaccess *
.//SVD/JPEG/jmemmgr.cpp:601:			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
.//SVD/JPEG/jmemmgr.cpp:602:      maximum_space += (long) sptr->rows_in_array *
.//SVD/JPEG/jmemmgr.cpp:603:		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
.//SVD/JPEG/jmemmgr.cpp:606:  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
.//SVD/JPEG/jmemmgr.cpp:607:    if (bptr->mem_buffer == NULL) { /* if not realized yet */
.//SVD/JPEG/jmemmgr.cpp:608:      space_per_minheight += (long) bptr->maxaccess *
.//SVD/JPEG/jmemmgr.cpp:609:			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
.//SVD/JPEG/jmemmgr.cpp:610:      maximum_space += (long) bptr->rows_in_array *
.//SVD/JPEG/jmemmgr.cpp:611:		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
.//SVD/JPEG/jmemmgr.cpp:618:  /* Determine amount of memory to actually use; this is system-dependent. */
.//SVD/JPEG/jmemmgr.cpp:620:				 mem->total_space_allocated);
.//SVD/JPEG/jmemmgr.cpp:637:  /* Allocate the in-memory buffers and initialize backing store as needed. */
.//SVD/JPEG/jmemmgr.cpp:639:  for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
.//SVD/JPEG/jmemmgr.cpp:640:    if (sptr->mem_buffer == NULL) { /* if not realized yet */
.//SVD/JPEG/jmemmgr.cpp:641:      minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
.//SVD/JPEG/jmemmgr.cpp:644:	sptr->rows_in_mem = sptr->rows_in_array;
.//SVD/JPEG/jmemmgr.cpp:647:	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
.//SVD/JPEG/jmemmgr.cpp:648:	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
.//SVD/JPEG/jmemmgr.cpp:649:				(long) sptr->rows_in_array *
.//SVD/JPEG/jmemmgr.cpp:650:				(long) sptr->samplesperrow *
.//SVD/JPEG/jmemmgr.cpp:652:	sptr->b_s_open = TRUE;
.//SVD/JPEG/jmemmgr.cpp:654:      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jmemmgr.cpp:655:				      sptr->samplesperrow, sptr->rows_in_mem);
.//SVD/JPEG/jmemmgr.cpp:656:      sptr->rowsperchunk = mem->last_rowsperchunk;
.//SVD/JPEG/jmemmgr.cpp:657:      sptr->cur_start_row = 0;
.//SVD/JPEG/jmemmgr.cpp:658:      sptr->first_undef_row = 0;
.//SVD/JPEG/jmemmgr.cpp:659:      sptr->dirty = FALSE;
.//SVD/JPEG/jmemmgr.cpp:663:  for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
.//SVD/JPEG/jmemmgr.cpp:664:    if (bptr->mem_buffer == NULL) { /* if not realized yet */
.//SVD/JPEG/jmemmgr.cpp:665:      minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
.//SVD/JPEG/jmemmgr.cpp:668:	bptr->rows_in_mem = bptr->rows_in_array;
.//SVD/JPEG/jmemmgr.cpp:671:	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
.//SVD/JPEG/jmemmgr.cpp:672:	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
.//SVD/JPEG/jmemmgr.cpp:673:				(long) bptr->rows_in_array *
.//SVD/JPEG/jmemmgr.cpp:674:				(long) bptr->blocksperrow *
.//SVD/JPEG/jmemmgr.cpp:676:	bptr->b_s_open = TRUE;
.//SVD/JPEG/jmemmgr.cpp:678:      bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jmemmgr.cpp:679:				      bptr->blocksperrow, bptr->rows_in_mem);
.//SVD/JPEG/jmemmgr.cpp:680:      bptr->rowsperchunk = mem->last_rowsperchunk;
.//SVD/JPEG/jmemmgr.cpp:681:      bptr->cur_start_row = 0;
.//SVD/JPEG/jmemmgr.cpp:682:      bptr->first_undef_row = 0;
.//SVD/JPEG/jmemmgr.cpp:683:      bptr->dirty = FALSE;
.//SVD/JPEG/jmemmgr.cpp:695:  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
.//SVD/JPEG/jmemmgr.cpp:696:  file_offset = ptr->cur_start_row * bytesperrow;
.//SVD/JPEG/jmemmgr.cpp:698:  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
.//SVD/JPEG/jmemmgr.cpp:700:    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
.//SVD/JPEG/jmemmgr.cpp:702:    thisrow = (long) ptr->cur_start_row + i;
.//SVD/JPEG/jmemmgr.cpp:703:    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
.//SVD/JPEG/jmemmgr.cpp:705:    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
.//SVD/JPEG/jmemmgr.cpp:710:      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
.//SVD/JPEG/jmemmgr.cpp:711:					    (void FAR *) ptr->mem_buffer[i],
.//SVD/JPEG/jmemmgr.cpp:714:      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
.//SVD/JPEG/jmemmgr.cpp:715:					   (void FAR *) ptr->mem_buffer[i],
.//SVD/JPEG/jmemmgr.cpp:724:/* Do backing store read or write of a virtual coefficient-block array */
.//SVD/JPEG/jmemmgr.cpp:728:  bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
.//SVD/JPEG/jmemmgr.cpp:729:  file_offset = ptr->cur_start_row * bytesperrow;
.//SVD/JPEG/jmemmgr.cpp:731:  for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
.//SVD/JPEG/jmemmgr.cpp:733:    rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
.//SVD/JPEG/jmemmgr.cpp:735:    thisrow = (long) ptr->cur_start_row + i;
.//SVD/JPEG/jmemmgr.cpp:736:    rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
.//SVD/JPEG/jmemmgr.cpp:738:    rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
.//SVD/JPEG/jmemmgr.cpp:743:      (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
.//SVD/JPEG/jmemmgr.cpp:744:					    (void FAR *) ptr->mem_buffer[i],
.//SVD/JPEG/jmemmgr.cpp:747:      (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
.//SVD/JPEG/jmemmgr.cpp:748:					   (void FAR *) ptr->mem_buffer[i],
.//SVD/JPEG/jmemmgr.cpp:767:  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
.//SVD/JPEG/jmemmgr.cpp:768:      ptr->mem_buffer == NULL)
.//SVD/JPEG/jmemmgr.cpp:772:  if (start_row < ptr->cur_start_row ||
.//SVD/JPEG/jmemmgr.cpp:773:      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
.//SVD/JPEG/jmemmgr.cpp:774:    if (! ptr->b_s_open)
.//SVD/JPEG/jmemmgr.cpp:777:    if (ptr->dirty) {
.//SVD/JPEG/jmemmgr.cpp:779:      ptr->dirty = FALSE;
.//SVD/JPEG/jmemmgr.cpp:788:    if (start_row > ptr->cur_start_row) {
.//SVD/JPEG/jmemmgr.cpp:789:      ptr->cur_start_row = start_row;
.//SVD/JPEG/jmemmgr.cpp:794:      ltemp = (long) end_row - (long) ptr->rows_in_mem;
.//SVD/JPEG/jmemmgr.cpp:797:      ptr->cur_start_row = (JDIMENSION) ltemp;
.//SVD/JPEG/jmemmgr.cpp:807:   * that the caller is about to access, not the entire in-memory array.
.//SVD/JPEG/jmemmgr.cpp:809:  if (ptr->first_undef_row < end_row) {
.//SVD/JPEG/jmemmgr.cpp:810:    if (ptr->first_undef_row < start_row) {
.//SVD/JPEG/jmemmgr.cpp:815:      undef_row = ptr->first_undef_row;
.//SVD/JPEG/jmemmgr.cpp:818:      ptr->first_undef_row = end_row;
.//SVD/JPEG/jmemmgr.cpp:819:    if (ptr->pre_zero) {
.//SVD/JPEG/jmemmgr.cpp:820:      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
.//SVD/JPEG/jmemmgr.cpp:821:      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
.//SVD/JPEG/jmemmgr.cpp:822:      end_row -= ptr->cur_start_row;
.//SVD/JPEG/jmemmgr.cpp:824:	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
.//SVD/JPEG/jmemmgr.cpp:834:    ptr->dirty = TRUE;
.//SVD/JPEG/jmemmgr.cpp:836:  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
.//SVD/JPEG/jmemmgr.cpp:852:  if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
.//SVD/JPEG/jmemmgr.cpp:853:      ptr->mem_buffer == NULL)
.//SVD/JPEG/jmemmgr.cpp:857:  if (start_row < ptr->cur_start_row ||
.//SVD/JPEG/jmemmgr.cpp:858:      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
.//SVD/JPEG/jmemmgr.cpp:859:    if (! ptr->b_s_open)
.//SVD/JPEG/jmemmgr.cpp:862:    if (ptr->dirty) {
.//SVD/JPEG/jmemmgr.cpp:864:      ptr->dirty = FALSE;
.//SVD/JPEG/jmemmgr.cpp:873:    if (start_row > ptr->cur_start_row) {
.//SVD/JPEG/jmemmgr.cpp:874:      ptr->cur_start_row = start_row;
.//SVD/JPEG/jmemmgr.cpp:879:      ltemp = (long) end_row - (long) ptr->rows_in_mem;
.//SVD/JPEG/jmemmgr.cpp:882:      ptr->cur_start_row = (JDIMENSION) ltemp;
.//SVD/JPEG/jmemmgr.cpp:892:   * that the caller is about to access, not the entire in-memory array.
.//SVD/JPEG/jmemmgr.cpp:894:  if (ptr->first_undef_row < end_row) {
.//SVD/JPEG/jmemmgr.cpp:895:    if (ptr->first_undef_row < start_row) {
.//SVD/JPEG/jmemmgr.cpp:900:      undef_row = ptr->first_undef_row;
.//SVD/JPEG/jmemmgr.cpp:903:      ptr->first_undef_row = end_row;
.//SVD/JPEG/jmemmgr.cpp:904:    if (ptr->pre_zero) {
.//SVD/JPEG/jmemmgr.cpp:905:      size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
.//SVD/JPEG/jmemmgr.cpp:906:      undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
.//SVD/JPEG/jmemmgr.cpp:907:      end_row -= ptr->cur_start_row;
.//SVD/JPEG/jmemmgr.cpp:909:	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
.//SVD/JPEG/jmemmgr.cpp:919:    ptr->dirty = TRUE;
.//SVD/JPEG/jmemmgr.cpp:921:  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
.//SVD/JPEG/jmemmgr.cpp:932:  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
.//SVD/JPEG/jmemmgr.cpp:941:  if (cinfo->err->trace_level > 1)
.//SVD/JPEG/jmemmgr.cpp:950:    for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
.//SVD/JPEG/jmemmgr.cpp:951:      if (sptr->b_s_open) {	/* there may be no backing store */
.//SVD/JPEG/jmemmgr.cpp:952:	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
.//SVD/JPEG/jmemmgr.cpp:953:	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
.//SVD/JPEG/jmemmgr.cpp:956:    mem->virt_sarray_list = NULL;
.//SVD/JPEG/jmemmgr.cpp:957:    for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
.//SVD/JPEG/jmemmgr.cpp:958:      if (bptr->b_s_open) {	/* there may be no backing store */
.//SVD/JPEG/jmemmgr.cpp:959:	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
.//SVD/JPEG/jmemmgr.cpp:960:	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
.//SVD/JPEG/jmemmgr.cpp:963:    mem->virt_barray_list = NULL;
.//SVD/JPEG/jmemmgr.cpp:967:  lhdr_ptr = mem->large_list[pool_id];
.//SVD/JPEG/jmemmgr.cpp:968:  mem->large_list[pool_id] = NULL;
.//SVD/JPEG/jmemmgr.cpp:971:    large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
.//SVD/JPEG/jmemmgr.cpp:972:    space_freed = lhdr_ptr->hdr.bytes_used +
.//SVD/JPEG/jmemmgr.cpp:973:		  lhdr_ptr->hdr.bytes_left +
.//SVD/JPEG/jmemmgr.cpp:976:    mem->total_space_allocated -= space_freed;
.//SVD/JPEG/jmemmgr.cpp:981:  shdr_ptr = mem->small_list[pool_id];
.//SVD/JPEG/jmemmgr.cpp:982:  mem->small_list[pool_id] = NULL;
.//SVD/JPEG/jmemmgr.cpp:985:    small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
.//SVD/JPEG/jmemmgr.cpp:986:    space_freed = shdr_ptr->hdr.bytes_used +
.//SVD/JPEG/jmemmgr.cpp:987:		  shdr_ptr->hdr.bytes_left +
.//SVD/JPEG/jmemmgr.cpp:990:    mem->total_space_allocated -= space_freed;
.//SVD/JPEG/jmemmgr.cpp:998: * Note that this cannot be called unless cinfo->mem is non-NULL.
.//SVD/JPEG/jmemmgr.cpp:1008:   * with some (brain-damaged) malloc libraries.
.//SVD/JPEG/jmemmgr.cpp:1010:  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
.//SVD/JPEG/jmemmgr.cpp:1015:  jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
.//SVD/JPEG/jmemmgr.cpp:1016:  cinfo->mem = NULL;		/* ensures I will be called only once */
.//SVD/JPEG/jmemmgr.cpp:1018:  jpeg_mem_term(cinfo);		/* system-dependent cleanup */
.//SVD/JPEG/jmemmgr.cpp:1035:  cinfo->mem = NULL;		/* for safety if init fails */
.//SVD/JPEG/jmemmgr.cpp:1040:   * The test is a little tricky: for X>0, X and X-1 have no one-bits
.//SVD/JPEG/jmemmgr.cpp:1041:   * in common if and only if X is a power of 2, ie has only one one-bit.
.//SVD/JPEG/jmemmgr.cpp:1044:  if ((SIZEOF(ALIGN_TYPE) & (SIZEOF(ALIGN_TYPE)-1)) != 0)
.//SVD/JPEG/jmemmgr.cpp:1056:  max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
.//SVD/JPEG/jmemmgr.cpp:1062:    jpeg_mem_term(cinfo);	/* system-dependent cleanup */
.//SVD/JPEG/jmemmgr.cpp:1067:  mem->pub.alloc_small = alloc_small;
.//SVD/JPEG/jmemmgr.cpp:1068:  mem->pub.alloc_large = alloc_large;
.//SVD/JPEG/jmemmgr.cpp:1069:  mem->pub.alloc_sarray = alloc_sarray;
.//SVD/JPEG/jmemmgr.cpp:1070:  mem->pub.alloc_barray = alloc_barray;
.//SVD/JPEG/jmemmgr.cpp:1071:  mem->pub.request_virt_sarray = request_virt_sarray;
.//SVD/JPEG/jmemmgr.cpp:1072:  mem->pub.request_virt_barray = request_virt_barray;
.//SVD/JPEG/jmemmgr.cpp:1073:  mem->pub.realize_virt_arrays = realize_virt_arrays;
.//SVD/JPEG/jmemmgr.cpp:1074:  mem->pub.access_virt_sarray = access_virt_sarray;
.//SVD/JPEG/jmemmgr.cpp:1075:  mem->pub.access_virt_barray = access_virt_barray;
.//SVD/JPEG/jmemmgr.cpp:1076:  mem->pub.free_pool = free_pool;
.//SVD/JPEG/jmemmgr.cpp:1077:  mem->pub.self_destruct = self_destruct;
.//SVD/JPEG/jmemmgr.cpp:1080:  mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
.//SVD/JPEG/jmemmgr.cpp:1083:  mem->pub.max_memory_to_use = max_to_use;
.//SVD/JPEG/jmemmgr.cpp:1085:  for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
.//SVD/JPEG/jmemmgr.cpp:1086:    mem->small_list[pool] = NULL;
.//SVD/JPEG/jmemmgr.cpp:1087:    mem->large_list[pool] = NULL;
.//SVD/JPEG/jmemmgr.cpp:1089:  mem->virt_sarray_list = NULL;
.//SVD/JPEG/jmemmgr.cpp:1090:  mem->virt_barray_list = NULL;
.//SVD/JPEG/jmemmgr.cpp:1092:  mem->total_space_allocated = SIZEOF(my_memory_mgr);
.//SVD/JPEG/jmemmgr.cpp:1095:  cinfo->mem = & mem->pub;
.//SVD/JPEG/jmemmgr.cpp:1112:	mem->pub.max_memory_to_use = max_to_use * 1000L;
.//SVD/JPEG/jmemnobs.cpp:4: * Copyright (C) 1992-1996, Thomas G. Lane.
.//SVD/JPEG/jmemnobs.cpp:8: * This file provides a really simple implementation of the system-
.//SVD/JPEG/jmemnobs.cpp:10: * assumes that no backing-store files are needed: all required space
.//SVD/JPEG/jmemnobs.cpp:21:#include "jmemsys.h"		/* import the system-dependent declarations */
.//SVD/JPEG/jmemnobs.cpp:51: * you probably won't be able to process useful-size images in only 64KB.
.//SVD/JPEG/jmemnobs.cpp:95: * These routines take care of any system-dependent initialization and
.//SVD/JPEG/jmemsys.h:4: * Copyright (C) 1992-1997, Thomas G. Lane.
.//SVD/JPEG/jmemsys.h:8: * This include file defines the interface between the system-independent
.//SVD/JPEG/jmemsys.h:9: * and system-dependent portions of the JPEG memory manager.  No other
.//SVD/JPEG/jmemsys.h:10: * modules need include it.  (The system-independent portion is jmemmgr.c;
.//SVD/JPEG/jmemsys.h:11: * there are several different versions of the system-dependent portion.)
.//SVD/JPEG/jmemsys.h:13: * This file works as-is for the system-dependent memory managers supplied
.//SVD/JPEG/jmemsys.h:15: * custom memory manager.  If system-dependent changes are needed in
.//SVD/JPEG/jmemsys.h:22:/* Short forms of external names for systems with brain-damaged linkers. */
.//SVD/JPEG/jmemsys.h:44: * On an 80x86 machine using small-data memory model, these manage near heap.
.//SVD/JPEG/jmemsys.h:69: * to model the 64Kb-segment-size limit of far addressing on 80x86 machines.
.//SVD/JPEG/jmemsys.h:71: * On machines with 32-bit flat address spaces, any large constant may be used.
.//SVD/JPEG/jmemsys.h:91: * method is available, cinfo->mem->max_memory_to_use - already_allocated
.//SVD/JPEG/jmemsys.h:95: * (that'll just lead to more backing-store access than is really necessary).
.//SVD/JPEG/jmemsys.h:111: * backing-store object.  The read/write/close method pointers are called
.//SVD/JPEG/jmemsys.h:112: * by jmemmgr.c to manipulate the backing-store object; all other fields
.//SVD/JPEG/jmemsys.h:113: * are private to the system-dependent backing store routines.
.//SVD/JPEG/jmemsys.h:119:#ifdef USE_MSDOS_MEMMGR		/* DOS-specific junk */
.//SVD/JPEG/jmemsys.h:121:typedef unsigned short XMSH;	/* type of extended-memory handles */
.//SVD/JPEG/jmemsys.h:122:typedef unsigned short EMSH;	/* type of expanded-memory handles */
.//SVD/JPEG/jmemsys.h:132:#ifdef USE_MAC_MEMMGR		/* Mac-specific junk */
.//SVD/JPEG/jmemsys.h:140:  /* Methods for reading/writing/closing this backing-store object */
.//SVD/JPEG/jmemsys.h:152:  /* Private fields for system-dependent backing-store management */
.//SVD/JPEG/jmemsys.h:154:  /* For the MS-DOS manager (jmemdos.c), we need: */
.//SVD/JPEG/jmemsys.h:155:  handle_union handle;		/* reference to backing-store storage object */
.//SVD/JPEG/jmemsys.h:173: * Initial opening of a backing-store object.  This must fill in the
.//SVD/JPEG/jmemsys.h:186: * These routines take care of any system-dependent initialization and
.//SVD/JPEG/jmemsys.h:194: * all opened backing-store objects have been closed.
.//SVD/JPEG/jmorecfg.h:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jmorecfg.h:9: * JPEG software for special applications or support machine-dependent
.//SVD/JPEG/jmorecfg.h:16: *   8   for 8-bit sample values (the usual setting)
.//SVD/JPEG/jmorecfg.h:17: *   12  for 12-bit sample values
.//SVD/JPEG/jmorecfg.h:20: * We do not support run-time selection of data precision, sorry.
.//SVD/JPEG/jmorecfg.h:152:/* INT16 must hold at least the values -32768..32767. */
.//SVD/JPEG/jmorecfg.h:158:/* INT32 must hold at least signed 32-bit values. */
.//SVD/JPEG/jmorecfg.h:165: * images up to 64K*64K due to 16-bit fields in SOF markers.  Therefore
.//SVD/JPEG/jmorecfg.h:206:/* Here is the pseudo-keyword for declaring pointers that must be "far"
.//SVD/JPEG/jmorecfg.h:221: * in standard header files.  Or you may have conflicts with application-
.//SVD/JPEG/jmorecfg.h:265:#define DCT_FLOAT_SUPPORTED	/* floating-point: accurate, fast on fast HW */
.//SVD/JPEG/jmorecfg.h:270:#define C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
.//SVD/JPEG/jmorecfg.h:273:/* Note: if you selected 12-bit data precision, it is dangerous to turn off
.//SVD/JPEG/jmorecfg.h:274: * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit
.//SVD/JPEG/jmorecfg.h:286:#define D_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
.//SVD/JPEG/jmorecfg.h:293:#define QUANT_1PASS_SUPPORTED	    /* 1-pass color quantization? */
.//SVD/JPEG/jmorecfg.h:294:#define QUANT_2PASS_SUPPORTED	    /* 2-pass color quantization? */
.//SVD/JPEG/jmorecfg.h:320:/* Definitions for speed-related optimizations. */
.//SVD/JPEG/jmorecfg.h:338: * two 16-bit shorts is faster than multiplying two ints.  Define MULTIPLIER
.//SVD/JPEG/jmorecfg.h:351: * pre-ANSI compilers (because they insist on converting to double anyway).
.//SVD/JPEG/jmorecfg.h:352: * The code below therefore chooses float if we have ANSI-style prototypes.
.//SVD/JPEG/jpegint.h:4: * Copyright (C) 1991-1997, Thomas G. Lane.
.//SVD/JPEG/jpegint.h:18:	/* Remaining modes require a full-image buffer to have been created */
.//SVD/JPEG/jpegint.h:33:#define DSTATE_PRESCAN	204	/* performing dummy pass for 2-pass quant */
.//SVD/JPEG/jpegint.h:55:/* Main buffer control (downsampled-data buffer) */
.//SVD/JPEG/jpegint.h:142:  boolean is_dummy_pass;	/* True during 1st pass for 2-pass quant */
.//SVD/JPEG/jpegint.h:157:/* Main buffer control (downsampled-data buffer) */
.//SVD/JPEG/jpegint.h:196:  /* Read a restart marker --- exported for use by entropy decoder only */
.//SVD/JPEG/jpegint.h:199:  /* State of marker reader --- nominally internal, but applications
.//SVD/JPEG/jpegint.h:204:  int next_restart_num;		/* next restart number expected (0-7) */
.//SVD/JPEG/jpegint.h:286:	 (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
.//SVD/JPEG/jpegint.h:294:/* Short forms of external names for systems with brain-damaged linkers. */
.//SVD/JPEG/jpegint.h:385:/* Suppress undefined-structure complaints if necessary. */
.//SVD/JPEG/jpeglib.h:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//SVD/JPEG/jpeglib.h:45:#define NUM_ARITH_TBLS      16	/* Arith-coding tables are numbered 0..15 */
.//SVD/JPEG/jpeglib.h:67:typedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
.//SVD/JPEG/jpeglib.h:68:typedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */
.//SVD/JPEG/jpeglib.h:72:typedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
.//SVD/JPEG/jpeglib.h:73:typedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */
.//SVD/JPEG/jpeglib.h:121:  int component_index;		/* its index in SOF or cinfo->comp_info[] */
.//SVD/JPEG/jpeglib.h:168:  int last_col_width;		/* # of non-dummy blocks across in last MCU */
.//SVD/JPEG/jpeglib.h:169:  int last_row_height;		/* # of non-dummy blocks down in last MCU */
.//SVD/JPEG/jpeglib.h:177:  /* Private per-component storage for DCT or IDCT subsystem. */
.//SVD/JPEG/jpeglib.h:182:/* The script for encoding a multiple-scan file is an array of these: */
.//SVD/JPEG/jpeglib.h:220:	JDCT_FLOAT		/* floating-point: accurate, fast on fast HW */
.//SVD/JPEG/jpeglib.h:235:	JDITHER_FS		/* Floyd-Steinberg error diffusion dither */
.//SVD/JPEG/jpeglib.h:274:  /* Description of source image --- these fields must be filled in by
.//SVD/JPEG/jpeglib.h:286:  /* Compression parameters --- these fields must be set before calling
.//SVD/JPEG/jpeglib.h:309:  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
.//SVD/JPEG/jpeglib.h:310:  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
.//SVD/JPEG/jpeglib.h:311:  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
.//SVD/JPEG/jpeglib.h:314:  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
.//SVD/JPEG/jpeglib.h:315:  /* The default value of scan_info is NULL, which causes a single-scan
.//SVD/JPEG/jpeglib.h:316:   * sequential JPEG file to be emitted.  To create a multi-scan file,
.//SVD/JPEG/jpeglib.h:354:  JDIMENSION next_scanline;	/* 0 .. image_height-1  */
.//SVD/JPEG/jpeglib.h:417:  /* Basic description of image --- filled in by jpeg_read_header(). */
.//SVD/JPEG/jpeglib.h:425:  /* Decompression processing parameters --- these fields must be set before
.//SVD/JPEG/jpeglib.h:446:  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
.//SVD/JPEG/jpeglib.h:448:  /* these are significant only in buffered-image mode: */
.//SVD/JPEG/jpeglib.h:449:  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
.//SVD/JPEG/jpeglib.h:451:  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */
.//SVD/JPEG/jpeglib.h:473:   * The application can supply a colormap by setting colormap non-NULL before
.//SVD/JPEG/jpeglib.h:479:  JSAMPARRAY colormap;		/* The color map as a 2-D pixel array */
.//SVD/JPEG/jpeglib.h:489:  JDIMENSION output_scanline;	/* 0 .. output_height-1  */
.//SVD/JPEG/jpeglib.h:506:   * It is -1 when no data has yet been received, otherwise it is the point
.//SVD/JPEG/jpeglib.h:509:   * This pointer is NULL when reading a non-progressive file.
.//SVD/JPEG/jpeglib.h:511:  int (*coef_bits)[DCTSIZE2];	/* -1 or current Al value for each coef */
.//SVD/JPEG/jpeglib.h:513:  /* Internal JPEG parameters --- the application usually need not look at
.//SVD/JPEG/jpeglib.h:541:  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
.//SVD/JPEG/jpeglib.h:542:  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
.//SVD/JPEG/jpeglib.h:543:  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
.//SVD/JPEG/jpeglib.h:589:  JSAMPLE * sample_range_limit; /* table for fast range-limiting */
.//SVD/JPEG/jpeglib.h:670:  /* For recoverable corrupt-data errors, we emit a warning message,
.//SVD/JPEG/jpeglib.h:676:  long num_warnings;		/* number of corrupt-data warnings */
.//SVD/JPEG/jpeglib.h:693:  const char * const * addon_message_table; /* Non-library errors */
.//SVD/JPEG/jpeglib.h:796:   * used for virtual-array buffers.)  May be changed by outer application
.//SVD/JPEG/jpeglib.h:806:/* Routine signature for application-supplied marker processing methods.
.//SVD/JPEG/jpeglib.h:807: * Need not pass marker code since it is stored in cinfo->unread_marker.
.//SVD/JPEG/jpeglib.h:824:/* Short forms of external names for systems with brain-damaged linkers.
.//SVD/JPEG/jpeglib.h:883:/* Default error-management setup */
.//SVD/JPEG/jpeglib.h:892: * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
.//SVD/JPEG/jpeglib.h:967:#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
.//SVD/JPEG/jpeglib.h:986:/* Additional entry points for buffered-image mode. */
.//SVD/JPEG/jpeglib.h:1014:/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
.//SVD/JPEG/jpeglib.h:1036:/* Default restart-marker-resync procedure for use by data source modules */
.//SVD/JPEG/jpeglib.h:1051:/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
.//SVD/JPEG/jquant1.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//SVD/JPEG/jquant1.cpp:8: * This file contains 1-pass color quantization (color mapping) routines.
.//SVD/JPEG/jquant1.cpp:10: * color values.  Optional Floyd-Steinberg or ordered dithering is available.
.//SVD/JPEG/jquant1.cpp:21: * The main purpose of 1-pass quantization is to provide a fast, if not very
.//SVD/JPEG/jquant1.cpp:22: * high quality, colormapped output capability.  A 2-pass quantizer usually
.//SVD/JPEG/jquant1.cpp:27: * In 1-pass quantization the colormap must be chosen in advance of seeing the
.//SVD/JPEG/jquant1.cpp:36: * N-dimensional-array-subscript calculation.  Most of the arithmetic involved
.//SVD/JPEG/jquant1.cpp:42: *    sum( colorindex[component-number][pixel-component-value] )
.//SVD/JPEG/jquant1.cpp:60: * output value.  The dither value is equivalent to (0.5 - threshold) times
.//SVD/JPEG/jquant1.cpp:65: * The normal calculation would be to form pixel value + dither, range-limit
.//SVD/JPEG/jquant1.cpp:67: * We can skip the separate range-limiting step by extending the colorindex
.//SVD/JPEG/jquant1.cpp:74:#define ODITHER_MASK  (ODITHER_SIZE-1) /* mask for wrapping around counters */
.//SVD/JPEG/jquant1.cpp:80:  /* Bayer's order-4 dither array.  Generated by the code given in
.//SVD/JPEG/jquant1.cpp:82:   * The values in this array must range from 0 to ODITHER_CELLS-1.
.//SVD/JPEG/jquant1.cpp:103:/* Declarations for Floyd-Steinberg dithering.
.//SVD/JPEG/jquant1.cpp:107: * to its not-yet-processed neighbors using the standard F-S fractions,
.//SVD/JPEG/jquant1.cpp:110: * We work left-to-right on even rows, right-to-left on odd rows.
.//SVD/JPEG/jquant1.cpp:121: * end saves us from special-casing the first and last pixels.
.//SVD/JPEG/jquant1.cpp:146:  JSAMPARRAY sv_colormap;	/* The color map as a 2-D pixel array */
.//SVD/JPEG/jquant1.cpp:162:  /* Variables for Floyd-Steinberg dithering */
.//SVD/JPEG/jquant1.cpp:171: * Policy-making subroutines for create_colormap and create_colorindex.
.//SVD/JPEG/jquant1.cpp:191:  int nc = cinfo->out_color_components; /* number of color components */
.//SVD/JPEG/jquant1.cpp:192:  int max_colors = cinfo->desired_number_of_colors;
.//SVD/JPEG/jquant1.cpp:207:  iroot--;			/* now iroot = floor(root) */
.//SVD/JPEG/jquant1.cpp:228:      j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
.//SVD/JPEG/jquant1.cpp:275:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant1.cpp:281:  total_colors = select_ncolors(cinfo, cquantize->Ncolors);
.//SVD/JPEG/jquant1.cpp:284:  if (cinfo->out_color_components == 3)
.//SVD/JPEG/jquant1.cpp:286:	     total_colors, cquantize->Ncolors[0],
.//SVD/JPEG/jquant1.cpp:287:	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
.//SVD/JPEG/jquant1.cpp:292:  /* The colors are ordered in the map in standard row-major order, */
.//SVD/JPEG/jquant1.cpp:293:  /* i.e. rightmost (highest-indexed) color changes most rapidly. */
.//SVD/JPEG/jquant1.cpp:295:  colormap = (*cinfo->mem->alloc_sarray)
.//SVD/JPEG/jquant1.cpp:297:     (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);
.//SVD/JPEG/jquant1.cpp:303:  for (i = 0; i < cinfo->out_color_components; i++) {
.//SVD/JPEG/jquant1.cpp:305:    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
.//SVD/JPEG/jquant1.cpp:309:      val = output_value(cinfo, i, j, nci-1);
.//SVD/JPEG/jquant1.cpp:323:  cquantize->sv_colormap = colormap;
.//SVD/JPEG/jquant1.cpp:324:  cquantize->sv_actual = total_colors;
.//SVD/JPEG/jquant1.cpp:335:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant1.cpp:340:   * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
.//SVD/JPEG/jquant1.cpp:344:  if (cinfo->dither_mode == JDITHER_ORDERED) {
.//SVD/JPEG/jquant1.cpp:346:    cquantize->is_padded = TRUE;
.//SVD/JPEG/jquant1.cpp:349:    cquantize->is_padded = FALSE;
.//SVD/JPEG/jquant1.cpp:352:  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
.//SVD/JPEG/jquant1.cpp:355:     (JDIMENSION) cinfo->out_color_components);
.//SVD/JPEG/jquant1.cpp:358:  blksize = cquantize->sv_actual;
.//SVD/JPEG/jquant1.cpp:360:  for (i = 0; i < cinfo->out_color_components; i++) {
.//SVD/JPEG/jquant1.cpp:362:    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
.//SVD/JPEG/jquant1.cpp:367:      cquantize->colorindex[i] += MAXJSAMPLE;
.//SVD/JPEG/jquant1.cpp:371:    indexptr = cquantize->colorindex[i];
.//SVD/JPEG/jquant1.cpp:373:    k = largest_input_value(cinfo, i, 0, nci-1);
.//SVD/JPEG/jquant1.cpp:376:	k = largest_input_value(cinfo, i, ++val, nci-1);
.//SVD/JPEG/jquant1.cpp:383:	indexptr[-j] = indexptr[0];
.//SVD/JPEG/jquant1.cpp:391: * Create an ordered-dither array for a component having ncolors
.//SVD/JPEG/jquant1.cpp:403:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jquant1.cpp:405:  /* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
.//SVD/JPEG/jquant1.cpp:407:   * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).
.//SVD/JPEG/jquant1.cpp:408:   * On 16-bit-int machine, be careful to avoid overflow.
.//SVD/JPEG/jquant1.cpp:410:  den = 2 * ODITHER_CELLS * ((INT32) (ncolors - 1));
.//SVD/JPEG/jquant1.cpp:413:      num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
.//SVD/JPEG/jquant1.cpp:418:      odither[j][k] = (int) (num<0 ? -((-num)/den) : num/den);
.//SVD/JPEG/jquant1.cpp:426: * Create the ordered-dither tables.
.//SVD/JPEG/jquant1.cpp:434:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant1.cpp:438:  for (i = 0; i < cinfo->out_color_components; i++) {
.//SVD/JPEG/jquant1.cpp:439:    nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
.//SVD/JPEG/jquant1.cpp:442:      if (nci == cquantize->Ncolors[j]) {
.//SVD/JPEG/jquant1.cpp:443:	odither = cquantize->odither[j];
.//SVD/JPEG/jquant1.cpp:449:    cquantize->odither[i] = odither;
.//SVD/JPEG/jquant1.cpp:463:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant1.cpp:464:  JSAMPARRAY colorindex = cquantize->colorindex;
.//SVD/JPEG/jquant1.cpp:469:  JDIMENSION width = cinfo->output_width;
.//SVD/JPEG/jquant1.cpp:470:  register int nc = cinfo->out_color_components;
.//SVD/JPEG/jquant1.cpp:475:    for (col = width; col > 0; col--) {
.//SVD/JPEG/jquant1.cpp:491:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant1.cpp:494:  JSAMPROW colorindex0 = cquantize->colorindex[0];
.//SVD/JPEG/jquant1.cpp:495:  JSAMPROW colorindex1 = cquantize->colorindex[1];
.//SVD/JPEG/jquant1.cpp:496:  JSAMPROW colorindex2 = cquantize->colorindex[2];
.//SVD/JPEG/jquant1.cpp:499:  JDIMENSION width = cinfo->output_width;
.//SVD/JPEG/jquant1.cpp:504:    for (col = width; col > 0; col--) {
.//SVD/JPEG/jquant1.cpp:519:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant1.cpp:525:  int nc = cinfo->out_color_components;
.//SVD/JPEG/jquant1.cpp:529:  JDIMENSION width = cinfo->output_width;
.//SVD/JPEG/jquant1.cpp:535:    row_index = cquantize->row_index;
.//SVD/JPEG/jquant1.cpp:539:      colorindex_ci = cquantize->colorindex[ci];
.//SVD/JPEG/jquant1.cpp:540:      dither = cquantize->odither[ci][row_index];
.//SVD/JPEG/jquant1.cpp:543:      for (col = width; col > 0; col--) {
.//SVD/JPEG/jquant1.cpp:544:	/* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
.//SVD/JPEG/jquant1.cpp:546:	 * Range-limiting need not be done explicitly, as we have extended
.//SVD/JPEG/jquant1.cpp:547:	 * the colorindex table to produce the right answers for out-of-range
.//SVD/JPEG/jquant1.cpp:548:	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
.//SVD/JPEG/jquant1.cpp:559:    cquantize->row_index = row_index;
.//SVD/JPEG/jquant1.cpp:569:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant1.cpp:573:  JSAMPROW colorindex0 = cquantize->colorindex[0];
.//SVD/JPEG/jquant1.cpp:574:  JSAMPROW colorindex1 = cquantize->colorindex[1];
.//SVD/JPEG/jquant1.cpp:575:  JSAMPROW colorindex2 = cquantize->colorindex[2];
.//SVD/JPEG/jquant1.cpp:582:  JDIMENSION width = cinfo->output_width;
.//SVD/JPEG/jquant1.cpp:585:    row_index = cquantize->row_index;
.//SVD/JPEG/jquant1.cpp:588:    dither0 = cquantize->odither[0][row_index];
.//SVD/JPEG/jquant1.cpp:589:    dither1 = cquantize->odither[1][row_index];
.//SVD/JPEG/jquant1.cpp:590:    dither2 = cquantize->odither[2][row_index];
.//SVD/JPEG/jquant1.cpp:593:    for (col = width; col > 0; col--) {
.//SVD/JPEG/jquant1.cpp:604:    cquantize->row_index = row_index;
.//SVD/JPEG/jquant1.cpp:612:/* General case, with Floyd-Steinberg dithering */
.//SVD/JPEG/jquant1.cpp:614:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant1.cpp:626:  int nc = cinfo->out_color_components;
.//SVD/JPEG/jquant1.cpp:627:  int dir;			/* 1 for left-to-right, -1 for right-to-left */
.//SVD/JPEG/jquant1.cpp:632:  JDIMENSION width = cinfo->output_width;
.//SVD/JPEG/jquant1.cpp:633:  JSAMPLE *range_limit = cinfo->sample_range_limit;
.//SVD/JPEG/jquant1.cpp:643:      if (cquantize->on_odd_row) {
.//SVD/JPEG/jquant1.cpp:645:	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
.//SVD/JPEG/jquant1.cpp:646:	output_ptr += width-1;
.//SVD/JPEG/jquant1.cpp:647:	dir = -1;
.//SVD/JPEG/jquant1.cpp:648:	dirnc = -nc;
.//SVD/JPEG/jquant1.cpp:649:	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
.//SVD/JPEG/jquant1.cpp:654:	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
.//SVD/JPEG/jquant1.cpp:656:      colorindex_ci = cquantize->colorindex[ci];
.//SVD/JPEG/jquant1.cpp:657:      colormap_ci = cquantize->sv_colormap[ci];
.//SVD/JPEG/jquant1.cpp:663:      for (col = width; col > 0; col--) {
.//SVD/JPEG/jquant1.cpp:673:	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
.//SVD/JPEG/jquant1.cpp:674:	 * The maximum error is +- MAXJSAMPLE; this sets the required size
.//SVD/JPEG/jquant1.cpp:685:	cur -= GETJSAMPLE(colormap_ci[pixcode]);
.//SVD/JPEG/jquant1.cpp:688:	 * next-line error sums left by 1 column.
.//SVD/JPEG/jquant1.cpp:706:      /* Post-loop cleanup: we must unload the final error value into the
.//SVD/JPEG/jquant1.cpp:712:    cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
.//SVD/JPEG/jquant1.cpp:718: * Allocate workspace for Floyd-Steinberg errors.
.//SVD/JPEG/jquant1.cpp:724:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant1.cpp:728:  arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
.//SVD/JPEG/jquant1.cpp:729:  for (i = 0; i < cinfo->out_color_components; i++) {
.//SVD/JPEG/jquant1.cpp:730:    cquantize->fserrors[i] = (FSERRPTR)
.//SVD/JPEG/jquant1.cpp:731:      (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
.//SVD/JPEG/jquant1.cpp:737: * Initialize for one-pass color quantization.
.//SVD/JPEG/jquant1.cpp:743:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant1.cpp:748:  cinfo->colormap = cquantize->sv_colormap;
.//SVD/JPEG/jquant1.cpp:749:  cinfo->actual_number_of_colors = cquantize->sv_actual;
.//SVD/JPEG/jquant1.cpp:752:  switch (cinfo->dither_mode) {
.//SVD/JPEG/jquant1.cpp:754:    if (cinfo->out_color_components == 3)
.//SVD/JPEG/jquant1.cpp:755:      cquantize->pub.color_quantize = color_quantize3;
.//SVD/JPEG/jquant1.cpp:757:      cquantize->pub.color_quantize = color_quantize;
.//SVD/JPEG/jquant1.cpp:760:    if (cinfo->out_color_components == 3)
.//SVD/JPEG/jquant1.cpp:761:      cquantize->pub.color_quantize = quantize3_ord_dither;
.//SVD/JPEG/jquant1.cpp:763:      cquantize->pub.color_quantize = quantize_ord_dither;
.//SVD/JPEG/jquant1.cpp:764:    cquantize->row_index = 0;	/* initialize state for ordered dither */
.//SVD/JPEG/jquant1.cpp:769:    if (! cquantize->is_padded)
.//SVD/JPEG/jquant1.cpp:771:    /* Create ordered-dither tables if we didn't already. */
.//SVD/JPEG/jquant1.cpp:772:    if (cquantize->odither[0] == NULL)
.//SVD/JPEG/jquant1.cpp:776:    cquantize->pub.color_quantize = quantize_fs_dither;
.//SVD/JPEG/jquant1.cpp:777:    cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
.//SVD/JPEG/jquant1.cpp:778:    /* Allocate Floyd-Steinberg workspace if didn't already. */
.//SVD/JPEG/jquant1.cpp:779:    if (cquantize->fserrors[0] == NULL)
.//SVD/JPEG/jquant1.cpp:782:    arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
.//SVD/JPEG/jquant1.cpp:783:    for (i = 0; i < cinfo->out_color_components; i++)
.//SVD/JPEG/jquant1.cpp:784:      jzero_far((void FAR *) cquantize->fserrors[i], arraysize);
.//SVD/JPEG/jquant1.cpp:800:  /* no work in 1-pass case */
.//SVD/JPEG/jquant1.cpp:817: * Module initialization routine for 1-pass color quantization.
.//SVD/JPEG/jquant1.cpp:826:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jquant1.cpp:828:  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
.//SVD/JPEG/jquant1.cpp:829:  cquantize->pub.start_pass = start_pass_1_quant;
.//SVD/JPEG/jquant1.cpp:830:  cquantize->pub.finish_pass = finish_pass_1_quant;
.//SVD/JPEG/jquant1.cpp:831:  cquantize->pub.new_color_map = new_color_map_1_quant;
.//SVD/JPEG/jquant1.cpp:832:  cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
.//SVD/JPEG/jquant1.cpp:833:  cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */
.//SVD/JPEG/jquant1.cpp:836:  if (cinfo->out_color_components > MAX_Q_COMPS)
.//SVD/JPEG/jquant1.cpp:839:  if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
.//SVD/JPEG/jquant1.cpp:846:  /* Allocate Floyd-Steinberg workspace now if requested.
.//SVD/JPEG/jquant1.cpp:852:  if (cinfo->dither_mode == JDITHER_FS)
.//SVD/JPEG/jquant2.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//SVD/JPEG/jquant2.cpp:8: * This file contains 2-pass color quantization (color mapping) routines.
.//SVD/JPEG/jquant2.cpp:11: * Floyd-Steinberg dithering.
.//SVD/JPEG/jquant2.cpp:13: * externally-given color map.
.//SVD/JPEG/jquant2.cpp:28: * This module implements the well-known Heckbert paradigm for color
.//SVD/JPEG/jquant2.cpp:32: *   Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.
.//SVD/JPEG/jquant2.cpp:40: * Next, the color-selection step begins with a box representing the whole
.//SVD/JPEG/jquant2.cpp:46: * color (optionally after applying a Floyd-Steinberg dithering correction).
.//SVD/JPEG/jquant2.cpp:50: * Heckbert-style quantizers vary a good deal in their policies for choosing
.//SVD/JPEG/jquant2.cpp:61: * externally-supplied colormap.  We have therefore abandoned that approach.
.//SVD/JPEG/jquant2.cpp:62: * The present code works in the post-conversion color space, typically RGB.
.//SVD/JPEG/jquant2.cpp:69: * If you want to use this code to quantize a non-RGB color space, you'll
.//SVD/JPEG/jquant2.cpp:112: * and clamping those that do overflow to the maximum value will give close-
.//SVD/JPEG/jquant2.cpp:114: * to 128Kb, which is a useful savings on PC-class machines.
.//SVD/JPEG/jquant2.cpp:115: * (In the second pass the histogram space is re-used for pixel mapping data;
.//SVD/JPEG/jquant2.cpp:120: * of a true 3-D array, we use a row of pointers to 2-D arrays.  Each
.//SVD/JPEG/jquant2.cpp:122: * each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that
.//SVD/JPEG/jquant2.cpp:142:#define C0_SHIFT  (BITS_IN_JSAMPLE-HIST_C0_BITS)
.//SVD/JPEG/jquant2.cpp:143:#define C1_SHIFT  (BITS_IN_JSAMPLE-HIST_C1_BITS)
.//SVD/JPEG/jquant2.cpp:144:#define C2_SHIFT  (BITS_IN_JSAMPLE-HIST_C2_BITS)
.//SVD/JPEG/jquant2.cpp:152:typedef hist1d FAR * hist2d;	/* type for the 2nd-level pointers */
.//SVD/JPEG/jquant2.cpp:153:typedef hist2d * hist3d;	/* type for top-level pointer */
.//SVD/JPEG/jquant2.cpp:156:/* Declarations for Floyd-Steinberg dithering.
.//SVD/JPEG/jquant2.cpp:160: * to its not-yet-processed neighbors using the standard F-S fractions,
.//SVD/JPEG/jquant2.cpp:163: * We work left-to-right on even rows, right-to-left on odd rows.
.//SVD/JPEG/jquant2.cpp:173: * each end saves us from special-casing the first and last pixels.
.//SVD/JPEG/jquant2.cpp:205:  /* Variables for Floyd-Steinberg dithering */
.//SVD/JPEG/jquant2.cpp:227:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant2.cpp:230:  register hist3d histogram = cquantize->histogram;
.//SVD/JPEG/jquant2.cpp:233:  JDIMENSION width = cinfo->output_width;
.//SVD/JPEG/jquant2.cpp:237:    for (col = width; col > 0; col--) {
.//SVD/JPEG/jquant2.cpp:244:	(*histp)--;
.//SVD/JPEG/jquant2.cpp:263:  /* The volume (actually 2-norm) of the box */
.//SVD/JPEG/jquant2.cpp:283:    if (boxp->colorcount > maxc && boxp->volume > 0) {
.//SVD/JPEG/jquant2.cpp:285:      maxc = boxp->colorcount;
.//SVD/JPEG/jquant2.cpp:303:    if (boxp->volume > maxv) {
.//SVD/JPEG/jquant2.cpp:305:      maxv = boxp->volume;
.//SVD/JPEG/jquant2.cpp:317:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant2.cpp:318:  hist3d histogram = cquantize->histogram;
.//SVD/JPEG/jquant2.cpp:325:  c0min = boxp->c0min;  c0max = boxp->c0max;
.//SVD/JPEG/jquant2.cpp:326:  c1min = boxp->c1min;  c1max = boxp->c1max;
.//SVD/JPEG/jquant2.cpp:327:  c2min = boxp->c2min;  c2max = boxp->c2max;
.//SVD/JPEG/jquant2.cpp:335:	    boxp->c0min = c0min = c0;
.//SVD/JPEG/jquant2.cpp:341:    for (c0 = c0max; c0 >= c0min; c0--)
.//SVD/JPEG/jquant2.cpp:346:	    boxp->c0max = c0max = c0;
.//SVD/JPEG/jquant2.cpp:357:	    boxp->c1min = c1min = c1;
.//SVD/JPEG/jquant2.cpp:363:    for (c1 = c1max; c1 >= c1min; c1--)
.//SVD/JPEG/jquant2.cpp:368:	    boxp->c1max = c1max = c1;
.//SVD/JPEG/jquant2.cpp:379:	    boxp->c2min = c2min = c2;
.//SVD/JPEG/jquant2.cpp:385:    for (c2 = c2max; c2 >= c2min; c2--)
.//SVD/JPEG/jquant2.cpp:390:	    boxp->c2max = c2max = c2;
.//SVD/JPEG/jquant2.cpp:397:   * We use 2-norm rather than real volume here; this biases the method
.//SVD/JPEG/jquant2.cpp:400:   * Since the differences are expressed in histogram-cell units,
.//SVD/JPEG/jquant2.cpp:404:  dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
.//SVD/JPEG/jquant2.cpp:405:  dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
.//SVD/JPEG/jquant2.cpp:406:  dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
.//SVD/JPEG/jquant2.cpp:407:  boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
.//SVD/JPEG/jquant2.cpp:419:  boxp->colorcount = ccount;
.//SVD/JPEG/jquant2.cpp:445:    b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
.//SVD/JPEG/jquant2.cpp:446:    b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
.//SVD/JPEG/jquant2.cpp:451:    c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
.//SVD/JPEG/jquant2.cpp:452:    c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
.//SVD/JPEG/jquant2.cpp:453:    c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
.//SVD/JPEG/jquant2.cpp:474:      lb = (b1->c0max + b1->c0min) / 2;
.//SVD/JPEG/jquant2.cpp:475:      b1->c0max = lb;
.//SVD/JPEG/jquant2.cpp:476:      b2->c0min = lb+1;
.//SVD/JPEG/jquant2.cpp:479:      lb = (b1->c1max + b1->c1min) / 2;
.//SVD/JPEG/jquant2.cpp:480:      b1->c1max = lb;
.//SVD/JPEG/jquant2.cpp:481:      b2->c1min = lb+1;
.//SVD/JPEG/jquant2.cpp:484:      lb = (b1->c2max + b1->c2min) / 2;
.//SVD/JPEG/jquant2.cpp:485:      b1->c2max = lb;
.//SVD/JPEG/jquant2.cpp:486:      b2->c2min = lb+1;
.//SVD/JPEG/jquant2.cpp:504:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant2.cpp:505:  hist3d histogram = cquantize->histogram;
.//SVD/JPEG/jquant2.cpp:515:  c0min = boxp->c0min;  c0max = boxp->c0max;
.//SVD/JPEG/jquant2.cpp:516:  c1min = boxp->c1min;  c1max = boxp->c1max;
.//SVD/JPEG/jquant2.cpp:517:  c2min = boxp->c2min;  c2max = boxp->c2max;
.//SVD/JPEG/jquant2.cpp:532:  cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
.//SVD/JPEG/jquant2.cpp:533:  cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
.//SVD/JPEG/jquant2.cpp:534:  cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
.//SVD/JPEG/jquant2.cpp:547:  boxlist = (boxptr) (*cinfo->mem->alloc_small)
.//SVD/JPEG/jquant2.cpp:557:  /* Shrink it to actually-used volume and set its statistics */
.//SVD/JPEG/jquant2.cpp:559:  /* Perform median-cut to produce final box list */
.//SVD/JPEG/jquant2.cpp:564:  cinfo->actual_number_of_colors = numboxes;
.//SVD/JPEG/jquant2.cpp:570: * These routines are concerned with the time-critical task of mapping input
.//SVD/JPEG/jquant2.cpp:573: * We re-use the histogram space as an "inverse color map", essentially a
.//SVD/JPEG/jquant2.cpp:574: * cache for the results of nearest-color searches.  All colors within a
.//SVD/JPEG/jquant2.cpp:593: * it needs a work array to hold the best-distance-so-far for each histogram
.//SVD/JPEG/jquant2.cpp:606: * three-fourths of the colormap entries are rejected by Heckbert's criterion,
.//SVD/JPEG/jquant2.cpp:614: * faster than the brute-force method, but it is also far more complex and
.//SVD/JPEG/jquant2.cpp:618: * refined method might be faster than the present code --- but then again,
.//SVD/JPEG/jquant2.cpp:624:#define BOX_C0_LOG  (HIST_C0_BITS-3)
.//SVD/JPEG/jquant2.cpp:625:#define BOX_C1_LOG  (HIST_C1_BITS-3)
.//SVD/JPEG/jquant2.cpp:626:#define BOX_C2_LOG  (HIST_C2_BITS-3)
.//SVD/JPEG/jquant2.cpp:642: * inner-loop variables.
.//SVD/JPEG/jquant2.cpp:657:  int numcolors = cinfo->actual_number_of_colors;
.//SVD/JPEG/jquant2.cpp:665:   * Actually we compute the coordinates of the center of the upper-corner
.//SVD/JPEG/jquant2.cpp:670:  maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
.//SVD/JPEG/jquant2.cpp:672:  maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
.//SVD/JPEG/jquant2.cpp:674:  maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
.//SVD/JPEG/jquant2.cpp:678:   *  1. its minimum squared-distance to any point in the update box
.//SVD/JPEG/jquant2.cpp:680:   *  2. its maximum squared-distance to any point in the update box.
.//SVD/JPEG/jquant2.cpp:688:    /* We compute the squared-c0-distance term, then add in the other two. */
.//SVD/JPEG/jquant2.cpp:689:    x = GETJSAMPLE(cinfo->colormap[0][i]);
.//SVD/JPEG/jquant2.cpp:691:      tdist = (x - minc0) * C0_SCALE;
.//SVD/JPEG/jquant2.cpp:693:      tdist = (x - maxc0) * C0_SCALE;
.//SVD/JPEG/jquant2.cpp:696:      tdist = (x - maxc0) * C0_SCALE;
.//SVD/JPEG/jquant2.cpp:698:      tdist = (x - minc0) * C0_SCALE;
.//SVD/JPEG/jquant2.cpp:704:	tdist = (x - maxc0) * C0_SCALE;
.//SVD/JPEG/jquant2.cpp:707:	tdist = (x - minc0) * C0_SCALE;
.//SVD/JPEG/jquant2.cpp:712:    x = GETJSAMPLE(cinfo->colormap[1][i]);
.//SVD/JPEG/jquant2.cpp:714:      tdist = (x - minc1) * C1_SCALE;
.//SVD/JPEG/jquant2.cpp:716:      tdist = (x - maxc1) * C1_SCALE;
.//SVD/JPEG/jquant2.cpp:719:      tdist = (x - maxc1) * C1_SCALE;
.//SVD/JPEG/jquant2.cpp:721:      tdist = (x - minc1) * C1_SCALE;
.//SVD/JPEG/jquant2.cpp:726:	tdist = (x - maxc1) * C1_SCALE;
.//SVD/JPEG/jquant2.cpp:729:	tdist = (x - minc1) * C1_SCALE;
.//SVD/JPEG/jquant2.cpp:734:    x = GETJSAMPLE(cinfo->colormap[2][i]);
.//SVD/JPEG/jquant2.cpp:736:      tdist = (x - minc2) * C2_SCALE;
.//SVD/JPEG/jquant2.cpp:738:      tdist = (x - maxc2) * C2_SCALE;
.//SVD/JPEG/jquant2.cpp:741:      tdist = (x - maxc2) * C2_SCALE;
.//SVD/JPEG/jquant2.cpp:743:      tdist = (x - minc2) * C2_SCALE;
.//SVD/JPEG/jquant2.cpp:748:	tdist = (x - maxc2) * C2_SCALE;
.//SVD/JPEG/jquant2.cpp:751:	tdist = (x - minc2) * C2_SCALE;
.//SVD/JPEG/jquant2.cpp:793:  /* This array holds the distance to the nearest-so-far color for each cell */
.//SVD/JPEG/jquant2.cpp:796:  /* Initialize best-distance for each cell of the update box */
.//SVD/JPEG/jquant2.cpp:798:  for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
.//SVD/JPEG/jquant2.cpp:803:   * If that's less than best-so-far, update best distance and color number.
.//SVD/JPEG/jquant2.cpp:814:    inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
.//SVD/JPEG/jquant2.cpp:816:    inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
.//SVD/JPEG/jquant2.cpp:818:    inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
.//SVD/JPEG/jquant2.cpp:828:    for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
.//SVD/JPEG/jquant2.cpp:831:      for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
.//SVD/JPEG/jquant2.cpp:834:	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
.//SVD/JPEG/jquant2.cpp:856:/* Fill the inverse-colormap entries in the update box that contains */
.//SVD/JPEG/jquant2.cpp:860:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant2.cpp:861:  hist3d histogram = cquantize->histogram;
.//SVD/JPEG/jquant2.cpp:919:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant2.cpp:920:  hist3d histogram = cquantize->histogram;
.//SVD/JPEG/jquant2.cpp:926:  JDIMENSION width = cinfo->output_width;
.//SVD/JPEG/jquant2.cpp:931:    for (col = width; col > 0; col--) {
.//SVD/JPEG/jquant2.cpp:942:      *outptr++ = (JSAMPLE) (*cachep - 1);
.//SVD/JPEG/jquant2.cpp:951:/* This version performs Floyd-Steinberg dithering */
.//SVD/JPEG/jquant2.cpp:953:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant2.cpp:954:  hist3d histogram = cquantize->histogram;
.//SVD/JPEG/jquant2.cpp:962:  int dir;			/* +1 or -1 depending on direction */
.//SVD/JPEG/jquant2.cpp:966:  JDIMENSION width = cinfo->output_width;
.//SVD/JPEG/jquant2.cpp:967:  JSAMPLE *range_limit = cinfo->sample_range_limit;
.//SVD/JPEG/jquant2.cpp:968:  int *error_limit = cquantize->error_limiter;
.//SVD/JPEG/jquant2.cpp:969:  JSAMPROW colormap0 = cinfo->colormap[0];
.//SVD/JPEG/jquant2.cpp:970:  JSAMPROW colormap1 = cinfo->colormap[1];
.//SVD/JPEG/jquant2.cpp:971:  JSAMPROW colormap2 = cinfo->colormap[2];
.//SVD/JPEG/jquant2.cpp:977:    if (cquantize->on_odd_row) {
.//SVD/JPEG/jquant2.cpp:979:      inptr += (width-1) * 3;	/* so point to rightmost pixel */
.//SVD/JPEG/jquant2.cpp:980:      outptr += width-1;
.//SVD/JPEG/jquant2.cpp:981:      dir = -1;
.//SVD/JPEG/jquant2.cpp:982:      dir3 = -3;
.//SVD/JPEG/jquant2.cpp:983:      errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
.//SVD/JPEG/jquant2.cpp:984:      cquantize->on_odd_row = FALSE; /* flip for next time */
.//SVD/JPEG/jquant2.cpp:989:      errorptr = cquantize->fserrors; /* => entry before first real column */
.//SVD/JPEG/jquant2.cpp:990:      cquantize->on_odd_row = TRUE; /* flip for next time */
.//SVD/JPEG/jquant2.cpp:998:    for (col = width; col > 0; col--) {
.//SVD/JPEG/jquant2.cpp:1016:      /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
.//SVD/JPEG/jquant2.cpp:1017:       * The maximum error is +- MAXJSAMPLE (or less with error limiting);
.//SVD/JPEG/jquant2.cpp:1033:      { register int pixcode = *cachep - 1;
.//SVD/JPEG/jquant2.cpp:1036:	cur0 -= GETJSAMPLE(colormap0[pixcode]);
.//SVD/JPEG/jquant2.cpp:1037:	cur1 -= GETJSAMPLE(colormap1[pixcode]);
.//SVD/JPEG/jquant2.cpp:1038:	cur2 -= GETJSAMPLE(colormap2[pixcode]);
.//SVD/JPEG/jquant2.cpp:1042:       * next-line error sums left by 1 column.
.//SVD/JPEG/jquant2.cpp:1079:    /* Post-loop cleanup: we must unload the final error values into the
.//SVD/JPEG/jquant2.cpp:1091: * Initialize the error-limiting transfer function (lookup table).
.//SVD/JPEG/jquant2.cpp:1092: * The raw F-S error computation can potentially compute error values of up to
.//SVD/JPEG/jquant2.cpp:1093: * +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be
.//SVD/JPEG/jquant2.cpp:1095: * effects include weird fringes at color-area boundaries, isolated bright
.//SVD/JPEG/jquant2.cpp:1102: * A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty
.//SVD/JPEG/jquant2.cpp:1111:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant2.cpp:1115:  table = (int *) (*cinfo->mem->alloc_small)
.//SVD/JPEG/jquant2.cpp:1117:  table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
.//SVD/JPEG/jquant2.cpp:1118:  cquantize->error_limiter = table;
.//SVD/JPEG/jquant2.cpp:1121:  /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
.//SVD/JPEG/jquant2.cpp:1124:    table[in] = out; table[-in] = -out;
.//SVD/JPEG/jquant2.cpp:1126:  /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
.//SVD/JPEG/jquant2.cpp:1128:    table[in] = out; table[-in] = -out;
.//SVD/JPEG/jquant2.cpp:1132:    table[in] = out; table[-in] = -out;
.//SVD/JPEG/jquant2.cpp:1145:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant2.cpp:1147:  /* Select the representative colors and fill in cinfo->colormap */
.//SVD/JPEG/jquant2.cpp:1148:  cinfo->colormap = cquantize->sv_colormap;
.//SVD/JPEG/jquant2.cpp:1149:  select_colors(cinfo, cquantize->desired);
.//SVD/JPEG/jquant2.cpp:1151:  cquantize->needs_zeroed = TRUE;
.//SVD/JPEG/jquant2.cpp:1169:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant2.cpp:1170:  hist3d histogram = cquantize->histogram;
.//SVD/JPEG/jquant2.cpp:1173:  /* Only F-S dithering or no dithering is supported. */
.//SVD/JPEG/jquant2.cpp:1174:  /* If user asks for ordered dither, give him F-S. */
.//SVD/JPEG/jquant2.cpp:1175:  if (cinfo->dither_mode != JDITHER_NONE)
.//SVD/JPEG/jquant2.cpp:1176:    cinfo->dither_mode = JDITHER_FS;
.//SVD/JPEG/jquant2.cpp:1180:    cquantize->pub.color_quantize = prescan_quantize;
.//SVD/JPEG/jquant2.cpp:1181:    cquantize->pub.finish_pass = finish_pass1;
.//SVD/JPEG/jquant2.cpp:1182:    cquantize->needs_zeroed = TRUE; /* Always zero histogram */
.//SVD/JPEG/jquant2.cpp:1185:    if (cinfo->dither_mode == JDITHER_FS)
.//SVD/JPEG/jquant2.cpp:1186:      cquantize->pub.color_quantize = pass2_fs_dither;
.//SVD/JPEG/jquant2.cpp:1188:      cquantize->pub.color_quantize = pass2_no_dither;
.//SVD/JPEG/jquant2.cpp:1189:    cquantize->pub.finish_pass = finish_pass2;
.//SVD/JPEG/jquant2.cpp:1192:    i = cinfo->actual_number_of_colors;
.//SVD/JPEG/jquant2.cpp:1198:    if (cinfo->dither_mode == JDITHER_FS) {
.//SVD/JPEG/jquant2.cpp:1199:      size_t arraysize = (size_t) ((cinfo->output_width + 2) *
.//SVD/JPEG/jquant2.cpp:1201:      /* Allocate Floyd-Steinberg workspace if we didn't already. */
.//SVD/JPEG/jquant2.cpp:1202:      if (cquantize->fserrors == NULL)
.//SVD/JPEG/jquant2.cpp:1203:	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
.//SVD/JPEG/jquant2.cpp:1206:      jzero_far((void FAR *) cquantize->fserrors, arraysize);
.//SVD/JPEG/jquant2.cpp:1207:      /* Make the error-limit table if we didn't already. */
.//SVD/JPEG/jquant2.cpp:1208:      if (cquantize->error_limiter == NULL)
.//SVD/JPEG/jquant2.cpp:1210:      cquantize->on_odd_row = FALSE;
.//SVD/JPEG/jquant2.cpp:1215:  if (cquantize->needs_zeroed) {
.//SVD/JPEG/jquant2.cpp:1220:    cquantize->needs_zeroed = FALSE;
.//SVD/JPEG/jquant2.cpp:1232:  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
.//SVD/JPEG/jquant2.cpp:1235:  cquantize->needs_zeroed = TRUE;
.//SVD/JPEG/jquant2.cpp:1240: * Module initialization routine for 2-pass color quantization.
.//SVD/JPEG/jquant2.cpp:1250:    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
.//SVD/JPEG/jquant2.cpp:1252:  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
.//SVD/JPEG/jquant2.cpp:1253:  cquantize->pub.start_pass = start_pass_2_quant;
.//SVD/JPEG/jquant2.cpp:1254:  cquantize->pub.new_color_map = new_color_map_2_quant;
.//SVD/JPEG/jquant2.cpp:1255:  cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
.//SVD/JPEG/jquant2.cpp:1256:  cquantize->error_limiter = NULL;
.//SVD/JPEG/jquant2.cpp:1259:  if (cinfo->out_color_components != 3)
.//SVD/JPEG/jquant2.cpp:1263:  cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
.//SVD/JPEG/jquant2.cpp:1266:    cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
.//SVD/JPEG/jquant2.cpp:1270:  cquantize->needs_zeroed = TRUE; /* histogram is garbage now */
.//SVD/JPEG/jquant2.cpp:1276:  if (cinfo->enable_2pass_quant) {
.//SVD/JPEG/jquant2.cpp:1278:    int desired = cinfo->desired_number_of_colors;
.//SVD/JPEG/jquant2.cpp:1285:    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
.//SVD/JPEG/jquant2.cpp:1287:    cquantize->desired = desired;
.//SVD/JPEG/jquant2.cpp:1289:    cquantize->sv_colormap = NULL;
.//SVD/JPEG/jquant2.cpp:1291:  /* Only F-S dithering or no dithering is supported. */
.//SVD/JPEG/jquant2.cpp:1292:  /* If user asks for ordered dither, give him F-S. */
.//SVD/JPEG/jquant2.cpp:1293:  if (cinfo->dither_mode != JDITHER_NONE)
.//SVD/JPEG/jquant2.cpp:1294:    cinfo->dither_mode = JDITHER_FS;
.//SVD/JPEG/jquant2.cpp:1296:  /* Allocate Floyd-Steinberg workspace if necessary.
.//SVD/JPEG/jquant2.cpp:1301:  if (cinfo->dither_mode == JDITHER_FS) {
.//SVD/JPEG/jquant2.cpp:1302:    cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
.//SVD/JPEG/jquant2.cpp:1304:       (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
.//SVD/JPEG/jquant2.cpp:1305:    /* Might as well create the error-limiting table too. */
.//SVD/JPEG/jutils.cpp:4: * Copyright (C) 1991-1996, Thomas G. Lane.
.//SVD/JPEG/jutils.cpp:20: * jpeg_zigzag_order[i] is the zigzag-order position of the i'th element
.//SVD/JPEG/jutils.cpp:40: * jpeg_natural_order[i] is the natural-order position of the i'th element
.//SVD/JPEG/jutils.cpp:46: * wild stores without adding an inner-loop test, we put some extra
.//SVD/JPEG/jutils.cpp:49: * The worst case would be a run-length of 15, which means we need 16
.//SVD/JPEG/jutils.cpp:76:  return (a + b - 1L) / b;
.//SVD/JPEG/jutils.cpp:85:  a += b - 1L;
.//SVD/JPEG/jutils.cpp:86:  return a - (a % b);
.//SVD/JPEG/jutils.cpp:91: * and coefficient-block arrays.  This won't work on 80x86 because the arrays
.//SVD/JPEG/jutils.cpp:92: * are FAR and we're assuming a small-pointer memory model.  However, some
.//SVD/JPEG/jutils.cpp:93: * DOS compilers provide far-pointer versions of memcpy() and memset() even
.//SVD/JPEG/jutils.cpp:94: * in the small-model libraries.  These will be used if USE_FMEM is defined.
.//SVD/JPEG/jutils.cpp:131:  for (row = num_rows; row > 0; row--) {
.//SVD/JPEG/jutils.cpp:137:    for (count = num_cols; count > 0; count--)
.//SVD/JPEG/jutils.cpp:157:  for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {
.//SVD/JPEG/jutils.cpp:167:/* This might be sample-array data, block-array data, or alloc_large data. */
.//SVD/JPEG/jutils.cpp:175:  for (count = bytestozero; count > 0; count--) {
.//SVD/JPEG/jversion.h:4: * Copyright (C) 1991-1998, Thomas G. Lane.
.//SVD/JPEG/jversion.h:12:#define JVERSION	"6b  27-Mar-1998"
.//SVD/JPEG/Makefile:61:debug: CFLAGS += -DDEBUG -g3
.//SVD/JPEG/Makefile:64:release: CFLAGS += -O2 -DRELEASE -pipe -fomit-frame-pointer
.//SVD/JPEG/Makefile:71:	/bin/rm -f ${CLEAN}
.//SVD/JPEG/Makefile:74:	${CC} ${CFLAGS} -c $<
.//SVD/JPEG/Makefile:77:	makedepend -- ${CFLAGS} -- ${addsuffix .cpp, ${SRCS}}
.//SVD/JPEG/Makefile:80:ckconfig.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:88:ckconfig.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:92:jcapimin.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:100:jcapimin.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:104:jcapistd.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:112:jcapistd.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:116:jccoefct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:124:jccoefct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:128:jccolor.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:135:jccolor.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:139:jcdctmgr.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:147:jcdctmgr.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:152:jchuff.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:159:jchuff.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:164:jcinit.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:171:jcinit.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:175:jcmainct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:183:jcmainct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:187:jcmarker.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:195:jcmarker.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:199:jcmaster.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:207:jcmaster.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:211:jcomapi.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:218:jcomapi.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:222:jcparam.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:229:jcparam.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:233:jcphuff.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:240:jcphuff.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:245:jcprepct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:253:jcprepct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:257:jcsample.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:265:jcsample.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:269:jctrans.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:276:jctrans.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:280:jdapimin.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:288:jdapimin.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:292:jdapistd.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:300:jdapistd.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:304:jdatadst.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:312:jdatadst.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:316:jdatasrc.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:324:jdatasrc.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:328:jdcoefct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:336:jdcoefct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:340:jdcolor.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:347:jdcolor.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:351:jddctmgr.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:359:jddctmgr.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:364:jdhuff.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:371:jdhuff.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:376:jdinput.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:383:jdinput.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:387:jdmainct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:395:jdmainct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:399:jdmarker.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:407:jdmarker.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:411:jdmaster.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:419:jdmaster.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:423:jdmerge.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:430:jdmerge.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:434:jdphuff.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:441:jdphuff.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:446:jdpostct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:454:jdpostct.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:458:jdsample.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:466:jdsample.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:470:jdtrans.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:477:jdtrans.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:481:jerror.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:488:jerror.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:493:jfdctflt.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:501:jfdctflt.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:506:jfdctfst.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:514:jfdctfst.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:519:jfdctint.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:527:jfdctint.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:532:jidctflt.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:540:jidctflt.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:545:jidctfst.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:553:jidctfst.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:558:jidctint.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:566:jidctint.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:571:jidctred.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:579:jidctred.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:584:jmemmgr.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:591:jmemmgr.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:596:jmemnobs.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:604:jmemnobs.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:609:jquant1.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:616:jquant1.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:620:jquant2.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:627:jquant2.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile:631:jutils.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stddef.h
.//SVD/JPEG/Makefile:638:jutils.o: /usr/lib/gcc/i386-redhat-linux/3.4.4/include/stdarg.h
.//SVD/JPEG/Makefile.bak:61:debug: CFLAGS += -DDEBUG -g3
.//SVD/JPEG/Makefile.bak:64:release: CFLAGS += -O2 -DRELEASE -pipe -fomit-frame-pointer
.//SVD/JPEG/Makefile.bak:71:	/bin/rm -f ${CLEAN}
.//SVD/JPEG/Makefile.bak:74:	${CC} ${CFLAGS} -c $<
.//SVD/JPEG/Makefile.bak:77:	makedepend -- ${CFLAGS} -- ${addsuffix .cpp, ${SRCS}}
.//SVD/MatrixMNTC.h:71:    const GXMatrixMNTC<Coord>& operator-= (const GXMatrixMNTC<Coord>& toAdd);
.//SVD/MatrixMNTC.h:78:    friend GXMatrixMNTC<Coord> operator- (const GXMatrixMNTC<Coord>& A, 
.//SVD/MatrixMNTC.h:87:    friend GXMatrixMNTC<Coord> operator- (const GXMatrixMNTC<Coord>& M);
.//SVD/MatrixMNTC.h:114:GXMatrixMNTC<Coord> operator- (const GXMatrixMNTC<Coord>& A,const GXMatrixMNTC<Coord>& B);
.//SVD/MatrixMNTC.h:126:GXMatrixMNTC<Coord> operator- (const GXMatrixMNTC<Coord>& M);
.//SVD/MatrixMNTC.inl:130:            if ((i != j) && (Get(i,j) != -Get(j,i)))
.//SVD/MatrixMNTC.inl:292:    const GXMatrixMNTC<Coord>& GXMatrixMNTC<Coord>::operator-= (const GXMatrixMNTC<Coord>& toAdd)
.//SVD/MatrixMNTC.inl:298:        m_pElements[i] -= toAdd.m_pElements[i];
.//SVD/MatrixMNTC.inl:342:// non-member operators ////////////////////////////////////////////////////////////////
.//SVD/MatrixMNTC.inl:391:    GXMatrixMNTC<Coord> operator - (const GXMatrixMNTC<Coord>& A, const GXMatrixMNTC<Coord>& B)
.//SVD/MatrixMNTC.inl:401:    AmB -= B;
.//SVD/MatrixMNTC.inl:473:    GXMatrixMNTC<Coord> operator - (const GXMatrixMNTC<Coord>& M)
.//SVD/MatrixMNTC.inl:477:    Mneg *= -1;
.//SVD/MatrixMNTC.inl:488://// non-member named functions ///////////////////////////////////////////
.//SVD/Ray/mouse.cpp:6:	startX=endX=-1;
.//SVD/Ray/mouse.cpp:7:	startY=endY=-1;
.//SVD/Ray/mouse.cpp:46:	d[0]=x-endX;
.//SVD/Ray/mouse.cpp:47:	d[1]=y-endY;
.//SVD/Ray/rayBox.cpp:25:	fprintf(fp,"#shape_box %d\n",material->index);
.//SVD/Ray/rayBox.h:28:	// Ray-Tracing stuff //
.//SVD/Ray/rayBox.h:30:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//SVD/Ray/rayBox.todo.cpp:7://  Ray-tracing stuff //
.//SVD/Ray/rayBox.todo.cpp:10:	return -1;
.//SVD/Ray/rayBox.todo.cpp:20:	return -1;
.//SVD/Ray/rayCone.cpp:27:	fprintf(fp,"#shape_cone %d\n",material->index);
.//SVD/Ray/rayCone.h:6:/** This class represents a cone whose central axis isparallel to the y-axis, and 
.//SVD/Ray/rayCone.h:29:	// Ray-Tracing stuff //
.//SVD/Ray/rayCone.h:31:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//SVD/Ray/rayCone.todo.cpp:8://  Ray-tracing stuff //
.//SVD/Ray/rayCone.todo.cpp:11:	return -1;
.//SVD/Ray/rayCone.todo.cpp:22:	return -1;
.//SVD/Ray/rayCylinder.cpp:28:	fprintf(fp,"#shape_cylinder %d\n",material->index);
.//SVD/Ray/rayCylinder.h:6:/** This class represents a cylinder whose central axis is parallel to the y-axis, 
.//SVD/Ray/rayCylinder.h:28:	// Ray-Tracing stuff //
.//SVD/Ray/rayCylinder.h:30:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//SVD/Ray/rayCylinder.todo.cpp:8://  Ray-tracing stuff //
.//SVD/Ray/rayCylinder.todo.cpp:11:	return -1;
.//SVD/Ray/rayCylinder.todo.cpp:22:	return -1;
.//SVD/Ray/rayDirectionalLight.h:18:	// Ray-Tracing stuff //
.//SVD/Ray/rayDirectionalLight.todo.cpp:7://  Ray-tracing stuff //
.//SVD/Ray/rayFileInstance.cpp:11:	fprintf(fp,"#ray_file_instance %d\n",rayFile->index);
.//SVD/Ray/rayFileInstance.cpp:14:	return rayFile->scene->group->intersect(ray,iInfo,mx);
.//SVD/Ray/rayFileInstance.cpp:18:	bBox=rayFile->scene->group->setBoundingBox();
.//SVD/Ray/rayFileInstance.cpp:22:int RayFileInstance::isStatic(void){return rayFile->scene->group->isStatic();}
.//SVD/Ray/rayFileInstance.cpp:29:int RayFileInstance::drawOpenGL(int materialIndex){return rayFile->scene->group->drawOpenGL(materialIndex);}
.//SVD/Ray/rayFileInstance.h:8:/** This subclass of RayShape stores a reference to a .ray file included in the scene-graph.*/
.//SVD/Ray/rayFileInstance.h:17:	// Ray-Tracing stuff //
.//SVD/Ray/rayFileInstance.h:19:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//SVD/Ray/rayGroup.cpp:13:	if(i1->t < i2->t){return -1;}
.//SVD/Ray/rayGroup.cpp:14:	else if(i2->t<i1->t){return 1;}
.//SVD/Ray/rayGroup.cpp:40:	for(int i=0;i<sNum;i++){shapes[i]->write(indent+2,fp);}
.//SVD/Ray/rayGroup.cpp:58:	for(i=0;i<sNum;i++){if(!shapes[i]->isStatic()){s=0;}}
.//SVD/Ray/rayGroup.cpp:59:	for(i=0;i<sNum;i++){shapes[i]->setUpOpenGL(cplx,setCallList && (!s));}
.//SVD/Ray/rayGroup.cpp:119:	for(int i=0;i<sNum;i++){if(!shapes[i]->isStatic()){return 0;}}
.//SVD/Ray/rayGroup.h:32:	/** An array of RayShapeHit elements that can be used for bounding-volume sorting*/
.//SVD/Ray/rayGroup.h:59:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//SVD/Ray/rayGroup.h:147:/** This class represents a parametrizable transformation that stores a pointer to the 3x3 skew-symmetric logarithm of the
.//SVD/Ray/rayGroup.h:148:  * rotation and a pointer to the translation vector. When it returns a transformation, it exponentiates the 3x3 skew-symmetric
.//SVD/Ray/rayGroup.h:157:  * unit-quaternion obtained by normalizing. */
.//SVD/Ray/rayGroup.todo.cpp:6://  Ray-tracing stuff //
.//SVD/Ray/rayGroup.todo.cpp:9:	return -1;
.//SVD/Ray/rayGroup.todo.cpp:27:	return -1;
.//SVD/Ray/rayKey.cpp:31:	return -1;
.//SVD/Ray/rayKey.cpp:155:	type=-1;
.//SVD/Ray/rayKey.cpp:165:	type=-1;
.//SVD/Ray/rayKey.cpp:169:	for(int i=0;i<pNum;i++){sampleData[i]->setCurrentValue(t,curveType);}
.//SVD/Ray/rayKey.cpp:183:		matrix->value=&(((ParameterSamples<Matrix4D>*)sampleData[i])->currentValue);
.//SVD/Ray/rayKey.cpp:188:		eulerAndTranslation->value=&(((ParameterSamples<EulerAnglesAndTranslation>*)sampleData[i])->currentValue);
.//SVD/Ray/rayKey.cpp:193:		rClosestAndTranslation->value=&(((ParameterSamples<RotationAndTranslation>*)sampleData[i])->currentValue);
.//SVD/Ray/rayKey.cpp:198:		rLogarithmAndTranslation->value=&(((ParameterSamples<LogRotationAndTranslation>*)sampleData[i])->currentValue);
.//SVD/Ray/rayKey.cpp:203:		quaternionAndTranslation->value=&(((ParameterSamples<QuaternionAndTranslation>*)sampleData[i])->currentValue);
.//SVD/Ray/rayKey.cpp:234:		if(!sampleData[i] || !sampleData[i]->set(keyFile.samples())){
.//SVD/Ray/rayKey.cpp:241:				((ParameterSamples<Matrix4D>*)sampleData[i])->samples[j]=keyFile[j][i];
.//SVD/Ray/rayKey.cpp:245:					((ParameterSamples<EulerAnglesAndTranslation>*)sampleData[i])->samples[j]=
.//SVD/Ray/rayKey.cpp:246:						EulerAnglesAndTranslation(keyFile[j][i],((ParameterSamples<EulerAnglesAndTranslation>*)sampleData[i])->samples[j-1]);
.//SVD/Ray/rayKey.cpp:248:				else{((ParameterSamples<EulerAnglesAndTranslation>*)sampleData[i])->samples[j]=keyFile[j][i];}
.//SVD/Ray/rayKey.cpp:251:				((ParameterSamples<RotationAndTranslation>*)sampleData[i])->samples[j]=keyFile[j][i];
.//SVD/Ray/rayKey.cpp:255:					((ParameterSamples<LogRotationAndTranslation>*)sampleData[i])->samples[j]=
.//SVD/Ray/rayKey.cpp:256:						LogRotationAndTranslation(keyFile[j][i],((ParameterSamples<LogRotationAndTranslation>*)sampleData[i])->samples[j-1]);
.//SVD/Ray/rayKey.cpp:258:				else{((ParameterSamples<LogRotationAndTranslation>*)sampleData[i])->samples[j]=keyFile[j][i];}
.//SVD/Ray/rayKey.cpp:262:					((ParameterSamples<QuaternionAndTranslation>*)sampleData[i])->samples[j]=
.//SVD/Ray/rayKey.cpp:263:						QuaternionAndTranslation(keyFile[j][i],((ParameterSamples<QuaternionAndTranslation>*)sampleData[i])->samples[j-1]);
.//SVD/Ray/rayKey.cpp:265:				else{((ParameterSamples<QuaternionAndTranslation>*)sampleData[i])->samples[j]=keyFile[j][i];}
.//SVD/Ray/rayKey.h:6:/** This class stores the matrix samples for all the parameters of the key-frames read out from a .key file */
.//SVD/Ray/rayKey.h:21:	/** This method provides access to the i-th row of transformation information.
.//SVD/Ray/rayKey.h:22:	  * The ordering is such that the (i,j)-th entry corresponds to the i-th sample of the j-th parameter.*/
.//SVD/Ray/rayKey.h:24:	/** This method returns the name of the i-th parameter */
.//SVD/Ray/rayKey.h:26:	/** This method returns the index of the parameter with the specified name. -1 is returned if no parameter matches the name. */
.//SVD/Ray/rayKey.h:28:	/** This method returns the number of key-frames stored. */
.//SVD/Ray/rayKey.h:50:	/** This method sets the RayKeyData object from a collection of key-frame transformations, using the specified type to indicate how the transformations
.//SVD/Ray/rayKey.h:53:	/** Tis method updates the in-between value of all the parameters, using the interpolation/approximation method specified by curveType. */
.//SVD/Ray/rayKey.h:56:	/** This method returns a ParametrizedRayGroup object which links to the in-between value of the i-th parameter.*/
.//SVD/Ray/rayLight.h:19:	// Ray-Tracing stuff //
.//SVD/Ray/rayPointLight.h:5:/** This class describes a point-light light-source. This light has a fixed 
.//SVD/Ray/rayPointLight.h:6:  * position and the light attenuates as function of the distance from the light-source.
.//SVD/Ray/rayPointLight.h:10:	/** The position of the spot-light */
.//SVD/Ray/rayPointLight.h:25:	// Ray-Tracing stuff //
.//SVD/Ray/rayPointLight.todo.cpp:7://  Ray-tracing stuff //
.//SVD/Ray/rayScene.cpp:39:	index=-1;
.//SVD/Ray/rayScene.cpp:44:	this->foo[0]=0;
.//SVD/Ray/rayScene.cpp:57:		if(foo[strlen(foo)-1]=='!'){foo[strlen(foo)-1]='\0';}
.//SVD/Ray/rayScene.cpp:64:	if(!tex){i=-1;}
.//SVD/Ray/rayScene.cpp:65:	else{i=tex->index;}
.//SVD/Ray/rayScene.cpp:91:	if(!img->ReadImage(filename)){
.//SVD/Ray/rayScene.cpp:120:	if(fscanf(fp," %s",filename) != 1 || !scene->read(filename,transformType)){
.//SVD/Ray/rayScene.cpp:182:	if(camera){camera->write(fp);}
.//SVD/Ray/rayScene.cpp:194:		for(i=0;i<lightNum;i++){lights[i]->write(fp);}
.//SVD/Ray/rayScene.cpp:216:	for(i=0;i<group->shapeNum();i++){group->shapes[i]->write(0,fp);}
.//SVD/Ray/rayScene.cpp:233:	int indL=-1, indM=-1, indT=-1,indRF=-1,indV=-1,indK=-1;
.//SVD/Ray/rayScene.cpp:239:	group->set(Matrix4D::IdentityMatrix());
.//SVD/Ray/rayScene.cpp:242:	lightNum=-1;
.//SVD/Ray/rayScene.cpp:243:	textureNum=-1;
.//SVD/Ray/rayScene.cpp:244:	materialNum=-1;
.//SVD/Ray/rayScene.cpp:245:	rayFileNum=-1;
.//SVD/Ray/rayScene.cpp:246:	vertexNum=-1;
.//SVD/Ray/rayScene.cpp:247:	keyFileNum=-1;
.//SVD/Ray/rayScene.cpp:277:				if(!camera->read(fp)){
.//SVD/Ray/rayScene.cpp:344:			if(lightNum>-1){
.//SVD/Ray/rayScene.cpp:375:			if(textureNum>-1){
.//SVD/Ray/rayScene.cpp:406:			if(materialNum>-1){
.//SVD/Ray/rayScene.cpp:439:			if(vertexNum>-1){
.//SVD/Ray/rayScene.cpp:470:			if(rayFileNum>-1){ParseLineError(cmndCtr,"attempted to define ray_file_num more than once\n");}
.//SVD/Ray/rayScene.cpp:483:		//Next we try read out the number of key-files. We make sure that we have
.//SVD/Ray/rayScene.cpp:485:		//of key-files is only specified once. Once we have a "good" ray file
.//SVD/Ray/rayScene.cpp:490:			if(keyFileNum>-1){ParseLineError(cmndCtr,"attempted to define key_file_num more than once\n");}
.//SVD/Ray/rayScene.cpp:516:			if(textureNum == -1){
.//SVD/Ray/rayScene.cpp:537:			if(materialNum==-1){
.//SVD/Ray/rayScene.cpp:549:					if(temp==-1){materials[indM].tex=NULL;}
.//SVD/Ray/rayScene.cpp:570:			if(vertexNum==-1){
.//SVD/Ray/rayScene.cpp:587:			if(rayFileNum==-1){ParseLineError(cmndCtr,"attempted to define ray_files before ray_file_num\n");}
.//SVD/Ray/rayScene.cpp:602:			if(lightNum==-1){ParseLineError(cmndCtr,"attempted to define lights before light_num\n");}
.//SVD/Ray/rayScene.cpp:610:				if(!lights[indL]->read(fp)){ParseLineError(cmndCtr,"failed to parse light\n");}
.//SVD/Ray/rayScene.cpp:618:			if(keyFileNum==-1){ParseLineError(cmndCtr,"attempted to define key_files before key_file_num\n");}
.//SVD/Ray/rayScene.cpp:640:		//We check if we have come to the end of a scene-graph group. If we have
.//SVD/Ray/rayScene.cpp:656:	if(indL<(lightNum-1)){ParseError("Couldn't find enough lights for light_num");}
.//SVD/Ray/rayScene.cpp:657:	if(indM<(materialNum-1)){ParseError("Couldn't find enough materials for material_num");}
.//SVD/Ray/rayScene.cpp:658:	if(indT<(textureNum-1)){ParseError("Couldn't find enough textures for texture_num");}
.//SVD/Ray/rayScene.cpp:659:	if(indRF<(rayFileNum-1)){ParseError("Couldn't find enough ray_files for ray_file_num");}
.//SVD/Ray/rayScene.cpp:660:	if(lightNum==-1){lightNum=0;}
.//SVD/Ray/rayScene.cpp:661:	if(materialNum==-1){materialNum=0;}
.//SVD/Ray/rayScene.cpp:662:	if(textureNum==-1){textureNum=0;}
.//SVD/Ray/rayScene.cpp:663:	if(rayFileNum==-1){rayFileNum=0;}
.//SVD/Ray/rayScene.cpp:664:	if(vertexNum==-1){vertexNum=0;}
.//SVD/Ray/rayScene.cpp:673:	if(!newNode || !((StaticRayGroup*)newNode)->read(fp)){ParseLineError(cmndCtr,"failed to allocate memory for StaticGroup\n");}
.//SVD/Ray/rayScene.cpp:674:	currNode->addShape(newNode);
.//SVD/Ray/rayScene.cpp:682:		/* We check if we have come to the end of a scene-graph group and we
.//SVD/Ray/rayScene.cpp:698:	int i,idx=-1;
.//SVD/Ray/rayScene.cpp:708:	strcpy(newNode->pName,paramName);
.//SVD/Ray/rayScene.cpp:709:	currNode->addShape(newNode);
.//SVD/Ray/rayScene.cpp:743:		current->addShape(rayFileInstance);
.//SVD/Ray/rayScene.cpp:751:		if(!sphere || !sphere->read(fp,&temp)){ParseLineError(cmndCtr,"failed to allocate memory for Sphere\n");}
.//SVD/Ray/rayScene.cpp:754:		else{sphere->material=&(materials[temp]);}
.//SVD/Ray/rayScene.cpp:755:		current->addShape(sphere);
.//SVD/Ray/rayScene.cpp:761:		if (!box || !box->read(fp,&temp)){ParseLineError(cmndCtr,"failed to allocate memory for Box\n");}
.//SVD/Ray/rayScene.cpp:764:		else{box->material=&(materials[temp]);}
.//SVD/Ray/rayScene.cpp:765:		current->addShape(box);
.//SVD/Ray/rayScene.cpp:771:		if(!cone || !cone->read(fp,&temp)){ParseLineError(cmndCtr,"failed to allocate memory for Cone\n");}
.//SVD/Ray/rayScene.cpp:774:		else{cone->material=&(materials[temp]);}
.//SVD/Ray/rayScene.cpp:775:		current->addShape(cone);
.//SVD/Ray/rayScene.cpp:781:		if (!cylinder || !cylinder->read(fp,&temp)){ParseLineError(cmndCtr,"failed to allocate memory for Cylinder\n");}
.//SVD/Ray/rayScene.cpp:784:		else{cylinder->material=&(materials[temp]);}
.//SVD/Ray/rayScene.cpp:785:		current->addShape(cylinder);
.//SVD/Ray/rayScene.cpp:791:		if(!triangle->read(fp,&temp,vertices,vertexNum)){
.//SVD/Ray/rayScene.cpp:797:		else{triangle->material=&(materials[temp]);}
.//SVD/Ray/rayScene.cpp:798:		current->addShape(triangle);
.//SVD/Ray/rayScene.cpp:808:	for(i=0;i<rayFileNum;i++){rayFiles[i].scene->setUpOpenGL(cplx);}
.//SVD/Ray/rayScene.cpp:810:	group->setUpOpenGL(cplx,1);
.//SVD/Ray/rayScene.cpp:813:	camera->drawOpenGL();
.//SVD/Ray/rayScene.cpp:816:	for(int i=0;i<lightNum;i++){lights[i]->drawOpenGL(i);}	
.//SVD/Ray/rayScene.cpp:818:	group->drawOpenGL(-1);
.//SVD/Ray/rayScene.cpp:824:		tt-=(int)tt;
.//SVD/Ray/rayScene.cpp:827:	for(i=0;i<rayFileNum;i++){rayFiles[i].scene->setCurrentTime(t,curveFit);}
.//SVD/Ray/rayScene.cpp:838:	ray.position=camera->position;
.//SVD/Ray/rayScene.cpp:843:			ray=GetRay(camera,i,height-j-1,width,height);
.//SVD/Ray/rayScene.h:61:	/** The coefficient for the specular fall-off of the material */
.//SVD/Ray/rayScene.h:107:/** This class stores information about the scene-graph read out from a .ray file. */
.//SVD/Ray/rayScene.h:119:	/** This method reads in ray-file name from the .ray file and reads the scene-graph from the specified file.*/
.//SVD/Ray/rayScene.h:121:	/** This method writes out ray-file name to a .ray file. If no file is specified,
.//SVD/Ray/rayScene.h:122:	  * the ray-file name is written out to stdout. */
.//SVD/Ray/rayScene.h:156:	/** The root of the scene-graph */
.//SVD/Ray/rayScene.h:165:	/** This method reads in the scene-graph from a .ray file. */
.//SVD/Ray/rayScene.h:167:	/** This method reads in the scene-graph from a .ray file. */
.//SVD/Ray/rayScene.h:169:	/** This method writes out the scene-graph to a .ray file. */
.//SVD/Ray/rayScene.h:171:	/** This method writes out the scene-graph to a .ray file. If no file is specified the scene-graph is written out stdout. */
.//SVD/Ray/rayScene.h:175:	// Ray-Tracing stuff //
.//SVD/Ray/rayScene.h:191:	/** This is the function responsible for the recursive ray-tracing returning the color obtained
.//SVD/Ray/rayScene.h:193:	  * or the contribution from subsequent bounces is guaranteed to be less than the cut-off.\n
.//SVD/Ray/rayScene.todo.cpp:7:// Ray-tracing stuff //
.//SVD/Ray/rayShape.h:7:/** This is the abstract class that all ray-traceable objects must implement. */
.//SVD/Ray/rayShape.h:21:	// Ray-Tracing stuff //
.//SVD/Ray/rayShape.h:26:	  * set and a value greater than 0 is returned. Otherwise, -1 is returned. (This is useful for
.//SVD/Ray/rayShape.h:30:	virtual double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1)=0;
.//SVD/Ray/raySphere.cpp:23:	fprintf(fp,"#shape_sphere %d\n",material->index);
.//SVD/Ray/raySphere.h:27:	// Ray-Tracing stuff //
.//SVD/Ray/raySphere.h:29:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//SVD/Ray/raySphere.todo.cpp:7://  Ray-tracing stuff //
.//SVD/Ray/raySphere.todo.cpp:10:	return -1;
.//SVD/Ray/raySphere.todo.cpp:20:	return -1;
.//SVD/Ray/raySpotLight.h:5:/** This class describes a spot-light light-source. This light has a fixed 
.//SVD/Ray/raySpotLight.h:7:  * function of the distance from the light-source and the angle between the
.//SVD/Ray/raySpotLight.h:14:	/** The position of the spot-light */
.//SVD/Ray/raySpotLight.h:26:	/** The cut-off angle for the spot light (should be in the range [0,Pi/2]) */
.//SVD/Ray/raySpotLight.h:28:	/** The rate at which the intensity falls off as light travels in the non-preferred direction (should be in the range [0,128]) */
.//SVD/Ray/raySpotLight.h:37:	// Ray-Tracing stuff //
.//SVD/Ray/raySpotLight.todo.cpp:8://  Ray-tracing stuff //
.//SVD/Ray/rayTriangle.cpp:35:	fprintf(fp,"#shape_triangle %d\n",material->index);
.//SVD/Ray/rayTriangle.cpp:37:	fprintf(fp,"  %d %d %d\n",v[0]->index,v[1]->index,v[2]->index);
.//SVD/Ray/rayTriangle.h:35:	// Ray-Tracing stuff //
.//SVD/Ray/rayTriangle.h:37:	double intersect(Ray3D ray,struct RayIntersectionInfo& iInfo,double mx=-1);
.//SVD/Ray/rayTriangle.todo.cpp:7://  Ray-tracing stuff //
.//SVD/Ray/rayTriangle.todo.cpp:12:	return -1;
.//SVD/Ray/rayTriangle.todo.cpp:22:	return -1;
.//SVD/Ray/rayWindow.cpp:62:/** This function writes out the specified string, left-aligned, at the specified location, onto the OpenGL window. */
.//SVD/Ray/rayWindow.cpp:93:/** This function writes out the specified string, right-aligned, at the specified location, onto the OpenGL window. */
.//SVD/Ray/rayWindow.cpp:98:	WriteLeftString(vp[2]-x-glutBitmapLength(GLUT_BITMAP_HELVETICA_18,(unsigned char*) str),y,str);
.//SVD/Ray/rayWindow.cpp:117:			temp=0+j*3+(vp[3]-i-1)*(vp[2])*3;
.//SVD/Ray/rayWindow.cpp:119:			temp=1+j*3+(vp[3]-i-1)*(vp[2])*3;
.//SVD/Ray/rayWindow.cpp:121:			temp=2+j*3+(vp[3]-i-1)*(vp[2])*3;
.//SVD/Ray/rayWindow.cpp:133:	scene->setCurrentTime(GetTime()-startTime,curveFit);
.//SVD/Ray/rayWindow.cpp:155:		scene->camera->rotateUp(center,0.01*d[0]);
.//SVD/Ray/rayWindow.cpp:156:		scene->camera->rotateRight(center,0.01*d[1]);
.//SVD/Ray/rayWindow.cpp:159:		scene->camera->moveForward(radius/15*d[1]);
.//SVD/Ray/rayWindow.cpp:162:		scene->camera->moveRight(-radius/250*d[0]);
.//SVD/Ray/rayWindow.cpp:163:		scene->camera->moveUp(radius/250*d[1]);
.//SVD/Ray/rayWindow.cpp:195:				scene->camera->position[0],scene->camera->position[1],scene->camera->position[2],
.//SVD/Ray/rayWindow.cpp:196:				scene->camera->direction[0],scene->camera->direction[1],scene->camera->direction[2],
.//SVD/Ray/rayWindow.cpp:197:				scene->camera->up[0],scene->camera->up[1],scene->camera->up[2]);
.//SVD/Ray/rayWindow.cpp:255:/** This function is called when the user updates the draw mode in the drop-down menu. */
.//SVD/Ray/rayWindow.cpp:261:/** This function is called when the user updates the cull mode in the drop-down menu. */
.//SVD/Ray/rayWindow.cpp:271:/** This function is called when the user updates the curve fitting method in the drop-down menu. */
.//SVD/Ray/rayWindow.cpp:277:/** This function is called when the user selects one of the main menu options in the drop-down menu. */
.//SVD/Ray/rayWindow.cpp:293:	float d=radius+(scene->camera->position-center).length();
.//SVD/Ray/rayWindow.cpp:299:	gluPerspective(scene->camera->heightAngle*180.0/PI,scene->camera->aspectRatio,.1*d,2*d);
.//SVD/Ray/rayWindow.cpp:304:	if(drawMode[0]==GL_FILL){scene->drawOpenGL();}
.//SVD/Ray/rayWindow.cpp:310:		scene->drawOpenGL();
.//SVD/Ray/rayWindow.cpp:317:		scene->drawOpenGL();
.//SVD/Ray/rayWindow.cpp:327:		frameRate=10/(frameCountStart-t);
.//SVD/Ray/rayWindow.cpp:347:	scene->camera->aspectRatio=(float)width/(float)height;
.//SVD/Ray/rayWindow.cpp:364:	BoundingBox3D b=scene->group->setBoundingBox();
.//SVD/Ray/rayWindow.cpp:366:	radius=(b.p[0]-b.p[1]).length()/2;
.//SVD/Ray/rayWindow.cpp:375:	glClearColor(scene->background[0],scene->background[1],scene->background[2],1.0);
.//SVD/Ray/rayWindow.cpp:402:	glutAddMenuEntry(" Catmull-Rom Interpolation ",CATMULL_ROM);
.//SVD/Ray/rayWindow.cpp:403:	glutAddMenuEntry(" Uniform Cubic B-Spline Approximation ", UNIFORM_CUBIC_B_SPLINE);
.//SVD/Ray/rayWindow.cpp:411:	// Attach the drop-down menu to the right button
.//SVD/Ray/rayWindow.cpp:424:	scene->setUpOpenGL(cplx);
.//SVD/Ray/rayWindow.h:15:		/** A value indicating that back-face culling should be used */
.//SVD/Ray/rayWindow.h:17:		/** A value indicating that front-face culling should be used */
.//SVD/Ray/rayWindow.h:49:	/** This function writes out the specified string, left-aligned, at the specified location, onto the OpenGL window. */
.//SVD/Ray/rayWindow.h:51:	/** This function writes out the specified string, right-aligned, at the specified location, onto the OpenGL window. */
.//SVD/Ray/rayWindow.h:81:	/** This function is called when the user updates the draw mode in the drop-down menu. */
.//SVD/Ray/rayWindow.h:83:	/** This function is called when the user updates the cull mode in the drop-down menu. */
.//SVD/Ray/rayWindow.h:85:	/** This function is called when the user updates the curve fitting method in the drop-down menu. */
.//SVD/Ray/rayWindow.h:87:	/** This function is called when the user selects one of the main menu options in the drop-down menu. */
.//SVD/SVD.h:5:// Abstract:  Singular-Value Decomposition.  Numerous informative comments 
.//SVD/SVD.h:11:// xxMay1993 Ronen Barzel    ANSI-C backsubst
.//SVD/SVD.inl:5:// Abstract:  Singular-Value Decomposition.  Numerous informative comments 
.//SVD/SVD.inl:11:// xxMay1993 Ronen Barzel    ANSI-C backsubst
.//SVD/SVD.inl:19:** Singular-Value Decomposition.
.//SVD/SVD.inl:31:        Algorithm 8.3-2: The SVD Algorithm
.//SVD/SVD.inl:35:                 +-            -+
.//SVD/SVD.inl:37:                 |  0   A22  0  |        n-p-q
.//SVD/SVD.inl:39:                 |  0    0   0  |         m-n
.//SVD/SVD.inl:40:                 +-            -+
.//SVD/SVD.inl:49:                     +-   -+
.//SVD/SVD.inl:53:                     +-   -+
.//SVD/SVD.inl:60:cannot be applied -- A22 has a diagonal entry that is zero, but there
.//SVD/SVD.inl:62:do seems to be to special-case: If A22 has 0 in its lower-right
.//SVD/SVD.inl:89:**	 (ansi-C, backsubst: May 1993)
.//SVD/SVD.inl:118:** (inclusive) (where i and j go from 0 to n-1).  Performs a householder
.//SVD/SVD.inl:139:		snorm,		/* +/- the norm of X1 */
.//SVD/SVD.inl:143:    /* we will scale X1 by its l1-norm.  squawk! */
.//SVD/SVD.inl:149:    /* divide out the l1-norm, and calculate sigma = |X|^2 */
.//SVD/SVD.inl:153:    /* The householder vector is X1 +/- (|X1|,0,0,...).  We will
.//SVD/SVD.inl:158:    snorm = ((REAL) ((f > 0) ? -sqrt(sigma) : sqrt(sigma)));
.//SVD/SVD.inl:159:    h = f*snorm - sigma;	/* eqn 11.2.4 in Press et.al. */
.//SVD/SVD.inl:160:    hv[i] = f - snorm;
.//SVD/SVD.inl:162:    /* set the first column of a to be the (|X1|,0,...) -- this is
.//SVD/SVD.inl:169:    ** the columns.  If the householder vector is X, and -half its norm^2
.//SVD/SVD.inl:207:    snorm = ((REAL) ((f > 0) ? -sqrt(sigma) : sqrt(sigma)));
.//SVD/SVD.inl:208:    h = f*snorm - sigma;
.//SVD/SVD.inl:209:    hv[j] = f - snorm;
.//SVD/SVD.inl:240:	REF2D(a,mm,nn,k,j) = -sin*x + cos*y;
.//SVD/SVD.inl:258:	REF2D(a,mm,nn,j,k) = -sin*x + cos*y;
.//SVD/SVD.inl:264:** must be bidiagonal, with a zero in the upper-left corner element.  Mucks
.//SVD/SVD.inl:273:** Where R & X's are different & non-zero.  We can rotate the first
.//SVD/SVD.inl:309:** must be bidiagonal, with a zero in the lower-right corner element.  Mucks
.//SVD/SVD.inl:318:** Where R & X's are different & non-zero.  We can rotate the last
.//SVD/SVD.inl:319:** and second-to-last columns, yielding
.//SVD/SVD.inl:324:** with new R's and X's.  We rotate the last and third-to-last cols, moving
.//SVD/SVD.inl:334:    for (i=z-1; i>=p; i--) {
.//SVD/SVD.inl:346:	if (i != p) rotate_cols(i,z,cos,sin,b,i-1,1,m,n);
.//SVD/SVD.inl:354:** must be bidiagonal except that the topmost subdiagonal element is non-zero.
.//SVD/SVD.inl:363:** Where R & X's are different & non-zero.  We can rotate the first and
.//SVD/SVD.inl:423:** This is the first part of an implicit-shift QR step.  We do some
.//SVD/SVD.inl:425:** the top-left corner.
.//SVD/SVD.inl:427:** This rotation is described as part of Golub's Algorithm 3.3-1
.//SVD/SVD.inl:435:**   - Ignoring the R's, one serially computes An+1 = Qn^t An Q
.//SVD/SVD.inl:436:**   - Eventually, An will approach diagonal
.//SVD/SVD.inl:437:**   - The rate of convergence goes like A[i,j] = u_i/u_j, where
.//SVD/SVD.inl:439:**   - To make it converge faster, we shift the eigenvalues by some amount
.//SVD/SVD.inl:440:**     ("uu" in the code) by decomposing the matrix A - uu I.
.//SVD/SVD.inl:441:**   - uu is computed so as to attempt to minimize (u_i-uu)/(u_j-uu), which
.//SVD/SVD.inl:446:**   - Rather than actually computing the matrix A - uu I, we just keep
.//SVD/SVD.inl:457:** bidiagonal matrix, based on the eigenvalue-shift stuff.  This
.//SVD/SVD.inl:459:** clean up the non-bidiagonal terms.  The net rotation that is performed
.//SVD/SVD.inl:478:    fm = (q-2) < 0 ? 0 : REF2D(b,m,n,q-2,q-1);
.//SVD/SVD.inl:479:    dm = REF2D(b,m,n,q-1,q-1);	fn = REF2D(b,m,n,q-1,q);
.//SVD/SVD.inl:490:    ** b = -(t11+t22)
.//SVD/SVD.inl:491:    ** c = t11 t22 - t12 t12
.//SVD/SVD.inl:493:    ** b^2 - 4ac = (t11^2 + t22^2 + 2 t11 t12) - 4 t11 t22 + 4 t12 t12
.//SVD/SVD.inl:494:    **           = (t11 - t22)^2 + 4 t12 t12
.//SVD/SVD.inl:496:    ** sqrt(b^2-4ac) = sqrt((t11 - t22)^2 + 4 t12 t12) -- use "pythag()"
.//SVD/SVD.inl:499:    ** (u1,u2) = .5 (t11 + t22 +/- pythag(...))
.//SVD/SVD.inl:500:    **         = t22 + .5 (t11 - t22 +/- pythag(...))
.//SVD/SVD.inl:502:    ** We propogate the .5 into the pythag term, yielding golub's equation 8.2-2
.//SVD/SVD.inl:504:    ** [Note:  Golub says to use (t22 + d - signum(d) s) to find the eigenvalue
.//SVD/SVD.inl:507:    d = ((REAL) 0.5)*(t11 - t22);
.//SVD/SVD.inl:509:    uu = t22 + d + ((d > 0) ? -s : s);
.//SVD/SVD.inl:518:    /* calculate the rotation that would zero the off-diagonal term of the
.//SVD/SVD.inl:519:    ** shifted matrix T - uu I
.//SVD/SVD.inl:521:    y = t11 - uu;
.//SVD/SVD.inl:527:    /* perform the rotation on B.  This sprays some glop into the upper-left
.//SVD/SVD.inl:545:** transformations to zero-out the off-diagonal elements, while
.//SVD/SVD.inl:577:       leaves a non-0 element in the [m-1,m]th spot.
.//SVD/SVD.inl:583:    /* For non-square arrays, lop off the parts we don't need */
.//SVD/SVD.inl:601:** left- and right-hand transforms into u and v.  The matrix
.//SVD/SVD.inl:610:** This is Golub's SVD algorithm (Algorithm 8.3-2)
.//SVD/SVD.inl:629:	    t = ((REAL) (fabs(REF2D(b,m,n,i,i)) + fabs(REF2D(b,m,n,i-1,i))));
.//SVD/SVD.inl:636:    ** element above b[q][q] -- i.e. b[q][q] will be a singular value.
.//SVD/SVD.inl:638:    for (q = min-1; q>=0; q--) {
.//SVD/SVD.inl:649:	    ** b33 goes from q+1 to n-1 -- it's the part we already did
.//SVD/SVD.inl:650:	    ** b22 goes from p through q -- it's a bidiagonal block
.//SVD/SVD.inl:654:	    for (p = q; p>0; p--) if (REF2D(b,m,n,p-1,p) + anorm == anorm) {
.//SVD/SVD.inl:655:		REF2D(b,m,n,p-1,p) = 0;
.//SVD/SVD.inl:668:		    REF2D(b,m,n,q,q) *= -1;
.//SVD/SVD.inl:669:		    for (j=0; j<n; j++) REF2D(v,min,n,q,j) *= -1;
.//SVD/SVD.inl:675:	    for (z= -1, i=q; i>=p; i--) if (REF2D(b,m,n,i,i)+anorm==anorm) {
.//SVD/SVD.inl:682:		    /* lower-right corner.  clr element above it */
.//SVD/SVD.inl:709:** computes u (m x min)	column-orthonormal
.//SVD/SVD.inl:711:**          vt (min x n)	column-orthonormal
.//SVD/SVD.inl:743:	if (w[i] > w[i-1]) {
.//SVD/SVD.inl:750:	    for (j=i; j>0 && wi > w[j-1]; j--) {
.//SVD/SVD.inl:751:		w[j] = w[j-1];
.//SVD/SVD.inl:752:		for (k=0; k<m; k++) REF2D(u,m,min,k,j)=REF2D(u,m,min,k,j-1);
.//SVD/SVD.inl:753:		for (k=0; k<n; k++) REF2D(vt,min,n,j,k)=REF2D(vt,min,n,j-1,k);
.//SVD/SVD.inl:771:** a vector X.  Takes a condition-threshold factor "eps", singular
.//SVD/SVD.inl:776:**	    u (m x min)			column-orthonormal
.//SVD/SVD.inl:777:**          w (min-element vector)	diagonal elements
.//SVD/SVD.inl:778:**          vt (min x n)		column-orthonormal
.//SVD/SVD.inl:781:**	    b (m-element vector)	
.//SVD/SVD.inl:784:** 	    x (n-element vector)
.//SVD/SVDFit.h:17:// 25Jul1999 ppsloan   SVDMat/Apply added - for saving the SVD of a matrix
.//SVD/SVDFit.h:32:void SVDMat(GXMatrixMNTC<REAL>& A, // input - matrix to apply SVD too...
.//SVD/SVDFit.h:33:            GXMatrixMNTC<REAL>& u, // output - SVD of matrix A...
.//SVD/SVDFit.inl:17:// 25Jul1999 ppsloan   SVDMat/Apply added - for saving the SVD of a matrix
.//SVD/SVDFit.inl:49:    threshold = wmax * ((REAL) 1.0e-5);
.//SVD/SVDFit.inl:59:void SVDMat(GXMatrixMNTC<REAL>& A, // input - matrix to apply SVD too...
.//SVD/SVDFit.inl:60:            GXMatrixMNTC<REAL>& u, // output - SVD of matrix A...
.//SVD/SVDFit.inl:102:    threshold = wmax * ((REAL) 1.0e-5);
.//TestFiles/sphere.ray:9:	-1
.//TestFiles/square.ray:9:	-1
.//TestFiles/square.ray:13:	-2  0  2
.//TestFiles/square.ray:21:	 2  0 -2
.//TestFiles/square.ray:25:	-2  0 -2
.//TestFiles/test.ray:1:#camera 0.0 10.0 0.0   0.0 -1.0 0.0   0.0 0.0 1.0   .523  
.//TestFiles/test.ray:10:	 0.0  -1.0  0.0
.//Util/cmdLineParser.cpp:129:		if (argv[0][0] == '-' && argv[0][1]=='-') {
.//Util/cmdLineParser.cpp:132:					argv++, argc--;
.//Util/cmdLineParser.cpp:133:					j=readable[i]->read(argv,argc);
.//Util/cmdLineParser.cpp:134:					argv+=j,argc-=j;
.//Util/cmdLineParser.cpp:138:			if(i==num){argv++, argc--;}
.//Util/cmdLineParser.cpp:140:		else {argv++, argc--;}
.//Util/cmdLineParser.h:83:  * a "--", so if I would like to set the value of a parameter with name "foo", it has to look like "--foo ..." in
.//Util/geometry.cpp:20:Point2D Point2D::negate(void) const{return scale(-1.0);}
.//Util/geometry.cpp:21:Point2D Point2D::operator -(void) const{return scale(-1.0);}
.//Util/geometry.cpp:50:Point2D Point2D::subtract(const Point2D& q) const {return Point2D(p[0]-q.p[0],p[1]-q.p[1]);}
.//Util/geometry.cpp:51:Point2D Point2D::operator- (const Point2D& q) const {return subtract(q);}
.//Util/geometry.cpp:52:Point2D& Point2D::operator-= (const Point2D& q){
.//Util/geometry.cpp:53:	p[0]-=q.p[0];
.//Util/geometry.cpp:54:	p[1]-=q.p[1];
.//Util/geometry.cpp:85:Point3D Point3D::negate(void) const {return scale(-1.0);}
.//Util/geometry.cpp:86:Point3D Point3D::operator -(void) const {return scale(-1.0);}
.//Util/geometry.cpp:115:Point3D Point3D::subtract(const Point3D& q) const {return Point3D(p[0]-q.p[0],p[1]-q.p[1],p[2]-q.p[2]);}
.//Util/geometry.cpp:116:Point3D  Point3D::operator- (const Point3D& q) const {return subtract(q);}
.//Util/geometry.cpp:117:Point3D& Point3D::operator-=(const Point3D& q){
.//Util/geometry.cpp:118:	p[0]-=q.p[0];
.//Util/geometry.cpp:119:	p[1]-=q.p[1];
.//Util/geometry.cpp:120:	p[2]-=q.p[2];
.//Util/geometry.cpp:124:Point3D Point3D::crossProduct(const Point3D& q) const {return Point3D(p[1]*q.p[2]-p[2]*q.p[1],-p[0]*q.p[2]+p[2]*q.p[0],p[0]*q.p[1]-p[1]*q.p[0]);}
.//Util/geometry.cpp:127:	double temp1= p[1]*q.p[2]-p[2]*q.p[1];
.//Util/geometry.cpp:128:	double temp2=-p[0]*q.p[2]+p[2]*q.p[0];
.//Util/geometry.cpp:129:	p[2]=      p[0]*q.p[1]-p[1]*q.p[0];
.//Util/geometry.cpp:160:	this->normal=normal.unit();
.//Util/geometry.cpp:161:	distance=-this->normal.dot(pt);
.//Util/geometry.cpp:164:	normal=((p2-p1)^(p3-p1)).unit();
.//Util/geometry.cpp:165:	distance=-normal.dot(p1);
.//Util/geometry.cpp:169:		normal=-normal;
.//Util/geometry.cpp:170:		distance=-distance;
.//Util/geometry.cpp:202:	r.position-=p;
.//Util/geometry.cpp:205:Ray3D  Ray3D::operator- (const Point3D& p) const {return subtract(p);}
.//Util/geometry.cpp:206:Ray3D& Ray3D::operator-=(const Point3D& p){
.//Util/geometry.cpp:207:	position-=p;
.//Util/geometry.cpp:235:	return m[0][0]*(m[1][1]*m[2][2]-m[1][2]*m[2][1])-m[1][0]*(m[0][1]*m[2][2]-m[0][2]*m[2][1])+m[2][0]*(m[0][1]*m[1][2]-m[0][2]*m[1][1]);
.//Util/geometry.cpp:237:Matrix3D Matrix3D::operator - (void) const {
.//Util/geometry.cpp:239:	n.m[0][0]=-m[0][0];
.//Util/geometry.cpp:240:	n.m[0][1]=-m[0][1];
.//Util/geometry.cpp:241:	n.m[0][2]=-m[0][2];
.//Util/geometry.cpp:242:	n.m[1][0]=-m[1][0];
.//Util/geometry.cpp:243:	n.m[1][1]=-m[1][1];
.//Util/geometry.cpp:244:	n.m[1][2]=-m[1][2];
.//Util/geometry.cpp:245:	n.m[2][0]=-m[2][0];
.//Util/geometry.cpp:246:	n.m[2][1]=-m[2][1];
.//Util/geometry.cpp:247:	n.m[2][2]=-m[2][2];
.//Util/geometry.cpp:307:Matrix3D  Matrix3D::operator- (const Matrix3D& n) const {
.//Util/geometry.cpp:309:	o.m[0][0]=m[0][0]-n.m[0][0];
.//Util/geometry.cpp:310:	o.m[0][1]=m[0][1]-n.m[0][1];
.//Util/geometry.cpp:311:	o.m[0][2]=m[0][2]-n.m[0][2];
.//Util/geometry.cpp:312:	o.m[1][0]=m[1][0]-n.m[1][0];
.//Util/geometry.cpp:313:	o.m[1][1]=m[1][1]-n.m[1][1];
.//Util/geometry.cpp:314:	o.m[1][2]=m[1][2]-n.m[1][2];
.//Util/geometry.cpp:315:	o.m[2][0]=m[2][0]-n.m[2][0];
.//Util/geometry.cpp:316:	o.m[2][1]=m[2][1]-n.m[2][1];
.//Util/geometry.cpp:317:	o.m[2][2]=m[2][2]-n.m[2][2];
.//Util/geometry.cpp:320:Matrix3D& Matrix3D::operator-=(const Matrix3D& n){
.//Util/geometry.cpp:321:	m[0][0]-=n.m[0][0];
.//Util/geometry.cpp:322:	m[0][1]-=n.m[0][1];
.//Util/geometry.cpp:323:	m[0][2]-=n.m[0][2];
.//Util/geometry.cpp:324:	m[1][0]-=n.m[1][0];
.//Util/geometry.cpp:325:	m[1][1]-=n.m[1][1];
.//Util/geometry.cpp:326:	m[1][2]-=n.m[1][2];
.//Util/geometry.cpp:327:	m[2][0]-=n.m[2][0];
.//Util/geometry.cpp:328:	m[2][1]-=n.m[2][1];
.//Util/geometry.cpp:329:	m[2][2]-=n.m[2][2];
.//Util/geometry.cpp:388:	n.m[0][0]= m[1][1]*m[2][2]-m[1][2]*m[2][1];
.//Util/geometry.cpp:389:	n.m[1][0]=-m[0][1]*m[2][2]+m[0][2]*m[2][1];
.//Util/geometry.cpp:390:	n.m[2][0]= m[0][1]*m[1][2]-m[0][2]*m[1][1];
.//Util/geometry.cpp:391:	n.m[0][1]=-m[1][0]*m[2][2]+m[1][2]*m[2][0];
.//Util/geometry.cpp:392:	n.m[1][1]= m[0][0]*m[2][2]-m[0][2]*m[2][0];
.//Util/geometry.cpp:393:	n.m[2][1]=-m[0][0]*m[1][2]+m[0][2]*m[1][0];
.//Util/geometry.cpp:394:	n.m[0][2]= m[1][0]*m[2][1]-m[1][1]*m[2][0];
.//Util/geometry.cpp:395:	n.m[1][2]=-m[0][0]*m[2][1]+m[0][1]*m[2][0];
.//Util/geometry.cpp:396:	n.m[2][2]= m[0][0]*m[1][1]-m[0][1]*m[1][0];
.//Util/geometry.cpp:403:	n.m[0][0]= m.m[1][1]*m.m[2][2]-m.m[1][2]*m.m[2][1];
.//Util/geometry.cpp:404:	n.m[1][0]=-m.m[0][1]*m.m[2][2]+m.m[0][2]*m.m[2][1];
.//Util/geometry.cpp:405:	n.m[2][0]= m.m[0][1]*m.m[1][2]-m.m[0][2]*m.m[1][1];
.//Util/geometry.cpp:406:	n.m[0][1]=-m.m[1][0]*m.m[2][2]+m.m[1][2]*m.m[2][0];
.//Util/geometry.cpp:407:	n.m[1][1]= m.m[0][0]*m.m[2][2]-m.m[0][2]*m.m[2][0];
.//Util/geometry.cpp:408:	n.m[2][1]=-m.m[0][0]*m.m[1][2]+m.m[0][2]*m.m[1][0];
.//Util/geometry.cpp:409:	n.m[0][2]= m.m[1][0]*m.m[2][1]-m.m[1][1]*m.m[2][0];
.//Util/geometry.cpp:410:	n.m[1][2]=-m.m[0][0]*m.m[2][1]+m.m[0][1]*m.m[2][0];
.//Util/geometry.cpp:411:	n.m[2][2]= m.m[0][0]*m.m[1][1]-m.m[0][1]*m.m[1][0];
.//Util/geometry.cpp:432:	e[1]=asin(-m[0][2]);
.//Util/geometry.cpp:446:		double d=fabs(euler.p[i]-e.p[i]);
.//Util/geometry.cpp:451:				if(fabs(euler.p[i]-e.p[i])<d){
.//Util/geometry.cpp:452:					d=fabs(euler.p[i]-e.p[i]);
.//Util/geometry.cpp:459:				euler.p[i]-=2*PI;
.//Util/geometry.cpp:460:				if(fabs(euler.p[i]-e.p[i])<d){
.//Util/geometry.cpp:461:					d=fabs(euler.p[i]-e.p[i]);
.//Util/geometry.cpp:479:			double temp=m1.m[i][j]-m2.m[i][j];
.//Util/geometry.cpp:508:				if(t1<0){r1(i,j)*=-1;}
.//Util/geometry.cpp:509:				if(t2<0){r2(i,j)*=-1;}
.//Util/geometry.cpp:510:				if(t1*t2<0){d(i,j)*=-1;}
.//Util/geometry.cpp:547:	A=I-A;
.//Util/geometry.cpp:555:	return X*(-pow(2.0,(double)k));
.//Util/geometry.cpp:570:	n.m[1][0]=(m[1][0]-m[0][1])/2;
.//Util/geometry.cpp:571:	n.m[0][1]=-n.m[1][0];
.//Util/geometry.cpp:572:	n.m[2][0]=(m[2][0]-m[0][2])/2;
.//Util/geometry.cpp:573:	n.m[0][2]=-n.m[2][0];
.//Util/geometry.cpp:574:	n.m[1][2]=(m[1][2]-m[2][1])/2;
.//Util/geometry.cpp:575:	n.m[2][1]=-n.m[1][2];
.//Util/geometry.cpp:628:		else{d-=subDet(i,0)*m[i][0];}
.//Util/geometry.cpp:633:	return this->m[c1][r1]*this->m[c2][r2]-this->m[c1][r2]*this->m[c2][r1];
.//Util/geometry.cpp:652:		d+=sgn*this->m[i][row]*subDet(c1,r1,c2,r2);
.//Util/geometry.cpp:653:		sgn*=-1.0;
.//Util/geometry.cpp:657:Matrix4D Matrix4D::operator- (void) const{
.//Util/geometry.cpp:659:	for(int i=0;i<4;i++){for(int j=0;j<4;j++){n.m[i][j]=-m[i][j];}}
.//Util/geometry.cpp:685:		for(j=0;j<4;j++){n(i,j)=this->m[j][i];}
.//Util/geometry.cpp:705:	for(i=0;i<4;i++){for(j=0;j<4;j++){o(i,j)=m[i][j]-n.m[i][j];}}
.//Util/geometry.cpp:708:Matrix4D  Matrix4D::operator- (const Matrix4D& m) const {return subtract(m);}
.//Util/geometry.cpp:709:Matrix4D& Matrix4D::operator-=(const Matrix4D& n){
.//Util/geometry.cpp:710:	for(int i=0;i<4;i++){for(int j=0;j<4;j++){m[i][j]-=n.m[i][j];}}
.//Util/geometry.cpp:725:	for(int i=0;i<4;i++){for(int j=0;j<4;j++){this->m[i][j]*=f;}}
.//Util/geometry.cpp:731:	for(int i=0;i<4;i++){for(int j=0;j<4;j++){this->m[i][j]/=f;}}
.//Util/geometry.cpp:744:			else{m(i,j)=-subDet(j,i)/d;}
.//Util/geometry.cpp:758:			else{out(i,j)=-in.subDet(j,i)/d;}
.//Util/geometry.cpp:770:		q[i]=this->m[3][i];
.//Util/geometry.cpp:771:		for(j=0;j<3;j++){q[i]+=this->m[j][i]*p.p[j];}
.//Util/geometry.cpp:781:		for(j=0;j<3;j++){q[i]+=this->m[j][i]*p.p[j];}
.//Util/geometry.cpp:806:	e[1]=asin(-m[0][2]);
.//Util/geometry.cpp:826:			double temp=m1.m[i][j]-m2.m[i][j];
.//Util/geometry.cpp:864:	if((b.p[0]-b.p[1]).squareNorm()==0.0){return *this;}
.//Util/geometry.cpp:865:	if((p[0]-p[1]).squareNorm()==0.0){return b;}
.//Util/geometry.cpp:876:	if((b.p[0]-b.p[1]).squareNorm()==0.0){return *this;}
.//Util/geometry.cpp:877:	if((p[0]-p[1]).squareNorm()==0.0){
.//Util/geometry.cpp:918:	imag[0]=-1.0/(4*real)*(rot.m[2][1]-rot.m[1][2]);
.//Util/geometry.cpp:919:	imag[1]=-1.0/(4*real)*(rot.m[0][2]-rot.m[2][0]);
.//Util/geometry.cpp:920:	imag[2]=-1.0/(4*real)*(rot.m[1][0]-rot.m[0][1]);
.//Util/geometry.cpp:924:	imag[0]=-1.0/(4*real)*(rot.m[2][1]-rot.m[1][2]);
.//Util/geometry.cpp:925:	imag[1]=-1.0/(4*real)*(rot.m[0][2]-rot.m[2][0]);
.//Util/geometry.cpp:926:	imag[2]=-1.0/(4*real)*(rot.m[1][0]-rot.m[0][1]);
.//Util/geometry.cpp:927:	if(((*this)-quat).squareNorm()>((*this)+quat).squareNorm()){(*this)*=-1;}
.//Util/geometry.cpp:933:double Quaternion::squareNorm(void) const{return this->dot(*this);}
.//Util/geometry.cpp:935:Quaternion Quaternion::operator- (void) const{return Quaternion(-real,-imag);}
.//Util/geometry.cpp:936:Quaternion Quaternion::conjugate(void) const{return Quaternion(real,-imag);}
.//Util/geometry.cpp:956:Quaternion  Quaternion::operator- (const Quaternion& q) const{return Quaternion(real-q.real,imag-q.imag);}
.//Util/geometry.cpp:957:Quaternion& Quaternion::operator-=(const Quaternion& q){
.//Util/geometry.cpp:958:	real-=q.real;
.//Util/geometry.cpp:959:	imag-=q.imag;
.//Util/geometry.cpp:963:	return Quaternion(real*q.real-imag.dot(imag),imag*q.real+q.imag*real+imag^q.imag);
.//Util/geometry.cpp:966:	Quaternion qq(real*q.real-imag.dot(imag),imag*q.real+q.imag*real+imag^q.imag);
.//Util/geometry.cpp:994:EulerAnglesAndTranslation  EulerAnglesAndTranslation::operator-(void) const{
.//Util/geometry.cpp:996:	e.translate=-translate;
.//Util/geometry.cpp:997:	e.eulerAngles=-eulerAngles;
.//Util/geometry.cpp:1033:EulerAnglesAndTranslation  EulerAnglesAndTranslation::operator- (const EulerAnglesAndTranslation& e) const{
.//Util/geometry.cpp:1035:	f.translate=translate-e.translate;
.//Util/geometry.cpp:1036:	f.eulerAngles=eulerAngles-e.eulerAngles;
.//Util/geometry.cpp:1039:EulerAnglesAndTranslation& EulerAnglesAndTranslation::operator-=(const EulerAnglesAndTranslation& e){
.//Util/geometry.cpp:1040:	translate-=e.translate;
.//Util/geometry.cpp:1041:	eulerAngles-=e.eulerAngles;
.//Util/geometry.cpp:1058:RotationAndTranslation  RotationAndTranslation::operator-(void) const{
.//Util/geometry.cpp:1060:	e.translate=-translate;
.//Util/geometry.cpp:1061:	e.rotation=-rotation;
.//Util/geometry.cpp:1097:RotationAndTranslation  RotationAndTranslation::operator- (const RotationAndTranslation& e) const{
.//Util/geometry.cpp:1099:	f.translate=translate-e.translate;
.//Util/geometry.cpp:1100:	f.rotation=rotation-e.rotation;
.//Util/geometry.cpp:1103:RotationAndTranslation& RotationAndTranslation::operator-=(const RotationAndTranslation& e){
.//Util/geometry.cpp:1104:	translate-=e.translate;
.//Util/geometry.cpp:1105:	rotation-=e.rotation;
.//Util/geometry.cpp:1146:		// need to solve for k minimizing ||s1-s2*(n2+2kPI)||
.//Util/geometry.cpp:1156:		t=s2*(n2-2*PI);
.//Util/geometry.cpp:1160:			t-=s2*(2*PI);
.//Util/geometry.cpp:1168:LogRotationAndTranslation  LogRotationAndTranslation::operator-(void) const{
.//Util/geometry.cpp:1170:	e.translate=-translate;
.//Util/geometry.cpp:1171:	e.skewSymmetric=-skewSymmetric;
.//Util/geometry.cpp:1207:LogRotationAndTranslation  LogRotationAndTranslation::operator- (const LogRotationAndTranslation& e) const{
.//Util/geometry.cpp:1209:	f.translate=translate-e.translate;
.//Util/geometry.cpp:1210:	f.skewSymmetric=skewSymmetric-e.skewSymmetric;
.//Util/geometry.cpp:1213:LogRotationAndTranslation& LogRotationAndTranslation::operator-=(const LogRotationAndTranslation& e){
.//Util/geometry.cpp:1214:	translate-=e.translate;
.//Util/geometry.cpp:1215:	skewSymmetric-=e.skewSymmetric;
.//Util/geometry.cpp:1237:QuaternionAndTranslation  QuaternionAndTranslation::operator-(void) const{
.//Util/geometry.cpp:1239:	e.translate=-translate;
.//Util/geometry.cpp:1240:	e.quaternion=-quaternion;
.//Util/geometry.cpp:1276:QuaternionAndTranslation  QuaternionAndTranslation::operator- (const QuaternionAndTranslation& e) const{
.//Util/geometry.cpp:1278:	f.translate=translate-e.translate;
.//Util/geometry.cpp:1279:	f.quaternion=quaternion-e.quaternion;
.//Util/geometry.cpp:1282:QuaternionAndTranslation& QuaternionAndTranslation::operator-=(const QuaternionAndTranslation& e){
.//Util/geometry.cpp:1283:	translate-=e.translate;
.//Util/geometry.cpp:1284:	quaternion-=e.quaternion;
.//Util/geometry.h:4:#define RAYEPS 1e-10
.//Util/geometry.h:37:	Point2D operator- (void) const;
.//Util/geometry.h:61:	Point2D  operator- (const Point2D& pt) const;
.//Util/geometry.h:63:	Point2D& operator-=(const Point2D& pt);
.//Util/geometry.h:65:	/** This method performs a component-wise multiplication of two ponts and returns the product. */
.//Util/geometry.h:67:	/** This method performs a component-wise multiplication of two ponts and returns the product. */
.//Util/geometry.h:72:	/** This method performs a component-wise division of two ponts and returns the ratio. */
.//Util/geometry.h:74:	/** This method performs a component-wise division of two ponts and returns the ratio. */
.//Util/geometry.h:107:	Point3D operator- (void) const;
.//Util/geometry.h:131:	Point3D  operator- (const Point3D& pt) const;
.//Util/geometry.h:133:	Point3D& operator-=(const Point3D& pt);
.//Util/geometry.h:135:	/** This method performs a component-wise multiplication of two ponts and returns the product. */
.//Util/geometry.h:137:	/** This method performs a component-wise multiplication of two ponts and returns the product. */
.//Util/geometry.h:142:	/** This method performs a component-wise division of two ponts and returns the ratio. */
.//Util/geometry.h:144:	/** This method performs a component-wise division of two ponts and returns the ratio. */
.//Util/geometry.h:149:	/** This method returns the cross-product of two points. */
.//Util/geometry.h:151:	/** This method returns the cross-product of two points. */
.//Util/geometry.h:153:	/** This method set the current point to be equal to the cross-product of itself with the input point. */
.//Util/geometry.h:177:	/** This method orients the plane so that the value of the plane function at p is non-negative. */
.//Util/geometry.h:198:	/** This method computes the translation of the ray by -p and returns the translated ray.*/
.//Util/geometry.h:200:	/** This method computes the translation of the ray by -p and returns the translated ray.*/
.//Util/geometry.h:201:	Ray3D  operator- (const Point3D& p) const;
.//Util/geometry.h:202:	/** This method translates the current ray by -p.*/
.//Util/geometry.h:203:	Ray3D& operator-=(const Point3D& p);
.//Util/geometry.h:224:	/** This method returns the entry of the matrix in the col-th column and the row-th row.*/
.//Util/geometry.h:226:	/** This method returns the entry of the matrix in the col-th column and the row-th row.*/
.//Util/geometry.h:233:	Matrix3D operator- (void) const;
.//Util/geometry.h:246:	Matrix3D  operator- (const Matrix3D& m) const;
.//Util/geometry.h:248:	Matrix3D& operator-=(const Matrix3D& m);
.//Util/geometry.h:292:	/** This method returns the square-root of a matrix */
.//Util/geometry.h:307:	/** This method returns nearest skew-symmetric matrix */
.//Util/geometry.h:327:	/** This method returns the entry of the matrix in the col-th column and the row-th row.*/
.//Util/geometry.h:329:	/** This method returns the entry of the matrix in the col-th column and the row-th row.*/
.//Util/geometry.h:336:	Matrix4D operator- (void) const;
.//Util/geometry.h:357:	Matrix4D  operator- (const Matrix4D& m) const;
.//Util/geometry.h:359:	Matrix4D& operator-=(const Matrix4D& m);
.//Util/geometry.h:423:	/** The end-points of the bounding box (all of the coefficients of p[0] are assumed to be less than or equal to the coefficients of p[1]).\n */
.//Util/geometry.h:443:	  * finding the minimal axis-aligned bounding box containing the transformed box. */
.//Util/geometry.h:446:	/** This method returns the distance along the ray to the box if the ray intersects, otherwise it returns -1.0. (The distance is 0.0 if the
.//Util/geometry.h:483:	Quaternion operator- (void) const;
.//Util/geometry.h:506:	Quaternion  operator- (const Quaternion& q) const;
.//Util/geometry.h:508:	Quaternion& operator-=(const Quaternion& q);
.//Util/geometry.h:539:	EulerAnglesAndTranslation operator - (void) const;
.//Util/geometry.h:557:	EulerAnglesAndTranslation  operator- (const EulerAnglesAndTranslation& q) const;
.//Util/geometry.h:559:	EulerAnglesAndTranslation& operator-=(const EulerAnglesAndTranslation& q);
.//Util/geometry.h:574:	RotationAndTranslation operator - (void) const;
.//Util/geometry.h:592:	RotationAndTranslation  operator- (const RotationAndTranslation& q) const;
.//Util/geometry.h:594:	RotationAndTranslation& operator-=(const RotationAndTranslation& q);
.//Util/geometry.h:596:/** This class represents a transformation by the skew-symmetric log of the rotation and the translation */
.//Util/geometry.h:611:	LogRotationAndTranslation operator - (void) const;
.//Util/geometry.h:629:	LogRotationAndTranslation  operator- (const LogRotationAndTranslation& q) const;
.//Util/geometry.h:631:	LogRotationAndTranslation& operator-=(const LogRotationAndTranslation& q);
.//Util/geometry.h:648:	QuaternionAndTranslation operator - (void) const;
.//Util/geometry.h:666:	QuaternionAndTranslation  operator- (const QuaternionAndTranslation& q) const;
.//Util/geometry.h:668:	QuaternionAndTranslation& operator-=(const QuaternionAndTranslation& q);
.//Util/geometry.todo.cpp:11:// Ray-tracing stuff //
.//Util/geometry.todo.cpp:14:	return -1;
.//Util/parameterSamples.h:14:	/** This method updates the value of the in-between value, by computing the interpolation/approximation at value 0<=t<=1.
.//Util/parameterSamples.h:19:  * the  in-between values using linear interpolation or spline methods.
.//Util/parameterSamples.h:29:	/** The computed in-between value */
.//Util/parameterSamples.h:36:	/** This overloaded operator returns a reference to the i-th sample value */
.//Util/parameterSamples.h:38:	/** This method updates the value of the in-between value, by computing the interpolation/approximation at value 0<=t<=1.
